<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Books on stsnブログ</title>
    <link>https://satoshun.github.io/book/</link>
    <description>Recent content in Books on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Fri, 28 Dec 2018 05:27:13 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/book/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>感想: コーディングを支える技術</title>
      <link>https://satoshun.github.io/2018/12/coding_tech/</link>
      <pubDate>Fri, 28 Dec 2018 05:27:13 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/coding_tech/</guid>
      <description>&lt;p&gt;「コーディングを支える技術」を読んだのでざっくりと感想。&lt;/p&gt;&#xA;&lt;p&gt;比較、歴史から学ぶ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;その機能はなにかの問題を解決するために導入されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;歴史から紐解くことでなぜそれが必要かが理解できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;言語によってどの問題を解決したいのかが違う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Python: 同じようなコードになるような言語&lt;/li&gt;&#xA;&lt;li&gt;C++: 高速に動作することを目指している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;エラー処理の進化&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;globalなエラーハンドリングはgotoと変わらない&lt;/li&gt;&#xA;&lt;li&gt;try catch finallyのように構造化されたエラー処理が誕生した&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Javaでは検査型例外、必ずerrorを処理しなければいけない設計&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;アドレスを覚えるのは人間には大変&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人間はメソッド、変数を介することでアドレスを忘れることが出来た&#xA;&lt;ul&gt;&#xA;&lt;li&gt;結果、メソッド名、変数名をいかにしてわかりやすくするかが重要になってきた&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;基本的には何をするかというよりかは、何をさせないかで進化している&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスによるポリモーフィズム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;関数ポインタを直接触らないように&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;gotoの禁止&#xA;&lt;ul&gt;&#xA;&lt;li&gt;構造化、モジュール化できなくなるので&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>感想: オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方</title>
      <link>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</link>
      <pubDate>Tue, 25 Dec 2018 03:00:39 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</guid>
      <description>&lt;p&gt;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方を読んだのでざっくりと感想。&lt;/p&gt;&#xA;&lt;p&gt;継承とコンポジションはトレードオフ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継承は自動的にaメッセージを委譲する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;便利だが依存関係は強い&lt;/li&gt;&#xA;&lt;li&gt;親クラスが変更されたときに、自動的に子クラスにも影響があることを意味する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;継承は階層構造を生み出す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポリモーフィズムを実現する&lt;/li&gt;&#xA;&lt;li&gt;これまた便利だが依存関係は強い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンポジションは自動的に委譲しない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必要に応じて集約クラスで操る必要がある&lt;/li&gt;&#xA;&lt;li&gt;依存は継承より少ない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;単一責任について&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あたりまえだけど守らないといけない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;無駄な責務があると再利用できない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;達成することで再利用可能な素晴らしいクラスが出来る&lt;/li&gt;&#xA;&lt;li&gt;責任の依存先が不明なときは一旦privateとかに切り出しておいて未来に託す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ダックタイピング&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ダックにより、具体的なGearクラスからロールへのマインドシフトが出来る&lt;/li&gt;&#xA;&lt;li&gt;ロールを満たすことにより要件を満たす&lt;/li&gt;&#xA;&lt;li&gt;実装には依存しない、メッセージを送るだけで良い世界はOOPの真骨頂&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;依存関係について&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依存関係の向きを考えるのは大切&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えばコンストラクタ内で依存するのと、インスタンスメソッドだと距離が違う。コンストラクタ内で依存したほうが良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;さらに進めるとDI，コンストラクタの外から注入する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;依存関係逆転の法則&#xA;&lt;ul&gt;&#xA;&lt;li&gt;低レイヤーに依存するのではなく、インターフェースに依存しておいて、あとから実装を注入することで達成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;domain層などの他の層に依存したくない層で有効&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;柔軟なインターフェース&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オブジェクトを信じるようなインターフェース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのようにするかではなく、何をするかをメソッド名にする。宣言的に&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;安定していなければいけない&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>感想: Androidアプリ設計パターン入門</title>
      <link>https://satoshun.github.io/2018/03/android-architecture-started/</link>
      <pubDate>Fri, 02 Mar 2018 00:28:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/03/android-architecture-started/</guid>
      <description>&lt;p&gt;Androidアプリ設計パターン入門を読んだのでざっくりと感想。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://peaks.cc/books/architecture_patterns&#34;&gt;https://peaks.cc/books/architecture_patterns&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MVP&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PresenterがViewとModelへの仲介役なので、Presenterはどうしてもfatになりそう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PresenterでView、Modelが何を出来るかを知らなければならない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Contractみたいなインタフェースを切るのは好き&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それを見ただけで何をそのページでやっているのかが掴めるので&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PresenterはContextを知らなく良い、Pure Javaなのでテスタブルだし綺麗になりそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MVVM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;個人的にはMVPより好き&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ViewModelがViewの参照を持たなくて良いので少しスッキリする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただViewへの参照がないだけで、LiveDataなりObservableFieldに値を書き出すので実質的にはViewがどんなことをしたいか知っているから同等といえば同等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Viewへの参照を持たないので、AACのViewModelへの適合性は高いと思う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DataBindingのObservableFieldとかを使わない前提。使うとViewへの参照を持ってメモリリークしちゃう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Flux&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単一方向データフローは凄い良いと思う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単一方向はFluxだけに限らないけど、Fluxを象徴する1つの特徴&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ViewModelとかPresenterって処理が集中する傾向にあると感じていて、FluxだとStore、ActionCreatorって形で切り出せるから良い&lt;/li&gt;&#xA;&lt;li&gt;FluxもAACとの相性は良いと思う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;負債の話&#xA;&lt;ul&gt;&#xA;&lt;li&gt;負債に対する解決策の1つとしてReact Nativeを出すのは発想として凄いと思ったし、そういう解決方法もあるのかと思った&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;メモ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ層の抽象化に関してはRepository的なものを作るで良さそう&lt;/li&gt;&#xA;&lt;li&gt;データ側はRx、UI側に反映する時はLiveDataが良さそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>読んだ: 達人に学ぶDB設計 徹底指南書</title>
      <link>https://satoshun.github.io/2015/03/master_of_database/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2015/03/master_of_database/</guid>
      <description>&lt;p&gt;この記事には僕の主観, 解釈が入っています. 本のまとめというよりかは, 感想的なものです.&lt;/p&gt;&#xA;&lt;h2 id=&#34;データベースを制する者はシステムを制す&#34;&gt;データベースを制する者はシステムを制す&lt;/h2&gt;&#xA;&lt;p&gt;システムを構築する時に, 要件定義をし, どのようにデータが必要, 保持するかを決定することはとても大切です. 拡張性が高く, 正しいデータ設計をすると, 要件修正があった時にも, 大きな変更をすることはありません. データ中心のアプローチは現在の主流です.&lt;/p&gt;&#xA;&lt;p&gt;view(外部スキーマ)とmodel(論理スキーマ)を分離しておくことも大切です.  論理スキーマを正規化などの技術を使い, リレーショナル・データベースの基本に沿った設計をすることで, 外部スキーマで柔軟に組み合わせて使用することが出来ます.&lt;/p&gt;&#xA;&lt;h2 id=&#34;論理設計と物理設計&#34;&gt;論理設計と物理設計&lt;/h2&gt;&#xA;&lt;p&gt;論理設計は物理設計に先立って行われる必要があり, 論理設計は物理設計とは独立して設計することが出来ます.&lt;/p&gt;&#xA;&lt;p&gt;論理設計では, エンティティ抽出が行われます. エンティティは要件定義に基づいて行われます. 例えば, 要件「ユーザがブログを投稿できる」があったとしたら，ユーザとブログがエンティティとして抽出できます. そして, 各エンティティがどのような属性(列)を持っているかを定義して, どのような関係(1対多になっているかなど)になっているかをER図などで示します.&lt;/p&gt;&#xA;&lt;p&gt;物理設計では, パフォーマンス, キャパシティの2つの要素が仕様を満たすようにすることが大切です. キャパシティは, データファイル, インデックスファイル, システムファイル, 一時ファイル, ログファイル(トランザクション履歴的なもの)の5つのファイルがあり, それぞれのファイルがどれくらいのサイズになるかを見積もります. パフォーマンスは, TPS(Transaction Per Second)のスループットがどれくらい出れば良いかを設定し, CPU, メインメモリを見積もります.&lt;/p&gt;&#xA;&lt;p&gt;冗長設計(RAID, レプリケーション), バックアップ設計(フル, 差分, 増分バックアップ)をし, 不測の事態でもデータがなくならないようにすることも大切です.&lt;/p&gt;&#xA;&lt;h2 id=&#34;論理設計と正規化-なぜテーブルは分割する必要があるのか&#34;&gt;論理設計と正規化 ～なぜテーブルは分割する必要があるのか？&lt;/h2&gt;&#xA;&lt;p&gt;正規化は, テーブルをどのように定義すればいいかのプラクティスです. 正規化をすることでデータの重複を防ぎ, データサイズを小さくし, データ不整合を防ぐことが出来ます. 正規化はRDSにおける, リファクタリングのような感じです.&lt;/p&gt;&#xA;&lt;p&gt;正規化には, 第5まであります. テーブルを分割することで, データの重複を除去していきます. 詳しくは&lt;a href=&#34;http://www.techscore.com/tech/sql/SQL16/16_02.html/&#34;&gt;こちら&lt;/a&gt;が分かりやすいです.&lt;/p&gt;&#xA;&lt;p&gt;まとめると, 正規化メリットは&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データの重複を防ぐ&lt;/li&gt;&#xA;&lt;li&gt;データサイズを小さく保つことが出来る&lt;/li&gt;&#xA;&lt;li&gt;正規化のノウハウは広く共有されているので, 他の人にも分かりやすいテーブル設計になりやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;er図-複数のテーブルの関係を表現する&#34;&gt;ER図 ～複数のテーブルの関係を表現する&lt;/h2&gt;&#xA;&lt;p&gt;正規化をすると, 必然的にテーブルが増加していきます. その結果, テーブル同士の依存関係が複雑になり管理が困難になります. ER(Entity Relationship)図で図示することで, 理解を助ける事ができます. Entityにはテーブルの属性, プライマリーキーなどを記述し, Entityの関係(Relationship)を線のようなものでつないでいきます. 詳しくは&lt;a href=&#34;http://itref.fc2web.com/technology/entity_relationship_diagram.html&#34;&gt;こちら&lt;/a&gt;が分かりやすいです.&lt;/p&gt;</description>
    </item>
    <item>
      <title>読んだ: Web API: The Good Parts</title>
      <link>https://satoshun.github.io/2015/03/webapi_the_good_parts/</link>
      <pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2015/03/webapi_the_good_parts/</guid>
      <description>&lt;p&gt;この記事には, 僕の主観, 解釈が入っています. 本のまとめというよりかは感想的なものです.&lt;/p&gt;&#xA;&lt;h2 id=&#34;web-apiとは何か&#34;&gt;Web APIとは何か&lt;/h2&gt;&#xA;&lt;p&gt;使いやすく, 理解しやすく, 拡張性が高く設計する必要があります.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使いやすく: クライアントが苦労しない, 素直な実装が出来る&lt;/li&gt;&#xA;&lt;li&gt;理解しやすく: 「エンドポイントが明確」, 「Twitterなどの他のWeb APIを参考にし, 慣習に従っている」.&lt;/li&gt;&#xA;&lt;li&gt;拡張性が高く: インターフェースの変更はクライアントに影響するため, バージョニングなどを使うなど, クライアントに影響を与えにくい設計になっている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一般に公開するLSUD(Large Set of Unknown Developers)と, 自社内のサービスで使う, SSKD(Small Set of Unknown Developers)のどちらの用途で使うかで大きく2つに分けることが出来ます. SSKDの場合は, クライアントのコントロールがしやすいので, 世間の常識から外れた設計をしても大きな問題にはなりませんが, &lt;strong&gt;理解のしやすさ&lt;/strong&gt; がなくなってしまうので, SSKDでもちゃんとした設計をする必要があります.&lt;/p&gt;&#xA;&lt;h2 id=&#34;エンドポイントの設計とリクエストの形式&#34;&gt;エンドポイントの設計とリクエストの形式&lt;/h2&gt;&#xA;&lt;p&gt;HTTPにおける, エンドポイントはURIになります. URIは&lt;strong&gt;リソースを示します&lt;/strong&gt;. 例えば, http://localhost/users なら, ホストlocalhostのユーザ一覧を指し示しています. さらに, ユーザIDが2のユーザを取得したいときは, http://localhost/users/2 とすれば直感的です. さらにさらに, ユーザIDが2のユーザの投稿一覧を取得したいときは, http://localhost/users/2/posts とすれば, 直感的です.&lt;/p&gt;&#xA;&lt;p&gt;ここで, 上記の例ではデータを&lt;em&gt;取得&lt;/em&gt;することにだけ, 注目していましたが, データを消去したい, 更新したいなどの機能も当然必要です. HTTPでは, &lt;em&gt;method&lt;/em&gt;を指定することで, それらの機能使い分けることが出来ます. よく使うmethodには, データを取得するGET, データを登録するPOST, データを更新するPUT, データを消去するDELETEがあります. 例えば, DELETE http://localhost/users/2 とすれば, ユーザIDが2のユーザを削除することが期待でき, PUT http://localhost/users/2 とすれば, ユーザIDが2のユーザの情報を更新することが期待されます. また, PUTと似たmethodにBATCHというものがあり, PUTは全データの上書き, BATCHは一部データの上書きという違いがあります. 例えるなら, PUTは, MongoDBの$setを使わないupdateみたいな振る舞いが, BATCHはSQLのUPDATEのように, 指定フィールドのみの更新が期待されます. URI+methodは, URIが示しているリソースに対して, methodの処理をする. とルールを統一することで理解しやすいエンドポイントを作成することが可能になります.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
