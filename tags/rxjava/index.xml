<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxjava on stsnブログ</title>
    <link>https://satoshun.github.io/tags/rxjava/</link>
    <description>Recent content in Rxjava on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Tue, 25 Jun 2019 12:38:16 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/tags/rxjava/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RxJava 3.xの開発が本格的に始まりました</title>
      <link>https://satoshun.github.io/2019/06/rxjava3-preview/</link>
      <pubDate>Mon, 24 Jun 2019 13:52:14 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/06/rxjava3-preview/</guid>
      <description>&lt;p&gt;現状での差異をまとめておきます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;rxjava2との差異&#34;&gt;RxJava2との差異&lt;/h2&gt;&#xA;&lt;h3 id=&#34;readmeから&#34;&gt;READMEから&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/blob/3.x/README.md&#34;&gt;README.md&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;RxJava2 との差分は以下のようになっています。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;fixed API mistakes and many limits of RxJava 2&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RxJava2のいくつかのAPIのミス、制限を直している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;intended to be a replacement for RxJava 2 with relatively few binary incompatible changes&#xA;&lt;ul&gt;&#xA;&lt;li&gt;APIに多少の変更があり、バイナリ互換がない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;test and diagnostic support via test schedulers, test consumers and plugin hooks&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テストのサポートの充実&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3x-different-docsから&#34;&gt;3.x different docsから&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/blob/3.x/docs/What&#39;s-different-in-3.0.md&#34;&gt;3.x different docs&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;asメソッドとtoメソッド&#34;&gt;asメソッドとtoメソッド&lt;/h4&gt;&#xA;&lt;p&gt;toメソッドはFunction型を引数から取っていた。しかし、あらゆるReactive型でFunction型を受け取っていたので、共通のConverterを作ることが出来なかった。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>&lt;p&gt;Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;launch {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task1 = async { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task1() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task2 = async { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task2() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${task1.await()}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${task2.await()}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;asyncで包むことで、並列に処理をすることができます。&lt;/p&gt;&#xA;&lt;p&gt;次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元で&lt;code&gt;runCatching&lt;/code&gt;を使います。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;launch {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task1 = async { runCatching { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task1() } }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task2 = async { runCatching { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task2() } }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result1 = task1.await()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result2 = task2.await()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$result1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; + &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$result2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>&lt;p&gt;RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;issueの内容&#34;&gt;Issueの内容&lt;/h2&gt;&#xA;&lt;p&gt;実際のIssueは &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/issues/441&#34;&gt;HandlerScheduler.scheduleDirect supports async option?&lt;/a&gt; になります。&lt;/p&gt;&#xA;&lt;p&gt;Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これは&lt;code&gt;Worker.schedule&lt;/code&gt;のスケジュールからのみのサポートでした。RxJavaでは&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;でもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;そもそもこの問題に気づいたきっかけ&#34;&gt;そもそもこの問題に気づいたきっかけ&lt;/h2&gt;&#xA;&lt;p&gt;RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;調べ方&#34;&gt;調べ方&lt;/h2&gt;&#xA;&lt;p&gt;クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。&lt;/p&gt;&#xA;&lt;p&gt;結果、&lt;code&gt;Observable.observeOn&lt;/code&gt;では&lt;code&gt;Worker.schedule&lt;/code&gt;メソッドでタスクのスケジューリングをし、&lt;code&gt;Maybe.observeOn&lt;/code&gt;では&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;メソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;その他感想&#34;&gt;その他・感想&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jakeさんとzacさんにレビューをしてもらった&#34;&gt;JakeさんとZacさんにレビューをしてもらった&lt;/h3&gt;&#xA;&lt;p&gt;二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>&lt;p&gt;RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これは&lt;code&gt;Message#setAsynchronous&lt;/code&gt;を使うことで、UIのパフォーマンス向上を狙った機能です。&#xA;下のリンクに詳細な内容が書かれています。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/@sweers/rxandroids-new-async-api-4ab5b3ad3e93&#34;&gt;RxAndroid’s New Async API&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。&lt;/p&gt;&#xA;&lt;p&gt;検証に使用したサンプルプロジェクトは以下になります。&#xA;&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;サンプルプロジェクトをかいつまんで説明します。&lt;/p&gt;&#xA;&lt;p&gt;まず2つのスケジューラを作成し、&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; mainScheduler = &lt;span style=&#34;color:#a6e22e&#34;&gt;AndroidSchedulers&lt;/span&gt;.from(&lt;span style=&#34;color:#a6e22e&#34;&gt;Looper&lt;/span&gt;.getMainLooper(), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; asyncMainScheduler = &lt;span style=&#34;color:#a6e22e&#34;&gt;AndroidSchedulers&lt;/span&gt;.from(&lt;span style=&#34;color:#a6e22e&#34;&gt;Looper&lt;/span&gt;.getMainLooper(), &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// asyncがfalseの場合&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Observable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .fromCallable { &lt;span style=&#34;color:#a6e22e&#34;&gt;System&lt;/span&gt;.currentTimeMillis() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .delay(index, &lt;span style=&#34;color:#a6e22e&#34;&gt;TimeUnit&lt;/span&gt;.MILLISECONDS)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .observeOn(mainScheduler)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .subscribe(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// asyncがtrueの場合&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Observable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .fromCallable { &lt;span style=&#34;color:#a6e22e&#34;&gt;System&lt;/span&gt;.currentTimeMillis() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .delay(index, &lt;span style=&#34;color:#a6e22e&#34;&gt;TimeUnit&lt;/span&gt;.MILLISECONDS)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .observeOn(asyncMainScheduler)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .subscribe(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>RxJava: as, toの違いについて</title>
      <link>https://satoshun.github.io/2017/12/rx-as-to-operator/</link>
      <pubDate>Sat, 23 Dec 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/12/rx-as-to-operator/</guid>
      <description>&lt;p&gt;RxJavaでobservable型(Flowable、Observableなど)を他の型に変換したいときには、toまたはasを使います。&lt;/p&gt;&#xA;&lt;p&gt;この記事ではそれぞれの違いを説明します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;toについて&#34;&gt;toについて&lt;/h2&gt;&#xA;&lt;p&gt;toのシグニチャは以下のようになります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; R &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; Flowable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; converter)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; R &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; Observable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; converter)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; R &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; Maybe&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; convert)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; R &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; Single&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; convert)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; U &lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;(Function&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; Completable, U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; converter)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Function&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, R&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    R &lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;@NonNull&lt;/span&gt; T t) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android: RxJava &#43; OkHttpを使って401の処理をいい感じにする</title>
      <link>https://satoshun.github.io/2017/08/rx-okhttp-401/</link>
      <pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/08/rx-okhttp-401/</guid>
      <description>&lt;p&gt;(この記事はRxJavaとOkHttpを知っている前提で進めていきます。またこの記事はRxJavaすごーいしたいだけの記事です。401のハンドリングのところは、RxJavaを使いたいだけのユースケースというか1例になります。)&lt;/p&gt;&#xA;&lt;p&gt;この記事のサンプルコードは &lt;a href=&#34;https://github.com/satoshun-example/authenticateSample&#34;&gt;ここ(Github)&lt;/a&gt;にあります。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;API周りの開発をしていて、401のときの処理をどうするかという永遠の課題があると思います。&#xA;クライアント側で頑張るとしたら以下の感じになるかなと思います。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;OkHttpのAuthenticatorを使い、そこで401のときのハンドリングをする。&lt;a href=&#34;https://github.com/square/okhttp/wiki/Recipes#handling-authentication&#34;&gt;公式ドキュメントのリンク&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;OkHttpのInterceptorを使い、そこで401のときのハンドリングをする。&lt;a href=&#34;https://github.com/square/okhttp/wiki/Interceptors&#34;&gt;公式ドキュメントのリンク&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;各処理(例えばRxJavaのTransformerとか)に401用の処理を埋め込んで、retryを掛ける。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;などがあるかなと(OkHttp、RxJavaを使うことを前提とする)&lt;/p&gt;&#xA;&lt;p&gt;このブログではOkHttpのAuthenticatorを使う方法で401の処理をいい感じにしたいと思います。&lt;/p&gt;&#xA;&lt;p&gt;またrefresh tokenは非同期、APIリクエストが必要であるとします。擬似コードはこんな感じです。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fun refreshToken(): Observable&amp;lt;String&amp;gt; {&#xA;  return Observable.just(Credentials.basic(&amp;#34;sato&amp;#34;, &amp;#34;passwordhoge&amp;#34;))&#xA;      .doOnNext { println(&amp;#34;GET credential: $it&amp;#34;) } // Log出力&#xA;      .delay(2000, TimeUnit.MILLISECONDS)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間が掛かるんだなあくらいに思って下さい。&lt;/p&gt;&#xA;&lt;h2 id=&#34;401の処理を書いていく&#34;&gt;401の処理を書いていく&lt;/h2&gt;&#xA;&lt;p&gt;OkHttpのAuthenticatorは401のときにフックされます。なのでこの中で401ならrefresh tokenをし、結果をauthorization headerにセットして再リクエストをすれば良さそうです。&lt;/p&gt;&#xA;&lt;p&gt;ただここで1つ問題があります。それは、APIリクエストは並列に行われるということです。ということは、何も考えないとrefresh tokenが複数回叩かれてしまいます。なのでrefresh tokenをしているときは、後続の401はそれを待つようにしないといけません。&lt;/p&gt;&#xA;&lt;p&gt;愚直に表現するなら、refresh tokenをしていますよフラグをどこかに立てておいて、それがtrueなら待つ。falseならrefersh tokenをして、結果を待つといった処理になります。&#xA;並列にリクエストが行われるとしたら、マルチスレッドからコールされるのでsynchorizeなどの制御をする必要があり、めっちゃムズい。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxJava multicastについて</title>
      <link>https://satoshun.github.io/2017/05/rx-multicast/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/05/rx-multicast/</guid>
      <description>&lt;p&gt;RxJavaには, stream上のアイテムを複数のSubscriberに渡せるmulticast(再利用のような感じ)の機能があります.&#xA;multicastは主に「キャッシュとして使う」, イベントをが発火したときに複数で処理をおこなう」 として使います.&lt;/p&gt;&#xA;&lt;p&gt;RxJavaでは2つの方法でmulticastを実現します.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;publish&lt;/code&gt;を使い, &lt;code&gt;ConnectableObservable&lt;/code&gt;を作る&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt;を使う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;また, RxJava2だとFlowableがありますが, Flowableの場合は &lt;code&gt;Processor&lt;/code&gt;を使います.&lt;/p&gt;&#xA;&lt;p&gt;説明だけだと分かりにくいので, サンプルコードも合わせてどうぞ.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-example/RxJava-Samples/blob/master/app/src/main/java/com/github/satoshun/example/rxjava/sample/CachedNetworkWithConnectableActivity.java&#34;&gt;ConnectableObservable&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-example/RxJava-Samples/blob/master/app/src/main/java/com/github/satoshun/example/rxjava/sample/CachedNetworkWithSubjectActivity.java&#34;&gt;Subject&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;connectableobservableについて&#34;&gt;ConnectableObservableについて&lt;/h2&gt;&#xA;&lt;p&gt;ConnectableObservableは&lt;code&gt;publish&lt;/code&gt;がコールされたタイミングで生成されます.&#xA;ここがStreamの開始地点, 再利用する地点になります. なので, &lt;code&gt;map&lt;/code&gt;や&lt;code&gt;filter&lt;/code&gt;など, 共通の処理があるのなら,&#xA;&lt;code&gt;publish&lt;/code&gt;のUpstreamに書いて共通化したほうが効率が良いです.&lt;/p&gt;&#xA;&lt;p&gt;ConnectableObservableは&lt;code&gt;connect&lt;/code&gt;メソッドがコールされたタイミングで, Streamの開始をします.&#xA;従来はSubscriberを登録した(subscribeメソッドをコールした)タイミングなので, 注意が必要です.&lt;/p&gt;&#xA;&lt;p&gt;そして, &lt;code&gt;publish&lt;/code&gt; + &lt;code&gt;connect&lt;/code&gt;を組みわせることで1つのStreamに対して複数のSubscriberを登録することが出来ます.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;publishConnect.png&#34; alt=&#34;Publish Connect&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;(source: &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators&#34;&gt;https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;p&gt;他にも, &lt;code&gt;share&lt;/code&gt;や&lt;code&gt;refcount&lt;/code&gt;がありますが, 基本的な考え方は変わりません.&lt;/p&gt;&#xA;&lt;h2 id=&#34;subjectを使う&#34;&gt;Subjectを使う&lt;/h2&gt;&#xA;&lt;p&gt;Subjectは, ObservableとObserverの機能を同時に使うことができる実装です.&#xA;1例としては, Observerの機能を使い, 複数のObservableからデータを取得し, Observableの機能を使いそのデータをObserverに渡す, いわゆるBridgeのような事ができます.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;BehaviorSubject&lt;/code&gt;, &lt;code&gt;ReplaySubject&lt;/code&gt;などのバラエティがあるので, 必要に応じて使い分ける必要があります. (&lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/subject&#34;&gt;https://github.com/ReactiveX/RxJava/wiki/subject&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxJava 並行でリクエストをして, リクエストした順番で値を受け取る</title>
      <link>https://satoshun.github.io/2017/05/rx-concateager-parallel-request/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/05/rx-concateager-parallel-request/</guid>
      <description>&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;concatEagerを使う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;concat-concateager&#34;&gt;concat, concatEager&lt;/h2&gt;&#xA;&lt;p&gt;RxJavaにはconcatEagerと, concatオペレータがあります. 似た名前ですが, 振る舞いは異なります.&#xA;concatEagerはconcatと違い, 並列にObservableは処理するけど, 返してくる順番は保証されています&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;concat: 直列にObservableを処理し, 返してくる順番は保証されている&lt;/li&gt;&#xA;&lt;li&gt;concatEager: 並列にObservableを処理し, 返してくる順番は保証されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;コードで説明すると,&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o1 ----&amp;gt; |&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o2       |------&amp;gt;|&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//          |       |&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//  s ------o1------o2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Observable.&lt;span style=&#34;color:#a6e22e&#34;&gt;concat&lt;/span&gt;(o1, o2)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; .&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>RxJava: AutoDisposeで自動的にdisposeする</title>
      <link>https://satoshun.github.io/2017/05/rx-autodispose/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/05/rx-autodispose/</guid>
      <description>&lt;p&gt;非同期処理を開始した後に, Activityのライフサイクルなどに連動して非同期処理をキャンセルする必要があります.&lt;/p&gt;&#xA;&lt;p&gt;RxJavaでは, Disposableからキャンセルの処理を行います.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disposable d;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; myObservable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(a &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onPause&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    d.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispose&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>RxJava: Connectable Observableについて</title>
      <link>https://satoshun.github.io/2017/05/rx-connectable-observable/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/05/rx-connectable-observable/</guid>
      <description>&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同じStreamを複数のObserverで扱いたいときはConnectable Observableを使う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;効率的!!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Connectable Observableはsubscribeをコールしても, Streamが開始しない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;connect&lt;/code&gt;メソッドをコールした時に, Streamが開始する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本的な使い方&#34;&gt;基本的な使い方&lt;/h2&gt;&#xA;&lt;p&gt;同じデータを必要としているObserverがあるとします.&#xA;これを単純に書くと以下のようになります.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obervable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;User&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUsers&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Observalbe.&lt;span style=&#34;color:#a6e22e&#34;&gt;just&lt;/span&gt;(User1, User2, User3);}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obervable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;User&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; users &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getUsers();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これだと, subscribeされるたびに新しいStreamが作られてしまいます.&#xA;上の例だと3つの独立したObservableが作成されてしまい, 非常に効率が悪いです.&lt;/p&gt;&#xA;&lt;p&gt;Connectable Observableを使うことで, 1つのStreamからsubscribeすることが出来ます.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ConnectableObservable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;User&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; users &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getUsers().&lt;span style=&#34;color:#a6e22e&#34;&gt;publish&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(o3);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;users.&lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 重要!!&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>RxJava: SubjectでonErrorを取り扱う時</title>
      <link>https://satoshun.github.io/2017/05/rx-subject-materialize/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2017/05/rx-subject-materialize/</guid>
      <description>&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;materialize, dematerializeを使う.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;onErrorをSubjectに流すと, Subjectはdispose状態になるため, これ以降のEventを流すことが出来なくなります.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;subscribe&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    v &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Log.&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;onNext&amp;#34;&lt;/span&gt;, String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(v)),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Log.&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;onError&amp;#34;&lt;/span&gt;, e.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMessage&lt;/span&gt;()));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;onNext&lt;/span&gt;(v1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;onNext&lt;/span&gt;(v2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;onError&lt;/span&gt;(e1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;onNext&lt;/span&gt;(v3); &lt;span style=&#34;color:#75715e&#34;&gt;// ignore&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sub.&lt;span style=&#34;color:#a6e22e&#34;&gt;onNext&lt;/span&gt;(v4); &lt;span style=&#34;color:#75715e&#34;&gt;// ignore&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これだと, Subjectがこれ以降に値を受け付けないため不便になることがあります.(ユースケース次第)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android: Fragmentを使って、画面の向きの変更時にデータを保持する</title>
      <link>https://satoshun.github.io/2016/10/android-orientation-data/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2016/10/android-orientation-data/</guid>
      <description>&lt;p&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;, &lt;code&gt;onRestoreInstanceState&lt;/code&gt;を使う方法もありますが, 今回はFragmentを使う方法を紹介します.&lt;/p&gt;&#xA;&lt;p&gt;サンプルコードは &lt;a href=&#34;https://github.com/satoshun-example/AndroidRetainData&#34;&gt;https://github.com/satoshun-example/AndroidRetainData&lt;/a&gt; にあります.&lt;/p&gt;&#xA;&lt;h2 id=&#34;ユースケース&#34;&gt;ユースケース&lt;/h2&gt;&#xA;&lt;p&gt;ネットワークはコストが掛かるので, 1度データを取得したら, 画面回転でアクティビティが再生成されたとしてもデータを使いまわしたい, というケースがあるとします.&lt;/p&gt;&#xA;&lt;h2 id=&#34;やり方&#34;&gt;やり方&lt;/h2&gt;&#xA;&lt;p&gt;まず, データを保持するFragmentを定義します.&lt;/p&gt;&#xA;&lt;p&gt;最初にonCreateで, setRetainInstance(true)をコールします.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    setRetainInstance(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    refresh();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;次に, refreshでデータを取得します. ここではRxJava2 + Retrofitを使っています.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
