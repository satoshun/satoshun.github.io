<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxandroid on stsnブログ</title>
    <link>https://satoshun.github.io/tags/rxandroid/</link>
    <description>Recent content in Rxandroid on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sat, 02 Mar 2019 13:21:05 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/tags/rxandroid/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>&lt;p&gt;RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;issueの内容&#34;&gt;Issueの内容&lt;/h2&gt;&#xA;&lt;p&gt;実際のIssueは &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/issues/441&#34;&gt;HandlerScheduler.scheduleDirect supports async option?&lt;/a&gt; になります。&lt;/p&gt;&#xA;&lt;p&gt;Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これは&lt;code&gt;Worker.schedule&lt;/code&gt;のスケジュールからのみのサポートでした。RxJavaでは&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;でもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;そもそもこの問題に気づいたきっかけ&#34;&gt;そもそもこの問題に気づいたきっかけ&lt;/h2&gt;&#xA;&lt;p&gt;RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。&lt;/p&gt;&#xA;&lt;h2 id=&#34;調べ方&#34;&gt;調べ方&lt;/h2&gt;&#xA;&lt;p&gt;クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。&lt;/p&gt;&#xA;&lt;p&gt;結果、&lt;code&gt;Observable.observeOn&lt;/code&gt;では&lt;code&gt;Worker.schedule&lt;/code&gt;メソッドでタスクのスケジューリングをし、&lt;code&gt;Maybe.observeOn&lt;/code&gt;では&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;メソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;その他感想&#34;&gt;その他・感想&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jakeさんとzacさんにレビューをしてもらった&#34;&gt;JakeさんとZacさんにレビューをしてもらった&lt;/h3&gt;&#xA;&lt;p&gt;二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>&lt;p&gt;RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これは&lt;code&gt;Message#setAsynchronous&lt;/code&gt;を使うことで、UIのパフォーマンス向上を狙った機能です。&#xA;下のリンクに詳細な内容が書かれています。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/@sweers/rxandroids-new-async-api-4ab5b3ad3e93&#34;&gt;RxAndroid’s New Async API&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。&lt;/p&gt;&#xA;&lt;p&gt;検証に使用したサンプルプロジェクトは以下になります。&#xA;&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;サンプルプロジェクトをかいつまんで説明します。&lt;/p&gt;&#xA;&lt;p&gt;まず2つのスケジューラを作成し、&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; mainScheduler = &lt;span style=&#34;color:#a6e22e&#34;&gt;AndroidSchedulers&lt;/span&gt;.from(&lt;span style=&#34;color:#a6e22e&#34;&gt;Looper&lt;/span&gt;.getMainLooper(), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; asyncMainScheduler = &lt;span style=&#34;color:#a6e22e&#34;&gt;AndroidSchedulers&lt;/span&gt;.from(&lt;span style=&#34;color:#a6e22e&#34;&gt;Looper&lt;/span&gt;.getMainLooper(), &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// asyncがfalseの場合&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Observable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .fromCallable { &lt;span style=&#34;color:#a6e22e&#34;&gt;System&lt;/span&gt;.currentTimeMillis() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .delay(index, &lt;span style=&#34;color:#a6e22e&#34;&gt;TimeUnit&lt;/span&gt;.MILLISECONDS)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .observeOn(mainScheduler)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .subscribe(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// asyncがtrueの場合&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Observable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .fromCallable { &lt;span style=&#34;color:#a6e22e&#34;&gt;System&lt;/span&gt;.currentTimeMillis() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .delay(index, &lt;span style=&#34;color:#a6e22e&#34;&gt;TimeUnit&lt;/span&gt;.MILLISECONDS)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .observeOn(asyncMainScheduler)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .subscribe(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;フルコードは以下になります。&#xA;&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;結果は、以下のようになりました。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// API27 エミュレータ&#xA;main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和&#xA;main=130857ms, async=126582ms&#xA;main=131401ms, async=126909ms&#xA;main=130763ms, async=126504ms&#xA;main=132758ms, async=127972ms&#xA;&#xA;// API21 エミュレータ&#xA;main=129869ms, async=125795ms&#xA;main=130050ms, async=125888ms&#xA;main=129935ms, async=125853ms&#xA;main=129908ms, async=125838ms&#xA;main=129927ms, async=125824ms&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
