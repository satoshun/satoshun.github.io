<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gradle on stsnブログ</title>
    <link>https://satoshun.github.io/tags/gradle/</link>
    <description>Recent content in Gradle on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Thu, 30 Mar 2023 14:23:54 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/tags/gradle/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android: Eng modeの紹介</title>
      <link>https://satoshun.github.io/2023/03/android-build-engmode/</link>
      <pubDate>Thu, 30 Mar 2023 14:23:54 +0000</pubDate>
      <guid>https://satoshun.github.io/2023/03/android-build-engmode/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/eboudrant/netflix-plus-gradle-a-journey-in-developer-productivity?slide=17&#34;&gt;Netflix + Gradle, A Journey in Developer Productivity&lt;/a&gt;の発表で、Eng modeの解説をしていて、いいテクニックだと思ったのでそれの紹介です。&lt;/p&gt;&#xA;&lt;p&gt;Eng modeとは、Eng modeフラグを作り、それがtrueのときに不必要な機能をoffにして、ビルドを高速化しようというテクニックです。&lt;/p&gt;&#xA;&lt;p&gt;Netflixでは次の機能をoff、または調整しているらしいです。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;incremental buildの最適化&lt;/li&gt;&#xA;&lt;li&gt;不要なプラグイン(jacocoなど)&lt;/li&gt;&#xA;&lt;li&gt;Variantの削除&lt;/li&gt;&#xA;&lt;li&gt;app bundlesの削除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;これらを調整することで、Gradleのconfiguration time、ビルドの短縮をし、開発の効率化をすることが出来ます。&#xA;Variantsが多い、プラグインをめちゃくちゃ入れているような大規模なプロジェクトだと効果がありそうです。&lt;/p&gt;&#xA;&lt;p&gt;より詳しくは、&lt;a href=&#34;https://speakerdeck.com/eboudrant/netflix-plus-gradle-a-journey-in-developer-productivity?slide=17&#34;&gt;スライド&lt;/a&gt;か、もしくは&lt;a href=&#34;https://www.droidcon.com/2022/09/29/netflix-gradle-a-journey-in-developer-productivity-2/&#34;&gt;動画&lt;/a&gt;を見てください。&lt;/p&gt;&#xA;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/eboudrant/netflix-plus-gradle-a-journey-in-developer-productivity&#34;&gt;https://speakerdeck.com/eboudrant/netflix-plus-gradle-a-journey-in-developer-productivity&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.droidcon.com/2022/09/29/netflix-gradle-a-journey-in-developer-productivity-2/&#34;&gt;https://www.droidcon.com/2022/09/29/netflix-gradle-a-journey-in-developer-productivity-2/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Gradle: Javaのバージョン差異によるビルド速度の変化</title>
      <link>https://satoshun.github.io/2022/10/gradle-java-version-performance/</link>
      <pubDate>Mon, 10 Oct 2022 07:49:35 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/10/gradle-java-version-performance/</guid>
      <description>&lt;p&gt;Javaのバージョンを変更することで、Androidプロジェクトのビルド速度がどのくらい変化するかについて確認してみました。&lt;/p&gt;&#xA;&lt;p&gt;環境は次のようにしました。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Mac M1 Max&lt;/li&gt;&#xA;&lt;li&gt;Gradle: 7.5.1&lt;/li&gt;&#xA;&lt;li&gt;Java:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;11.0.16.1&lt;/li&gt;&#xA;&lt;li&gt;17.0.4&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;この環境で、Java11と17でそれぞれ10回 &lt;code&gt;./gradlew assembleDebug --rerun-tasks&lt;/code&gt;を実行します。&lt;/p&gt;&#xA;&lt;p&gt;Java11の場合&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BUILD SUCCESSFUL in 2m 36s&#xA;BUILD SUCCESSFUL in 2m 29s&#xA;BUILD SUCCESSFUL in 2m 30s&#xA;BUILD SUCCESSFUL in 2m 28s&#xA;BUILD SUCCESSFUL in 2m 30s&#xA;BUILD SUCCESSFUL in 2m 30s&#xA;BUILD SUCCESSFUL in 2m 30s&#xA;BUILD SUCCESSFUL in 2m 34s&#xA;BUILD SUCCESSFUL in 2m 31s&#xA;BUILD SUCCESSFUL in 2m 32s&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Androidビルド速度改善雑記 その2</title>
      <link>https://satoshun.github.io/2022/09/android-build-performance-2/</link>
      <pubDate>Sun, 25 Sep 2022 06:33:51 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/09/android-build-performance-2/</guid>
      <description>&lt;p&gt;中、大規模なプロジェクトの場合に、マルチモジュール環境に移行するのは一般的だと思います。&lt;/p&gt;&#xA;&lt;p&gt;マルチモジュールに移行する1つの利点として、ビルド速度の向上が挙げられます。向上する主な理由としては、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;並列ビルドをより有効に活用出来る&lt;/li&gt;&#xA;&lt;li&gt;キャッシュをより有効に活用出来る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;などがあります。&lt;/p&gt;&#xA;&lt;p&gt;この記事では、全体のビルドに影響を及ぼしているモジュールを特定し、改善することで、並列ビルドを向上させる方法について紹介します。&lt;/p&gt;&#xA;&lt;p&gt;全体のビルドに影響を及ぼしているモジュールとは、&#xA;「いろいろなモジュールに依存されていて、ビルドが終わっていないモジュール」です。これがあると、他のモジュールのビルドのブロッカーになります。&lt;/p&gt;&#xA;&lt;p&gt;例えば、core-uiモジュールがあって、それにFeature A、Bモジュールがそれぞれ依存していると、core-uiモジュールのビルドが終わるまで、Feature A、Bモジュールのビルドを開始することができずに、並列ビルドの恩恵を受けることが出来ません。&#xA;解決策としては、core-ui A、Bのように細かくする、Feature A、Bがcore-uiに依存しないようにする、などがあります。&lt;/p&gt;&#xA;&lt;p&gt;次に、そのようなモジュールの特定方法ですが、Gradle Build Scanを使うと良いです。&#xA;Gradle Build Scanを使い、Timelineタブ → On critical pathにチェックを入れることで、特定できます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://paper-attachments.dropbox.com/s_3282C4DCF24694CFFACCC494B9C7B94F2A243EDD722354F39FC0CAEE16D5BA17_1664086854982_Screen+Shot+2022-09-25+at+15.20.46.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Criticalと判定されたタスクを修正することで、全体のビルド時間を改善することが期待できます。&lt;/p&gt;&#xA;&lt;p&gt;（ただし、無為にモジュールを増やしすぎると、 Configurationなどの時間が増え、ビルド改善できない場合があるので、注意してください。)&lt;/p&gt;&#xA;&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Gradle Build ScanでCriticalなモジュールを特定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モジュール間の依存関係を見直す&lt;/li&gt;&#xA;&lt;li&gt;モジュールの分割を検討する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ただ、無理やりモジュール分割をすると、設計に無理が出たりすると思うので、そういった場合にはやらないほうが無難だと思います。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Androidビルド速度改善雑記 その1</title>
      <link>https://satoshun.github.io/2022/09/android-build-performance-1/</link>
      <pubDate>Sat, 17 Sep 2022 03:43:41 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/09/android-build-performance-1/</guid>
      <description>&lt;p&gt;今回はGradleビルドキャッシュが有効に使われているかについて説明します。&#xA;ビルド速度（incremental build）を改善するためには、ビルドキャッシュがいい感じに効いている必要があるからです。&lt;/p&gt;&#xA;&lt;p&gt;キャッシュが効いているかを確認するためには、2回同じコマンドを実行すると良いです。&lt;/p&gt;&#xA;&lt;p&gt;まず1回目の実行をしてみます。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; ./gradlew assembleDebug&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt; actionable tasks: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; executed, &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt; up-to-date&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この場合は、16タスクが実行されて、23タスクが最新（キャッシュ）となっており、23タスクがキャッシュを使っています。&#xA;もう一度同じコマンドを実行したときに、すべてのタスクがキャッシュを使っていれば、いい感じです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; ./gradlew assembleDebug&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt; actionable tasks: &lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt; up-to-date&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これが理想ケースです。&lt;/p&gt;&#xA;&lt;p&gt;こうなっていない場合には、Gradle Build Scanを使って調査するのが良いと思います。&#xA;Build Scanの使い方は簡単で、引数に &amp;ndash;scan をつけるだけです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; ./gradlew assembleDebug --scan&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android: Gradle Build Scanで、マルチモジュール環境のビルド改善</title>
      <link>https://satoshun.github.io/2022/04/gradle-buildperformance-scan/</link>
      <pubDate>Sun, 10 Apr 2022 07:10:16 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/04/gradle-buildperformance-scan/</guid>
      <description>&lt;p&gt;GradleにはBuild Scanという機能があり、これを使うことで、プロジェクトのビルドの全体像を知ることが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;使い方は簡単で &lt;code&gt;--scan&lt;/code&gt; を指定するだけです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew assembleDebug --scan&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これで、GradleのBuild Scanをしてくれます。&#xA;今回はこれをヒントにして、モジュール間の依存を見直すことで、ビルドの改善をしてみます。&lt;/p&gt;&#xA;&lt;p&gt;左タブのTimelineから、全体的なビルドの確認をすることが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://paper-attachments.dropbox.com/s_82512F6D62C51E4BD720E70C8981F518B8055502F7A6812E3E86458A5B1C7F53_1649564767788_Screen+Shot+2022-04-10+at+13.25.56.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Timelineでは、どのような順番でmoduleのビルドが行われたかを確認することが出来ます。&#xA;時間が掛かっているモジュール（クリティカルパス）を改善すれば、全体のビルドを改善することが期待できます。&lt;/p&gt;&#xA;&lt;p&gt;Timelineでは、どのモジュールがクリティカルパスになっているかを検索することが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://paper-attachments.dropbox.com/s_82512F6D62C51E4BD720E70C8981F518B8055502F7A6812E3E86458A5B1C7F53_1649564981910_Screen+Shot+2022-04-10+at+13.29.34.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;クリティカルパス検索をすると、次の画像のように、クリティカルなタスク（モジュール）に色が付きます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://paper-attachments.dropbox.com/s_82512F6D62C51E4BD720E70C8981F518B8055502F7A6812E3E86458A5B1C7F53_1649564832644_Screen+Shot+2022-04-10+at+13.27.02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;これで、クリティカルパスとなっているモジュールを知ることが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;次に、このクリティカルなモジュールの改善を考えます。大きく2つの方法があると思います。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;モジュール自体のサイズを小さくする → このモジュールで管理するクラス数を減らす&lt;/li&gt;&#xA;&lt;li&gt;ビルドするタイミングを早くする → 他のモジュールへの依存を減らす&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;1.に関しては、それはそうという感じなので、2について説明します。&lt;/p&gt;&#xA;&lt;p&gt;例えば、A &amp;lt;- B &amp;lt;- C のような依存構成になっているときに、Bがクリティカルであるとします。&#xA;このときに、BがAに依存しないように変更することで、Bのビルドタイミングを早めることができ、全体のビルドが改善されることが期待できます。&#xA;「BがAに依存しないように変更できる」、また、「その変更によってモジュールの責務が崩れない」ことが前提となりますが、無駄な他モジュールへの依存を無くすだけでも、ビルドの改善が出来る場合があります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;&#xA;&lt;p&gt;こんな感じで、Gradle Scanを使い、ちょこちょことTimelineのクリティカルパスを改善することで、ビルド時間の改善が期待出来ます。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gradle: Typesafe project dependencies</title>
      <link>https://satoshun.github.io/2022/02/gradle-typesafe-accessor/</link>
      <pubDate>Sun, 27 Feb 2022 11:42:50 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/02/gradle-typesafe-accessor/</guid>
      <description>&lt;p&gt;Type-safe project dependenciesの紹介ブログです。Gradle 7.4で試しています。&lt;/p&gt;&#xA;&lt;p&gt;Gradleでマルチモジュールプロジェクトを構成すると、例えば、プロジェクトlibAへの依存は、次のようにう書くことが出来ます。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// app/build.gradle.kts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  implementation(project(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:libA&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この際に、projectで指定している &lt;code&gt;:libA&lt;/code&gt; の部分は文字列なのでtypesafeではなく、補完などが効きにくいです。(最近のIntelliJ、Android Studioだと補完が効いたりします)&lt;/p&gt;&#xA;&lt;p&gt;ここで、今回紹介する Type-safe project dependenciesを使うと、次のように書くことが出来ます。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// settings.gradle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;enableFeaturePreview&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TYPESAFE_PROJECT_ACCESSORS&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// app/build.gradle.kts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  implementation(projects.libA)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Gradle Profilerを使って、ビルドを最適化する</title>
      <link>https://satoshun.github.io/2022/02/gradle-profile-build/</link>
      <pubDate>Sun, 06 Feb 2022 03:39:04 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/02/gradle-profile-build/</guid>
      <description>&lt;p&gt;開発を高速化するために、ビルド速度を改善することは重要です。&#xA;Gradleの設定を見直すことで、ビルド速度を改善できる可能性があります。&lt;/p&gt;&#xA;&lt;p&gt;この記事では、Gradle Profilerを使って、自分の環境において最適そうな設定を見つける方法を紹介します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;gradle-profilerとは&#34;&gt;Gradle Profilerとは?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/gradle/gradle-profiler&#34;&gt;Gradle Profiler&lt;/a&gt; は、Gradleのプロファイリング、ベンチマークを計測してくれるツールです。&lt;/p&gt;&#xA;&lt;p&gt;Gradle Profilerを使うことで、最適なGradleの設定を見つけだすことが出来ます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;良さそうな設定を見つける&#34;&gt;良さそうな設定を見つける&lt;/h2&gt;&#xA;&lt;p&gt;まず、最初にシナリオファイルを作成します。これは、Gradle Profilerを実行する際に必要なファイルで、記述したシナリオ通りに実行してくれます。&lt;/p&gt;&#xA;&lt;p&gt;今回は、次のようなシナリオを作りました。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# scenario.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clean_build_2gb_2workers {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tasks = [&amp;#34;:app:assembleDebug&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gradle-args = [&amp;#34;--max-workers=2&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    jvm-args = [&amp;#34;-Xmx2048m&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cleanup-tasks = [&amp;#34;clean&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clean_build_4gb_4workers {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tasks = [&amp;#34;:app:assembleDebug&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gradle-args = [&amp;#34;--max-workers=4&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    jvm-args = [&amp;#34;-Xmx4096m&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cleanup-tasks = [&amp;#34;clean&amp;#34;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Gradle: 様々なバージョン管理の方法</title>
      <link>https://satoshun.github.io/2022/01/gradle-dependency-version-definition/</link>
      <pubDate>Tue, 25 Jan 2022 12:53:58 +0000</pubDate>
      <guid>https://satoshun.github.io/2022/01/gradle-dependency-version-definition/</guid>
      <description>&lt;p&gt;Android開発では、Gradleを使ってビルド環境を構築します。その中で、バージョンを管理する必要があります。&#xA;Gradleでは、いろいろなバージョンの管理方法があるので、色々と紹介したいと思います。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-バージョン管理しない管理方法&#34;&gt;1. バージョン管理しない管理方法&lt;/h2&gt;&#xA;&lt;p&gt;パワー系の管理方法です。&#xA;小規模なプロジェクトや、個人プロジェクトなどは、シングルモジュールな構成であったりと、そもそもバージョンを管理する必要がない場合があります。&lt;/p&gt;&#xA;&lt;p&gt;具体的には、build.gradle(.kts)にベタ書きします。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.google.android.material:material:1.4.0&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;バージョン管理をしない、バージョン管理方法です。これだと、マルチモジュール環境などで、辛くなるので進化させる必要があります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-dependenciesgradleに定義する&#34;&gt;2. dependencies.gradleに定義する&lt;/h2&gt;&#xA;&lt;p&gt;dependencies.gradleファイルを定義し、そこでバージョンを管理する方法です。&#xA;ファイル名はなんでもいいのですが、dependencies.gradleという命名が多いような気がします。&lt;/p&gt;&#xA;&lt;p&gt;具体的には、dependencies.gradleに依存を定義し、それをbuild.gradleで読み込んで使います。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// dependencies.gradle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ext &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  material &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.google.android.material:material:1.4.0&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android: non-transitive Rの導入と、ビルド時間の変化について</title>
      <link>https://satoshun.github.io/2021/11/android-non-transitive-r/</link>
      <pubDate>Sun, 14 Nov 2021 01:58:16 +0000</pubDate>
      <guid>https://satoshun.github.io/2021/11/android-non-transitive-r/</guid>
      <description>&lt;p&gt;non-transitive Rというオプションがあり、これを有効にすると、マルチモジュールなプロジェクトでのビルド時間の改善が期待できます。&lt;/p&gt;&#xA;&lt;p&gt;この記事では、non-transitive R対応の仕方と、どれくらいビルド時間が向上したかについて紹介したいと思います。&lt;/p&gt;&#xA;&lt;h2 id=&#34;non-transitive-r対応の仕方&#34;&gt;non transitive R対応の仕方&lt;/h2&gt;&#xA;&lt;p&gt;比較的新しいAndroid Studio（4.2以降?）を使っているなら、Refactor機能から変換することが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Refactor &amp;gt; Migrate to Non-transitive R Classes.&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;この機能を使うと、各モジュールのRファイル参照が、フルパッケージ名参照に置換されます。&lt;/p&gt;&#xA;&lt;p&gt;擬似コードだとこんな感じです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// before&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; jp.hoge.sample.R&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HogeFragment&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;R&lt;/span&gt;.layout.hoge_layout) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// after&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HogeFragment&lt;/span&gt;(jp.hoge.sample.&lt;span style=&#34;color:#a6e22e&#34;&gt;R&lt;/span&gt;.layout.hoge_layout) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;non-transitve Rを有効にすると、各モジュールで、Rファイルのマージ?のようなタスクが行われなくなり、Rの参照先が変わるためです。&lt;/p&gt;&#xA;&lt;p&gt;動作自体は上記のコードでも問題なく出来ます。ただ、フルパッケージ指定が気になるなら、import aliasまたは、typealiasを使うことで解決できます。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android: BuildConfigの生成をoffにする</title>
      <link>https://satoshun.github.io/2021/04/android-buildconfig/</link>
      <pubDate>Sat, 10 Apr 2021 01:13:45 +0000</pubDate>
      <guid>https://satoshun.github.io/2021/04/android-buildconfig/</guid>
      <description>&lt;p&gt;buildFeaturesから、BuildConfigクラスの生成をするかどうかを設定できるようになりました。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;gradle.properties&lt;/code&gt;から設定できます。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;android.defaults.buildfeatures.buildconfig=false # defaultはtrue&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;マルチモジュール構成のプロジェクトでは、基本的にはBuildConfigを生成しないと思うので、BuildConfigの生成のデフォルト設定をoffにしておくと良いと思います。&lt;/p&gt;&#xA;&lt;p&gt;モジュール単位で、生成をonにするには、&lt;code&gt;build.gradle&lt;/code&gt;に次の記述をします。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;android &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buildFeatures &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    buildConfig &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;buildFeaturesブロックから設定を与えることが出来ます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;&#xA;&lt;p&gt;マルチモジュール構成のプロジェクトの場合は、coreモジュールやappモジュールのみonにして、他をoffにするのが良さそう&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gradle: 新しいバージョン管理方法 Central declaration of dependenciesの紹介</title>
      <link>https://satoshun.github.io/2021/03/gradle-central-declaration-of-dependencies/</link>
      <pubDate>Sun, 28 Mar 2021 06:48:44 +0000</pubDate>
      <guid>https://satoshun.github.io/2021/03/gradle-central-declaration-of-dependencies/</guid>
      <description>&lt;p&gt;Gradleの7.0-RC01に、Central declaration of dependenciesという機能が入りました。まだ、experimentalな機能で今後どうなるか分かりませんが、気になったので紹介します。&lt;/p&gt;&#xA;&lt;p&gt;この記事を書くのに使ったサンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/Template&#34;&gt;github/satoshun-android-example&lt;/a&gt; にあります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;central-declaration-of-dependenciesが導入された背景&#34;&gt;Central declaration of dependenciesが導入された背景&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.gradle.org/7.0-rc-1/release-notes.html&#34;&gt;Gradle 7.0 Release Notes&lt;/a&gt; に次のように書いてあります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;There are a number of ways to share dependency versions between projects in multi-project builds. For example, users can declare versions or dependency coordinates directly in build scripts (in the ext block), external files (e.g dependencies.gradle), in buildSrcor even dedicated plugins. There wasn’t, however, any standard mechanism to do this which would combine the advantages of each approach.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Gradle: BOMを使って依存を指定する</title>
      <link>https://satoshun.github.io/2020/02/gradle-bom-android/</link>
      <pubDate>Tue, 18 Feb 2020 13:08:10 +0000</pubDate>
      <guid>https://satoshun.github.io/2020/02/gradle-bom-android/</guid>
      <description>&lt;p&gt;Gradleの5から、Bill Of Materials(BOM)が使えるようになりました。これが、結構いいものだと思ったので紹介します。&lt;/p&gt;&#xA;&lt;p&gt;ついでに&lt;a href=&#34;https://dependabot.com/&#34;&gt;dependabot&lt;/a&gt;の話もちょっとします。&lt;/p&gt;&#xA;&lt;h2 id=&#34;bom&#34;&gt;BOM?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.gradle.org/5.0/userguide/managing_transitive_dependencies.html#sec:bom_import&#34;&gt;BOM&lt;/a&gt;を使うことで、 複数のライブラリのバージョンを省略することが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;ドキュメントの例にはspring-bootが挙げられています。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// import a BOM&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  implementation &lt;span style=&#34;color:#a6e22e&#34;&gt;platform&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// define dependencies without versions&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.google.code.gson:gson&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dom4j:dom4j&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android マルチモジュール: Gradle周りで便利だと思う設定</title>
      <link>https://satoshun.github.io/2019/11/multi-module-gradle-properties/</link>
      <pubDate>Mon, 11 Nov 2019 00:50:18 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/11/multi-module-gradle-properties/</guid>
      <description>&lt;p&gt;マルチモジュールなアプリを作ることをテーマにブログを書いていこうの、2本目です。&lt;/p&gt;&#xA;&lt;p&gt;1本目はこちらになります。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://satoshun.github.io/2019/09/multi-module-dependency-management/&#34;&gt;Android マルチモジュール: ライブラリのバージョン管理について&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;今回は、マルチモジュール環境における、Gradle周りの便利であろう設定について、次の4つを紹介します。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モジュール内のリソース名にルールを持たせる&lt;/li&gt;&#xA;&lt;li&gt;BuildConfigを作らない&lt;/li&gt;&#xA;&lt;li&gt;モジュール内でProGuard/R8の設定をする&lt;/li&gt;&#xA;&lt;li&gt;Rファイルを小さく保つ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;モジュール内のリソース名にルールを持たせる&#34;&gt;モジュール内のリソース名にルールを持たせる&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.LibraryExtension.html#com.android.build.gradle.LibraryExtension:resourcePrefix&#34;&gt;resourcePrefix&lt;/a&gt;は、リソース名のプレフィックスにルールを設けるプロパティです。&lt;/p&gt;&#xA;&lt;p&gt;例えば、次のように書くと、このモジュール内のリソース（レイアウト、Drawable、Stringなど）は&lt;code&gt;home_&lt;/code&gt;から始まる必要があります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// build.gradle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;android &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  resourcePrefix &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;home_&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// strings.xml&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;resource&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// home_から始まる必要がある&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;string name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;home_app_name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;適当な文字列&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/string&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;/&lt;/span&gt;resource&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android マルチモジュール: ライブラリのバージョン管理について</title>
      <link>https://satoshun.github.io/2019/09/multi-module-dependency-management/</link>
      <pubDate>Mon, 23 Sep 2019 12:07:59 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/09/multi-module-dependency-management/</guid>
      <description>&lt;p&gt;マルチモジュールなアプリを作ることをテーマにいくつかの記事を書いていきたいと思っています。&lt;/p&gt;&#xA;&lt;p&gt;まだ正確には決まっていないのですが、以下のような内容をまとめていこうと思っております。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ライブラリのバージョン管理について&lt;/li&gt;&#xA;&lt;li&gt;マルチモジュール構築に役立つGradleの設定&lt;/li&gt;&#xA;&lt;li&gt;モノリシックなアプリからマルチモジュールへ&lt;/li&gt;&#xA;&lt;li&gt;外部ライブラリとして切り出すタイミングを考える&lt;/li&gt;&#xA;&lt;li&gt;DFM、モジュール間の遷移方法&lt;/li&gt;&#xA;&lt;li&gt;モジュールの階層について&lt;/li&gt;&#xA;&lt;li&gt;ビルドの高速化について&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;今回は、ライブラリのバージョン管理について書いてきます。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ライブラリのバージョン管理&#34;&gt;ライブラリのバージョン管理？&lt;/h2&gt;&#xA;&lt;p&gt;Android開発では、Gradleで外部ライブラリの依存を定義するのが一般的です。マルチモジュールプロジェクトの場合、外部ライブラリのバージョンを合わせるため、変数のような形で定義しておくと便利です。&lt;/p&gt;&#xA;&lt;p&gt;変数の定義方法には、直接記述する方法を除くと、大きく2つの方法があります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-gradleのextraプロパティを使う&#34;&gt;1. Gradleのextraプロパティを使う&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/build/gradle-tips.html#configure-project-wide-properties&#34;&gt;Androidの公式ドキュメント: Configure project-wide properties&lt;/a&gt;で紹介されている方法です。&#xA;extにバージョンを定義します。&lt;/p&gt;&#xA;&lt;p&gt;例えば、&lt;a href=&#34;https://square.github.io/okhttp/&#34;&gt;OkHttp&lt;/a&gt;では、次のように定義しています。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;buildscript &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;versions&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;animalSniffer&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1.17&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;assertj&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3.11.0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bouncycastle&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1.62&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;brotli&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0.1.2&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;deps&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;picocli&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;info.picocli:picocli:${versions.picocli}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;android&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.robolectric:android-all:9-robolectric-4913185-2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;animalSniffer&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;assertj&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.assertj:assertj-core:${versions.assertj}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bouncycastle&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;brotli&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.brotli:dec:${versions.brotli}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>&lt;p&gt;マルチモジュール遷移方法Part2です。&lt;a href=&#34;https://satoshun.github.io/2018/12/multi-module_transition_part1/&#34;&gt;Part1&lt;/a&gt;はここになります😌&lt;/p&gt;&#xA;&lt;p&gt;Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。&lt;/p&gt;&#xA;&lt;p&gt;また、今回の検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;モジュール構成について&#34;&gt;モジュール構成について&lt;/h2&gt;&#xA;&lt;p&gt;細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/img/SoWkIImgAStDuU8goIp9ILLutBpeSTEEnyrB7pVlUToy-kdipLnS1Od9sOdfgGfAYGK5yMcfYIMbHQbA2jLS2WhHG95O45sKNrgIMXJBLOkakhWqoH1DEKWe5iQ8nw7925EJ4KoJ4RAcvFpSWloyrBmIi3lGN1wha5Yi01H6LWNHYqqXH0PPxUF6kOyRrptPFGqi3t8likpBnktFb-z-tBJaSVFcnqtxmIPDVToq7CHesWdN4a-4kKQacmiB1Iuka2KAkdOebe4KGCKG2e4XeQ2Rab-U1rCC3MDq2IEi4Z1Jk20Cg7WDghrOv13sEwJcfG2J6G00&#34; width=&#34;600&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。&lt;/p&gt;&#xA;&lt;p&gt;このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。&lt;/p&gt;&#xA;&lt;p&gt;では、実装に入っていきます。今回はDagger2を使って実装をします。&lt;/p&gt;&#xA;&lt;h2 id=&#34;featureモジュール側の遷移用インターフェースの定義&#34;&gt;featureモジュール側の遷移用インターフェースの定義&lt;/h2&gt;&#xA;&lt;p&gt;前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。&lt;/p&gt;&#xA;&lt;p&gt;main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MainModuleRouter&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// sub1画面へ移動する&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;routeToSub1&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mainモジュール用のインターフェースなので、&lt;code&gt;MainModuleRouter&lt;/code&gt;という名前にし、sub1画面へ遷移するためのメソッドを定義しています。&lt;/p&gt;&#xA;&lt;p&gt;そしてこのインターフェースを、MainFragmentで使います。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MainFragment&lt;/span&gt; : Fragment() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Inject&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; moduleRouter: MainModuleRouter&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onViewCreated&lt;/span&gt;(view: View, savedInstanceState: Bundle?) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.onViewCreated(view, savedInstanceState)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    view.findViewById&amp;lt;View&amp;gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;R&lt;/span&gt;.id.route).setOnClickListener {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      moduleRouter.routeToSub1()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>&lt;p&gt;マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）&lt;/p&gt;&#xA;&lt;p&gt;例えば、以下のモジュール構成を考えます。&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0mYXQcxO-RfvcY4rbSMcI8QPI8nnAZRYuk81cA-Ycv9VdwTf1TAC90DKufEQb0Bq40000&#34; width=&#34;400&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。&lt;/p&gt;&#xA;&lt;p&gt;そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0miXQGGPEcunDOMPnQHAA9KrR7pTFCyIc5AZI45Ef4GwbHbnSN41NAEYcv9VdwTf1BE82aN0Xi87e8a1z3gbvAS000G00&#34; width=&#34;400&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。&lt;/p&gt;&#xA;&lt;p&gt;ただし、いくつか条件があります。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-中間モジュールで公開可能なものに限る&#34;&gt;1. 中間モジュールで公開可能なものに限る&lt;/h3&gt;&#xA;&lt;p&gt;例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。&#xA;これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。&lt;/p&gt;&#xA;&lt;p&gt;中間モジュールのコードイメージとしては以下のようになります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createUserFragment&lt;/span&gt;(userName: String, age: Int): Fragment {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserFragment&lt;/span&gt;.createFragment(userName, age)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createUserIntent&lt;/span&gt;(context: Context): Intent {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Intent(context, UserActivity&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;.java)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://medium.com/@keyboardsurfer/dependency-injection-in-a-multi-module-project-1a09511c14b7&#34;&gt;Dependency injection in a multi module project&lt;/a&gt;を見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。&lt;/p&gt;&#xA;&lt;p&gt;結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。&lt;/p&gt;&#xA;&lt;p&gt;また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。&lt;/p&gt;&#xA;&lt;p&gt;検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;satoshun-android-example/DynamicFeatureDaggerExample&lt;/a&gt;にあります😊&lt;/p&gt;&#xA;&lt;h2 id=&#34;前提知識&#34;&gt;前提知識&lt;/h2&gt;&#xA;&lt;p&gt;通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。&#xA;ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLukc_oixbB7pUkUx9lxjErCvxEtip5bPoVMv2VbvfNeX2TM53mk7dHuwOTZvkNFcxUyxXvTQn2Oh42K1XPrUEchO-RfnbYKrbSccI8gTG8Xr8ZBYukeDaAkYdvvNcwTX3TQ090DGwfUIb0Fm00&#34; width=&#34;300&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLmgSnBpCrCLd1BJImfBKfztBZkoRwvJzVEU3fxCnTNSdvkGNvUQbw9GdHYGS7ZvaMFctOyRbxwk7dFu-RLiGg9nGf0OMHLZvksFcwUPeXDPN5faY6cKYCSIesukBX0EXHqK_BBytJjm1Q1n544k1nIyrA0dW40&#34; width=&#34;300&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。&lt;/p&gt;&#xA;&lt;p&gt;ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;&#xA;&lt;p&gt;Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。&#xA;実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。&lt;/p&gt;&#xA;&lt;p&gt;では、実装を始めます。&lt;/p&gt;&#xA;&lt;p&gt;最初に、SubActivityをDaggerApplicationのように振る舞わさせるために&lt;code&gt;ModuleRootActivity&lt;/code&gt;クラスを定義します。&#xA;それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ModuleRootActivity&lt;/span&gt; : AppCompatActivity(),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  HasModuleInjector {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Inject&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; injector: ModuleActivityInjector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    injector = moduleComponent.moduleInjector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    injector.activity.inject(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.onCreate(savedInstanceState)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; moduleComponent: ModuleActivityComponent&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;supportFragmentInjector&lt;/span&gt;(): AndroidInjector&amp;lt;Fragment&amp;gt; =&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fragmentInjector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ModuleActivityInjector&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@Inject&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constructor&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ModuleActivityComponent&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; moduleInjector: ModuleActivityInjector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HasModuleInjector&lt;/span&gt; : HasSupportFragmentInjector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ModuleChildFragment&lt;/span&gt; : Fragment() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onAttach&lt;/span&gt;(context: Context) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;AndroidSupportInjection&lt;/span&gt;.inject(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.onAttach(context)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>&lt;p&gt;Androidのトレンドの1つにマルチモジュール構成があります。&#xA;マルチモジュールによるメリットとして、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビルド時間の短縮&lt;/li&gt;&#xA;&lt;li&gt;依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。&lt;/p&gt;&#xA;&lt;p&gt;この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい&lt;/li&gt;&#xA;&lt;li&gt;コード量を減らしたい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Part1では、遷移専用のモジュールを作る方法を考えてみます。&lt;/p&gt;&#xA;&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;遷移専用のモジュールを作る&#34;&gt;遷移専用のモジュールを作る&lt;/h2&gt;&#xA;&lt;p&gt;まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。&lt;/p&gt;&#xA;&lt;p&gt;例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メインではサブ画面が必要なのでサブモジュールに依存する&lt;/li&gt;&#xA;&lt;li&gt;サブではメイン画面が必要なのでメインモジュールに依存する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwecY1CaGcBmH5nSNa5BGBSfCpoZHjOE8WGW5tPpKDAW85vT3QbuAq6K0&#34; width=&#34;300&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。&#xA;直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。&lt;/p&gt;&#xA;&lt;p&gt;そこで、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メイン画面に遷移するメインルーターモジュール&lt;/li&gt;&#xA;&lt;li&gt;サブ画面に遷移するサブルーターモジュール&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;の2つのモジュールを作ります。&lt;/p&gt;&#xA;&lt;p&gt;メインルーターモジュールでは次の遷移専用インターフェースを定義します。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MainRouter&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;routeToMain&lt;/span&gt;(context: Context): Intent&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>&lt;p&gt;&lt;code&gt;JitPack&lt;/code&gt;からライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。&#xA;詳しくは次のリンクを参照してください。&lt;a href=&#34;https://blog.autsoft.hu/a-confusing-dependency/&#34;&gt;A Confusing Dependency&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に &lt;a href=&#34;https://docs.gradle.org/5.1-rc-1/userguide/declaring_repositories.html#sec::matching_repositories_to_dependencies&#34;&gt;Matching repositories to dependencies&lt;/a&gt; が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）&lt;/p&gt;&#xA;&lt;p&gt;まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、&lt;code&gt;cloudflare&lt;/code&gt;のSDKを依存関係に入れることを目指します。&#xA;また、今回の検証にはGradle 5.1-rc-1を使いました。&lt;a href=&#34;https://github.com/satoshun-android-example/GradleDependencyMatchingExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;まずは従来の書き方です。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// topのbuild.gradle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;allprojects &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    repositories &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        maven &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            url &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://storage.googleapis.com/cloudflare-maven/public/&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// projectのbuild.gradle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; この記事はapiとimplementationの説明をする類の記事ではありません。&lt;/p&gt;&#xA;&lt;p&gt;Gradleで&lt;code&gt;compile&lt;/code&gt;がDeprecatedになり、implementationまたはapiを使うことが推奨されています。&#xA;それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。&lt;/p&gt;&#xA;&lt;p&gt;Dagger2でもcompileをimplementationに置き換えるPRが出されました。https://github.com/google/dagger/pull/1130&lt;/p&gt;&#xA;&lt;p&gt;内容が興味深かったのでまとめてみようと思います。&lt;/p&gt;&#xA;&lt;p&gt;まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Add Dagger dependencies&#xA;dependencies {&#xA;  - compile &amp;#39;com.google.dagger:dagger:2.x&amp;#39;&#xA;  + implementation &amp;#39;com.google.dagger:dagger:2.x&amp;#39;&#xA;  annotationProcessor &amp;#39;com.google.dagger:dagger-compiler:2.x&amp;#39;&#xA;}&#xA;&#xA;- compile &amp;#39;com.google.dagger:dagger-android:2.x&amp;#39;&#xA;- compile &amp;#39;com.google.dagger:dagger-android-support:2.x&amp;#39; // if you use the support libraries&#xA;+ implementation &amp;#39;com.google.dagger:dagger-android:2.x&amp;#39;&#xA;+ implementation &amp;#39;com.google.dagger:dagger-android-support:2.x&amp;#39; // if you use the support libraries&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここでjakeさんが&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
