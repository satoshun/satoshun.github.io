<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Retrofit on stsnブログ</title>
    <link>https://satoshun.github.io/tags/retrofit/</link>
    <description>Recent content in Retrofit on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Tue, 02 Jul 2019 13:46:54 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/tags/retrofit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Retrofit: Coroutineを使うときの、Response&lt;T&gt;と生のTの使い分け</title>
      <link>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</link>
      <pubDate>Tue, 02 Jul 2019 13:46:54 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</guid>
      <description>&lt;p&gt;psideさんの、&lt;a href=&#34;https://qiita.com/pside/items/e546f0f12989e8dcd729&#34;&gt;Retrofit2でRxJavaを使う時の Result&lt;T&gt;, Response&lt;T&gt;, そのままT の使い分け所感&lt;/a&gt;のCoroutineバージョンの記事となります。&lt;/p&gt;&#xA;&lt;p&gt;上記の記事に書いてある、Rxとは違い、Result型は用意されていないので、Response型で包むか、生で値ｗ受け取るかのどちらかが基本となります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HogeService&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getHoge&lt;/span&gt;(): Hoge&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    or&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getHoge&lt;/span&gt;(): Response&amp;lt;Hoge&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Retrofitの2.6.0で、挙動の違いを確認しました。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;生&lt;/th&gt;&#xA;          &lt;th&gt;Response&lt;T&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;200&lt;/td&gt;&#xA;          &lt;td&gt;成功&lt;/td&gt;&#xA;          &lt;td&gt;成功&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;404&lt;/td&gt;&#xA;          &lt;td&gt;例外&lt;/td&gt;&#xA;          &lt;td&gt;成功&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ネットワークに繋がっていない&lt;/td&gt;&#xA;          &lt;td&gt;例外&lt;/td&gt;&#xA;          &lt;td&gt;例外&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;シリアライズが出来ない（型がおかしい）&lt;/td&gt;&#xA;          &lt;td&gt;例外&lt;/td&gt;&#xA;          &lt;td&gt;例外&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生の場合、HTTPのstatus Code的に失敗とされるものは例外になる&lt;/li&gt;&#xA;&lt;li&gt;Response型で包めば、HTTPのstatus Code的に失敗だとしても例外が発生しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;っていう感じの挙動になります。&lt;/p&gt;&#xA;&lt;h2 id=&#34;どっちを使えばいいの&#34;&gt;どっちを使えばいいの?&lt;/h2&gt;&#xA;&lt;p&gt;サーバがエラーコードを返してきた時に、特別な振る舞いをしたいエンドポイントってあると思うので、そういうときはResponseで包んであげて、それ以外は生でいいんじゃない？って思ってます（小並感&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/blob/master/CHANGELOG.md#version-250-2018-11-18&#34;&gt;Retrofit 2.5.0&lt;/a&gt;からカスタムアノテーションが使えるようになったので、それの紹介です。&lt;/p&gt;&#xA;&lt;p&gt;例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。&lt;/p&gt;&#xA;&lt;p&gt;まず最初にアノテーションを定義します。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;annotation&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RequireAuth&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;次に、上記で定義したアノテーションを使い、Apiを定義します。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ApiService&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@RequireAuth&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@GET&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;login&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;login&lt;/span&gt;(: retrofit2.Call&amp;lt;Unit&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;次に、&lt;code&gt;RequireAuth&lt;/code&gt;を処理するための&lt;code&gt;okhttp3.Interceptor&lt;/code&gt;を定義します。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AuthInterceptor&lt;/span&gt; : Interceptor {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;intercept&lt;/span&gt;(chain: &lt;span style=&#34;color:#a6e22e&#34;&gt;Interceptor&lt;/span&gt;.Chain): Response {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; request = chain.request()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; invocation = request.tag(Invocation&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;.java)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; authAnnotation = invocation&lt;span style=&#34;color:#f92672&#34;&gt;?.&lt;/span&gt;method()&lt;span style=&#34;color:#f92672&#34;&gt;?.&lt;/span&gt;getAnnotation(RequireAuth&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;.java)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (authAnnotation &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      request = request&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .newBuilder()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .addHeader(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Basic AAAAA&amp;#34;&lt;/span&gt;).build()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chain.proceed(request)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ここでのポイントは、&lt;code&gt;val invocation = request.tag(Invocation::class.java)&lt;/code&gt;です。&#xA;Retrofit 2.5.0から&lt;code&gt;Invocation&lt;/code&gt;が追加され、&lt;code&gt;Request&lt;/code&gt;から&lt;code&gt;Invocation&lt;/code&gt;が取得できるようになりました。&#xA;&lt;code&gt;Invocation&lt;/code&gt;には、処理している&lt;code&gt;Request&lt;/code&gt;の&lt;code&gt;java.lang.reflect.Method&lt;/code&gt;が格納されており、&#xA;そこからアノテーションの情報を取得することができます。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)&lt;/code&gt;で、&#xA;メソッドに&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションが付与されているかどうかを知ることが出来ます。&#xA;&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションがついていれば、&lt;code&gt;Request&lt;/code&gt;のヘッダーに認証情報を追加します。&lt;/p&gt;&#xA;&lt;p&gt;最後に、上記の&lt;code&gt;Interceptor&lt;/code&gt;をOkHttpクライアントに付与します。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; client = &lt;span style=&#34;color:#a6e22e&#34;&gt;OkHttpClient&lt;/span&gt;.Builder()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .addInterceptor(AuthInterceptor())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .build()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これでRetrofitでカスタムアノテーションを使うことが出来ます!!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;&#xA;&lt;p&gt;この記事では, JakeWhartonさんの&lt;a href=&#34;https://github.com/JakeWharton/u2020&#34;&gt;u2020&lt;/a&gt;から, AndroidでDagger2を使うときの実践的な方法を紹介します.&#xA;u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.&lt;/p&gt;&#xA;&lt;p&gt;DI, Dagger2の基本について知りたい方は, &lt;a href=&#34;https://satoshun.github.io/2015/05/dagger2/&#34;&gt;Part1&lt;/a&gt;を見て下さい.&lt;/p&gt;&#xA;&lt;p&gt;目次&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;debugとproductionでModuleを切り替える&lt;/li&gt;&#xA;&lt;li&gt;Debug専用のViewを作る&lt;/li&gt;&#xA;&lt;li&gt;Mockモードの定義&#xA;-　まとめ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;debugとproductionでmoduleを切り替える&#34;&gt;debugとproductionでModuleを切り替える&lt;/h2&gt;&#xA;&lt;p&gt;gradleは, &lt;code&gt;productFlavors&lt;/code&gt;を設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります.&#xA;そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています.&#xA;具体的には,&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/src/production/java/com/jakewharton/u2020/Modules.java&lt;/li&gt;&#xA;&lt;li&gt;/src/internalDebug/java/com/jakewharton/u2020/Modules.java&lt;/li&gt;&#xA;&lt;li&gt;/src/internalRelease/java/com/jakewharton/u2020/Modules.javaに&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています.&#xA;これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.&lt;/p&gt;&#xA;&lt;p&gt;こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Debugのみログを有効にしたい&lt;/li&gt;&#xA;&lt;li&gt;APIのエンドポイントを変えたい&lt;/li&gt;&#xA;&lt;li&gt;debug専用のViewを出したい&lt;/li&gt;&#xA;&lt;li&gt;Test用のインスタンスをinjectしたい&lt;/li&gt;&#xA;&lt;li&gt;etc, etc&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以下では, より細かく説明していきます.&lt;/p&gt;&#xA;&lt;h2 id=&#34;debug専用のviewを作る&#34;&gt;Debug専用のViewを作る&lt;/h2&gt;&#xA;&lt;p&gt;u2020では, Debug専用のView &lt;code&gt;DebugAppContainer&lt;/code&gt;があります.&#xA;&lt;a href=&#34;https://github.com/JakeWharton/u2020/blob/master/u2020.gif&#34; target=&#34;\_blank&#34;&gt;Debug専用のView&lt;/a&gt;&#xA;はこんな感じです. Debugビルドの時は, このContainerをinjectしています.&lt;/p&gt;&#xA;&lt;p&gt;DebugAppContainerは簡単にいえば, &lt;code&gt;DrawerLayout&lt;/code&gt;を1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.&lt;/p&gt;&#xA;&lt;h2 id=&#34;mockモードの定義&#34;&gt;Mockモードの定義&lt;/h2&gt;&#xA;&lt;p&gt;u2020ではMockモードがあり, Mockデータを表示機能があります.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DebugDataModule&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Provides&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@Singleton&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@ApiEndpoint&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  StringPreference &lt;span style=&#34;color:#a6e22e&#34;&gt;provideEndpointPreference&lt;/span&gt;(SharedPreferences preferences) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringPreference(preferences, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;debug_endpoint&amp;#34;&lt;/span&gt;, ApiEndpoints.&lt;span style=&#34;color:#a6e22e&#34;&gt;MOCK_MODE&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;@Provides&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@Singleton&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@IsMockMode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;provideIsMockMode&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;@ApiEndpoint&lt;/span&gt; StringPreference endpoint) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ApiEndpoints.&lt;span style=&#34;color:#a6e22e&#34;&gt;isMockMode&lt;/span&gt;(endpoint.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上記のコードを見て分かる通り, デバッグビルドの時はMockモードが有効になります. デバッグ時にサーバがなくて困る時がありますが, u2020では, assets/内にデバッグ用のモックデータを入れておくことで,&#xA;サーバ問題を解決しています. retrofitの&lt;code&gt;MockRestAdapter&lt;/code&gt;を組み合わせ, mockからデータを取得しています.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
