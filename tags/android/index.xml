<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android on stsnブログ</title>
    <link>https://satoshun.github.io/tags/android/</link>
    <description>Recent content in android on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sun, 22 May 2022 12:53:30 +0000</lastBuildDate><atom:link href="https://satoshun.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>マルチモジュール環境の開発改善について雑談</title>
      <link>https://satoshun.github.io/2022/05/android-improve-development-multimodule/</link>
      <pubDate>Sun, 22 May 2022 12:53:30 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/05/android-improve-development-multimodule/</guid>
      <description>この記事では、昨今のマルチモジュール環境の開発改善について雑談をします。この記事は文章がまとまってないです。（いつかもう少しいい感じにまとめます）
大きいプロジェクトの場合、マルチモジュールプロジェクトに移行するケースは多いと思います。歴史とともに機能が増えていき、どうしてもビルド時間の増加、IDEのパフォーマンス低下などが発生します。
どう頑張っても、app全体のビルド時間の短縮には限界があります。そこで、機能単位でもアプリを作れるようにすることで、改善を試みます。 機能単位と言っても、すべての機能ごとにアプリを作れるようにする必要はなくて、開発が活発な機能に絞って作れるようにしておくと良いです。新機能であったり、コア機能などが該当します。
ここで、どのように機能単位のアプリを作るのかって話なんですが、Dagger Hiltを使っているなら、DaggerのDIの解決さえ出来れば、機能アプリを作ることが出来ます。DIをどのように解決するかって話なんですが、既存のapplicationモジュールから、Dagger DI部分を切り出したapplication-diモジュールを作って、それを機能アプリから参照すれば、ほぼ解決出来ると思います。どうしても解決できないクラスは、MockHogeHogeみたいにして、機能アプリ内のモジュールで解決してあげれば良いです。
機能モジュールを作ることで、ビルド時間は短縮出来ますが、IDEのインデックス時間などは改善されません。そこでさらに、focusを組み合わせることで、IDEのパフォーマンス改善が期待できます。 focusの使い方は、下記のリンクを参考にしてください。
 https://dropbox.tech/mobile/introducing-focus-a-new-open-source-gradle-plugin https://github.com/dropbox/focus  例えば、機能が20個のプロジェクトの場合に、focusを使うことで、19個の機能モジュールの読み込みを制限することが出来ます。実際にはデータモジュール等、機能モジュール以外のモジュールもあるので、そう単純な話ではないんですが、それでもかなりのモジュールの読み込みを削減が期待できます。
大規模なプロジェクトの場合、機能ごとにアプリを作れるようにする + focusを使うことで開発環境の改善が期待できるので、検討して見るのも良いと思います。</description>
    </item>
    
    <item>
      <title>Dagger2: 拡張関数を使い、@Bindsの定義をシンプルにする</title>
      <link>https://satoshun.github.io/2022/04/dagger-binds-extension-method/</link>
      <pubDate>Sun, 24 Apr 2022 06:16:34 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/04/dagger-binds-extension-method/</guid>
      <description>Dagger2のtipsです。
Dagger2では、Bindsアノテーションを使うことで、キャストした型をバインディングすることが出来ます。 例えば、次のように使います。
@Module interface AppModule {  @Binds fun bindHoge(impl: HogeImpl): Hoge } このときに、拡張関数を使うことで、少しシンプルに書くことが出来ます。
@Module interface AppModule {  @Binds fun HogeImpl.bindHoge(): Hoge } 同様に、拡張プロパティを使うことも出来ます。
@Module interface AppModule {  @get:Binds val HogeImpl.bindHoge: Hoge } 拡張関数を使うと、コード量が減り、シンプルになるのでおすすめです。</description>
    </item>
    
    <item>
      <title>Android: Gradle Build Scanで、マルチモジュール環境のビルド改善</title>
      <link>https://satoshun.github.io/2022/04/gradle-buildperformance-scan/</link>
      <pubDate>Sun, 10 Apr 2022 07:10:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/04/gradle-buildperformance-scan/</guid>
      <description>GradleにはBuild Scanという機能があり、これを使うことで、プロジェクトのビルドの全体像を知ることが出来ます。
使い方は簡単で --scan を指定するだけです。
./gradlew assembleDebug --scan これで、GradleのBuild Scanをしてくれます。 今回はこれをヒントにして、モジュール間の依存を見直すことで、ビルドの改善をしてみます。
左タブのTimelineから、全体的なビルドの確認をすることが出来ます。
Timelineでは、どのような順番でmoduleのビルドが行われたかを確認することが出来ます。 時間が掛かっているモジュール（クリティカルパス）を改善すれば、全体のビルドを改善することが期待できます。
Timelineでは、どのモジュールがクリティカルパスになっているかを検索することが出来ます。
クリティカルパス検索をすると、次の画像のように、クリティカルなタスク（モジュール）に色が付きます。
これで、クリティカルパスとなっているモジュールを知ることが出来ます。
次に、このクリティカルなモジュールの改善を考えます。大きく2つの方法があると思います。
 モジュール自体のサイズを小さくする → このモジュールで管理するクラス数を減らす ビルドするタイミングを早くする → 他のモジュールへの依存を減らす  1.に関しては、それはそうという感じなので、2について説明します。
例えば、A &amp;lt;- B &amp;lt;- C のような依存構成になっているときに、Bがクリティカルであるとします。 このときに、BがAに依存しないように変更することで、Bのビルドタイミングを早めることができ、全体のビルドが改善されることが期待できます。 「BがAに依存しないように変更できる」、また、「その変更によってモジュールの責務が崩れない」ことが前提となりますが、無駄な他モジュールへの依存を無くすだけでも、ビルドの改善が出来る場合があります。
まとめ こんな感じで、Gradle Scanを使い、ちょこちょことTimelineのクリティカルパスを改善することで、ビルド時間の改善が期待出来ます。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: debugInspectorInfoを使って、デバッグを少し楽にする</title>
      <link>https://satoshun.github.io/2022/03/compose-debug-inspector-info/</link>
      <pubDate>Sun, 06 Mar 2022 12:12:41 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/03/compose-debug-inspector-info/</guid>
      <description>Android Studioで、Layout Inspector を使うことで、レイアウトの配置や、実際にどのような値がセットされているかの詳細を見る事ができます。
Jetpack Composeでは、そのLayout Inspectorに情報を渡すことができます。
どのように渡すかを Modifier.border を例にして説明します。まず、Modifier.borderを次のように使ってみます。
Surface(  modifier = Modifier  .border(width = 2.dp, color = Color.Cyan) ) { ... } そして、Layout Inspectorで、このSurfaceの中身を見てみます。
 modifierの中に、borderがあり、詳細な情報があることが分かります。
では次に、Modifier.border ではどのようにして、Layout Inspectorに値をセットしているかを見ていきます。
fun Modifier.border(width: Dp, brush: Brush, shape: Shape): Modifier = composed(  factory = { ... },  inspectorInfo = debugInspectorInfo {  name = &amp;#34;border&amp;#34;  properties[&amp;#34;width&amp;#34;] = width  if (brush is SolidColor) {  properties[&amp;#34;color&amp;#34;] = brush.</description>
    </item>
    
    <item>
      <title>Gradle: Typesafe project dependencies</title>
      <link>https://satoshun.github.io/2022/02/gradle-typesafe-accessor/</link>
      <pubDate>Sun, 27 Feb 2022 11:42:50 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/02/gradle-typesafe-accessor/</guid>
      <description>Type-safe project dependenciesの紹介ブログです。Gradle 7.4で試しています。
Gradleでマルチモジュールプロジェクトを構成すると、例えば、プロジェクトlibAへの依存は、次のようにう書くことが出来ます。
// app/build.gradle.kts  dependencies {  implementation(project(&amp;#34;:libA&amp;#34;))  ... } この際に、projectで指定している :libA の部分は文字列なのでtypesafeではなく、補完などが効きにくいです。(最近のIntelliJ、Android Studioだと補完が効いたりします)
ここで、今回紹介する Type-safe project dependenciesを使うと、次のように書くことが出来ます。
// settings.gradle enableFeaturePreview(&amp;#34;TYPESAFE_PROJECT_ACCESSORS&amp;#34;) // app/build.gradle.kts  dependencies {  implementation(projects.libA)  ... } projectsから、プロジェクトlibA参照出来るようになり、補完がいい感じに効きます。
まとめ Gradle 7.4段階では、まだFeature Previewですが、ktsと相性が良い技術になっています。 ktsを入れているようなプロジェクトの場合は、導入を検討するのも良いかもしれません。
参考  https://docs.gradle.org/7.4/userguide/declaring_dependencies.html#sec:type-safe-project-accessors  </description>
    </item>
    
    <item>
      <title>Gradle Profilerを使って、ビルドを最適化する</title>
      <link>https://satoshun.github.io/2022/02/gradle-profile-build/</link>
      <pubDate>Sun, 06 Feb 2022 03:39:04 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/02/gradle-profile-build/</guid>
      <description>開発を高速化するために、ビルド速度を改善することは重要です。 Gradleの設定を見直すことで、ビルド速度を改善できる可能性があります。
この記事では、Gradle Profilerを使って、自分の環境において最適そうな設定を見つける方法を紹介します。
Gradle Profilerとは? Gradle Profiler は、Gradleのプロファイリング、ベンチマークを計測してくれるツールです。
Gradle Profilerを使うことで、最適なGradleの設定を見つけだすことが出来ます。
良さそうな設定を見つける まず、最初にシナリオファイルを作成します。これは、Gradle Profilerを実行する際に必要なファイルで、記述したシナリオ通りに実行してくれます。
今回は、次のようなシナリオを作りました。
# scenario.txt clean_build_2gb_2workers {  tasks = [&amp;#34;:app:assembleDebug&amp;#34;]  gradle-args = [&amp;#34;--max-workers=2&amp;#34;]  jvm-args = [&amp;#34;-Xmx2048m&amp;#34;]  cleanup-tasks = [&amp;#34;clean&amp;#34;] }  clean_build_4gb_4workers {  tasks = [&amp;#34;:app:assembleDebug&amp;#34;]  gradle-args = [&amp;#34;--max-workers=4&amp;#34;]  jvm-args = [&amp;#34;-Xmx4096m&amp;#34;]  cleanup-tasks = [&amp;#34;clean&amp;#34;] } このシナリオでは、worker数と、メモリの値をそれぞれ設定しています。
このシナリオは、Gradle Profilerコマンドを使って、次のように実行できます。
gradle-profiler --benchmark --project-dir . --scenario-file scenarios.txt これを実行すると、ビルドにどれくらい時間が掛かったかの出力してくれます。
   この結果から、僕の環境 + このプロジェクトの場合、2GB、2workerよりも4GB、4workerで設定したほうが良さそうなことが分かります。</description>
    </item>
    
    <item>
      <title>Gradle: 様々なバージョン管理の方法</title>
      <link>https://satoshun.github.io/2022/01/gradle-dependency-version-definition/</link>
      <pubDate>Tue, 25 Jan 2022 12:53:58 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/01/gradle-dependency-version-definition/</guid>
      <description>Android開発では、Gradleを使ってビルド環境を構築します。その中で、バージョンを管理する必要があります。 Gradleでは、いろいろなバージョンの管理方法があるので、色々と紹介したいと思います。
1. バージョン管理しない管理方法 パワー系の管理方法です。 小規模なプロジェクトや、個人プロジェクトなどは、シングルモジュールな構成であったりと、そもそもバージョンを管理する必要がない場合があります。
具体的には、build.gradle(.kts)にベタ書きします。
dependencies {  implementation &amp;#34;com.google.android.material:material:1.4.0&amp;#34;  ... } バージョン管理をしない、バージョン管理方法です。これだと、マルチモジュール環境などで、辛くなるので進化させる必要があります。
2. dependencies.gradleに定義する dependencies.gradleファイルを定義し、そこでバージョンを管理する方法です。 ファイル名はなんでもいいのですが、dependencies.gradleという命名が多いような気がします。
具体的には、dependencies.gradleに依存を定義し、それをbuild.gradleで読み込んで使います。
// dependencies.gradle ext {  material = &amp;#34;com.google.android.material:material:1.4.0&amp;#34;  ... } // build.gradle apply from: rootProject.file(&amp;#39;dependencies.gradle&amp;#39;) // app/build.gradle dependencies {  implementation rootProject.ext.kotlinStdlib } 参考コード: https://github.com/JakeWharton/RxBinding/tree/version-one
また、わざわざdependencies.gradleにファイルを分けないで、build.gradleに直接書くことも出来ます。
// build.gradle buildscript {  ext.versions = [  &amp;#34;material&amp;#34;: &amp;#34;com.google.android.material:material:1.4.0&amp;#34;  ] } 参考コード: https://github.com/JakeWharton/RxBinding
3. buildSrcを使う buildSrcディレクトリを使い、バージョンの管理をする方法です。 GradleではbuildSrcは特別なディレクトリになっており、ビルド実行時に自動で中身を読み込みます。
具体的には、次のようになります。今回は、kotlinでバージョンを管理してみます。
// buildSrc/src/main/java/Dep.</description>
    </item>
    
    <item>
      <title>moleculeライブラリで感動したところ</title>
      <link>https://satoshun.github.io/2022/01/android-molecule/</link>
      <pubDate>Sun, 02 Jan 2022 08:53:09 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/01/android-molecule/</guid>
      <description>moleculeは、Cash App(Square)社が公開したライブラリです。
このライブラリを使うかどうかは置いておいて、良いな、面白いなと思ったところをつらつらと述べたいと思います。
Coroutine(RxJava)などの複雑なオペレーターを覚えなくて済む 複雑な画面になると、複数のデータソース(Flowなど)をcombineLatest等のオペレータで束ねて、処理を書くことをすると思います。 しかし、データソースが増えると、どんどんエラーハンドリングなどが複雑になり、スケールしない印象があります。
これを、moleculeでは命令型コードで書くことができ、データソースが増えてもスケールしてコードを書くことが出来ます。
RxJavaに傾倒していたときに感じていたのですが、いろいろなオペレーターがあるのは便利ではあるんですが、複雑になりやすいというか、誤用しがちなので、そういうのを防ぐことが出来ます。
Jetpack Composeのエコシステムに乗っている点 おそらく、このmoleculeのような機能を実現しようとすると、KSPなどのアノテーションプロセッシング的なことをする必要があります。 そうなると、
 メンテナ目線: 実装、メンテにコストがかかる ユーザ目線: 学習コストが高くつく  などのデメリットがあります。
それを、Jetpack Composeという、Android開発者であれば、いつかは勉強しなければならない、導入するであろう機能を使って、実現しており、このデメリットを回避しています。
一番メンテしやすいコードは、コードを書かないこと、みたいな言葉があったような気がするんですが、それを体現した実装だと思います。
まとめ 実現したい機能に対して、極力コードを書かなくて済む方法を考える大切さを感じました（小並感）</description>
    </item>
    
    <item>
      <title>Android: non-transitive Rの導入と、ビルド時間の変化について</title>
      <link>https://satoshun.github.io/2021/11/android-non-transitive-r/</link>
      <pubDate>Sun, 14 Nov 2021 01:58:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/11/android-non-transitive-r/</guid>
      <description>non-transitive Rというオプションがあり、これを有効にすると、マルチモジュールなプロジェクトでのビルド時間の改善が期待できます。
この記事では、non-transitive R対応の仕方と、どれくらいビルド時間が向上したかについて紹介したいと思います。
non transitive R対応の仕方 比較的新しいAndroid Studio（4.2以降?）を使っているなら、Refactor機能から変換することが出来ます。
Refactor &amp;gt; Migrate to Non-transitive R Classes.
この機能を使うと、各モジュールのRファイル参照が、フルパッケージ名参照に置換されます。
擬似コードだとこんな感じです。
// before import jp.hoge.sample.R  class HogeFragment(R.layout.hoge_layout) { }  // after class HogeFragment(jp.hoge.sample.R.layout.hoge_layout) { } non-transitve Rを有効にすると、各モジュールで、Rファイルのマージ?のようなタスクが行われなくなり、Rの参照先が変わるためです。
動作自体は上記のコードでも問題なく出来ます。ただ、フルパッケージ指定が気になるなら、import aliasまたは、typealiasを使うことで解決できます。
擬似コードだとこんな感じです。
// import alias import jp.hoge.sample.R as SampleR  class HogeFragment(SampleR.layout.hoge_layout) { }  // typealias typealias SampleRLayout = jp.hoge.sample.R.layout  class HogeFragment(SampleRLayout.hoge_layout) { } non-transitive R対応はこれで完了です。
どれくらい速度向上があったか? 前提として、CI上で計測したので、ローカル環境とは異なります。
計測には、Gradle-Profilerを使い、applicationモジュールのファイルが変更された時の、インクリメンタルビルド時間の変化について、計10回反復し測定しました。
結果、おおよそ20%程度の速度向上が見られました。R参照がフルパッケージになるなど、多少不便な点はありますが、十分に導入する価値があると感じました。
まとめ マルチモジュールな環境で、大きなプロジェクトなら導入するのを検討するのが良いと感じました。 また、Refactor機能が賢いので、導入にもそう手間は掛からないと思います。</description>
    </item>
    
    <item>
      <title>GitHub Actions: Composite Run Stepsの簡単な使い方</title>
      <link>https://satoshun.github.io/2021/08/github-actions-composite-run-steps/</link>
      <pubDate>Sun, 29 Aug 2021 13:18:37 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/08/github-actions-composite-run-steps/</guid>
      <description>Composite Run Stepsを使うと、GitHub Actionsでactionを再利用する事ができます。
この記事では、同一リポジトリ内で使い回すパターンの、Composite Run Stepsについて紹介します。
最終的には、こんな感じになります
 composite run stepの定義側 composite run stepを使う側  ローカルcomposite run stepsの定義 今回は、Java11のセットアップをする、setup-java ステップを作ってみたいと思います。
最初に、次のパスにaction.ymlを作ります。
.github/actions/setup-java/action.yml
action.ymlは次のようになります。
name: &amp;#39;Java Setup&amp;#39; description: &amp;#39;Installs Java&amp;#39;  runs:  using: &amp;#39;composite&amp;#39;  steps:  - name: Install Java 11  uses: actions/setup-java@v2  with:  distribution: &amp;#39;adopt&amp;#39;  java-version: &amp;#39;11&amp;#39; 今回は1つのstepしか使っていませんが、stepsには複数stepを定義することが出来るので、処理を1箇所にまとめることが可能です。
setup-javaをworkflowから使う 次に、定義したsetup-javaを使ってみます。
jobs:  build:  runs-on: ubuntu-latest   steps:  - name: Checkout  uses: actions/checkout@v2   - name: Setup Java  uses: .</description>
    </item>
    
    <item>
      <title>Testifyを使って、Jetpack Composeのスクリーンショットテストをする</title>
      <link>https://satoshun.github.io/2021/07/android-testify-jetpack-compose/</link>
      <pubDate>Sun, 18 Jul 2021 07:44:46 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/07/android-testify-jetpack-compose/</guid>
      <description>(この記事は、ほぼ、Testify のREADMEに書いてあることをやっているだけです)
Testify を使って、Jetpack Composeのスクリーンショットテストをしてみます。
セットアップ READMEに記してある通り、build.gradleに下記の設定を追加します。
dependencies {  classpath &amp;#34;com.shopify.testify:plugin:1.1.0-beta2&amp;#34; }  apply plugin: &amp;#39;com.shopify.testify&amp;#39; これで完了です。
テストを書いてみる JUnit4ベースのScreenshotRule と、ScreenshotInstrumentation アノテーションを使います。
class AppActivityTest {  @get:Rule val rule = ScreenshotRule(TestActivity::class.java)   @ScreenshotInstrumentation  @Test  fun test() {  rule.activity.runOnUiThread {  rule.activity.setContent { AppContent() } // AppContent関数は適当なComposeコンポーネント  }  Thread.sleep(500) // 一応  rule.assertSame()  } } こんな感じでテストを記述できます。ScreenshotRule を使って、適当なActivityを起動する。それに、Jetpack Composeコンポーネントをセットする感じです。
次にテストの実行をします。まず下準備として、baseとなる画像を生成します。
./gradlew screenshotRecord これでスクリーンショット(pngファイル)がローカルにコピーされるので、Gitなどにコミットしておきます。
次に、スクリーンショットテストを行います。今回は、連続でコマンドを実行しているので成功します。
./gradlew screenshotTest ------------------------------------------------------------ Run the Testify screenshot tests ------------------------------------------------------------ com.</description>
    </item>
    
    <item>
      <title>Android: Dagger Hiltで推移的な依存を解決する</title>
      <link>https://satoshun.github.io/2021/05/dagger-traversing-dependency-chain/</link>
      <pubDate>Tue, 25 May 2021 12:39:26 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/05/dagger-traversing-dependency-chain/</guid>
      <description>従来のDaggerだと、app(root)モジュールは、すべてのクラスパスが見えている必要がありました。
例えば、
|appモジュール| -&amp;gt; |dataモジュール| -&amp;gt; &amp;lt;retrofitライブラリ&amp;gt;
のような関係だと、appモジュールでもretrofitライブラリが見えている必要があります。 なので、appモジュールに implementation retrofit を記述するか、もしくは、dataモジュールに api retrofit を記述する必要があります。
Dagger Hiltの2.31以降に、この問題を解決する Classpath Aggregation が追加されたので、それを紹介します。
Classpath Aggregation Classpath Aggregationを有効にするには、次の設定をGradleに記述します。
hilt { enableExperimentalClasspathAggregation = true } これを追加することで、implementation から api にしなくても、コンパイルを成功させることが出来ます。
便利なフラグですが、最新のv2.35だと、パフォーマンスに影響が出るので、規模が大きいプロジェクトの場合には注意して導入する必要があります。 今後、改善予定だそうです。
参照  https://dagger.dev/hilt/gradle-setup#classpath-aggregation  </description>
    </item>
    
    <item>
      <title>JetBrains Toolbox Appのススメ</title>
      <link>https://satoshun.github.io/2021/05/jetbrains-toolbox/</link>
      <pubDate>Sun, 23 May 2021 03:00:22 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/05/jetbrains-toolbox/</guid>
      <description>JeBbrains Toolbox App が便利なので、それの啓蒙ブログです。
JetBrains Toolbox App? JetBrains製のIDEのバージョンを管理するアプリになります。Android開発の場合だと、stable版、beta版、canary版を別々に管理することが主な使い方になります。
これで説明は終わりなのですが、設定しておくと便利な機能を紹介します。
シェルコマンドの生成 ONにしておくと、シェルコマンドを生成をしてくれます。
 次のようにコマンドラインから、プロジェクトを開くことが出来ます。
studio . git clone をした後などに、上記コマンドを入力することで、プロジェクトを簡単に開くことが出来ます。
インストール先のフォルダを /Applications にする 下記のツイートにあったのですが、spotlightによるインデックスがいい感じになるそうです。
https://twitter.com/kaushikgopal/status/1396210659847819264
まとめ JetPack Composeやらなんやらで、beta、canaryなどの開発版を使うことも多くなると思うので、入れとくと幸せになります。</description>
    </item>
    
    <item>
      <title>Android: BuildConfigの生成をoffにする</title>
      <link>https://satoshun.github.io/2021/04/android-buildconfig/</link>
      <pubDate>Sat, 10 Apr 2021 01:13:45 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/04/android-buildconfig/</guid>
      <description>buildFeaturesから、BuildConfigクラスの生成をするかどうかを設定できるようになりました。
gradle.propertiesから設定できます。
android.defaults.buildfeatures.buildconfig=false # defaultはtrue マルチモジュール構成のプロジェクトでは、基本的にはBuildConfigを生成しないと思うので、BuildConfigの生成のデフォルト設定をoffにしておくと良いと思います。
モジュール単位で、生成をonにするには、build.gradleに次の記述をします。
android {  buildFeatures {  buildConfig true  } } buildFeaturesブロックから設定を与えることが出来ます。
まとめ マルチモジュール構成のプロジェクトの場合は、coreモジュールやappモジュールのみonにして、他をoffにするのが良さそう</description>
    </item>
    
    <item>
      <title>Gradle: 新しいバージョン管理方法 Central declaration of dependenciesの紹介</title>
      <link>https://satoshun.github.io/2021/03/gradle-central-declaration-of-dependencies/</link>
      <pubDate>Sun, 28 Mar 2021 06:48:44 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/03/gradle-central-declaration-of-dependencies/</guid>
      <description>Gradleの7.0-RC01に、Central declaration of dependenciesという機能が入りました。まだ、experimentalな機能で今後どうなるか分かりませんが、気になったので紹介します。
この記事を書くのに使ったサンプルコードは github/satoshun-android-example にあります。
Central declaration of dependenciesが導入された背景 Gradle 7.0 Release Notes に次のように書いてあります。
There are a number of ways to share dependency versions between projects in multi-project builds. For example, users can declare versions or dependency coordinates directly in build scripts (in the ext block), external files (e.g dependencies.gradle), in buildSrcor even dedicated plugins. There wasn’t, however, any standard mechanism to do this which would combine the advantages of each approach.</description>
    </item>
    
    <item>
      <title>Paparazziを使って、実機を使わずにスナップショットを取る</title>
      <link>https://satoshun.github.io/2021/02/paparazzi-snapshot-testing/</link>
      <pubDate>Sun, 28 Feb 2021 07:53:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2021/02/paparazzi-snapshot-testing/</guid>
      <description>今回は、Paparazzi の使い方について紹介します。
また、今回の記事のサンプルコードは github/satoshun/paparazzi にあります。
Paparazzi? square社がメンテしているライブラリです。これを使うことで、実機を使わずにスナップショットを取ることが出来ます。
https://github.com/cashapp/paparazzi
使い方 トップのbuild.gradleにGradleプラグインをセットします。
buildscript {  repositories {  mavenCentral()  google()  }  dependencies {  classpath &amp;#39;app.cash.paparazzi:paparazzi-gradle-plugin:0.7.0&amp;#39;  } } ライブラリのbuild.gradleにプラグインを適用します。
apply plugin: &amp;#39;app.cash.paparazzi&amp;#39; これで準備は完了です。
次に、サンプルのレイアウトファイルとして、lib_item.xml を準備したので、これをPaparazziを使ってスナップショットを取る例を紹介します。
class LayoutTest {  @get:Rule  var paparazzi = Paparazzi(deviceConfig = DeviceConfig.NEXUS_5)   @Test  fun sample() {  val launch = paparazzi.inflate&amp;lt;LinearLayout&amp;gt;(R.layout.lib_item)  paparazzi.snapshot(view = launch)  } } Paparazziには、Junit4 Ruleが定義されています。引数には、デバイス情報を指定します。今回は、Nexus5を指定しました。</description>
    </item>
    
    <item>
      <title>Android: 公式でAssisted Injectがサポートされそう</title>
      <link>https://satoshun.github.io/2020/12/dagger-official-assisted/</link>
      <pubDate>Wed, 30 Dec 2020 08:53:33 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/12/dagger-official-assisted/</guid>
      <description>Assisted Injectのコードが公式のDaggerに入ったそうです。
https://twitter.com/JakeWharton/status/1344055984575160321
まだリリースされていないんですが、軽く試してみました。
サンプルコード 初期値を受け取りたい Counterクラスがあるとして、それをAssistedを使って定義してみます。
class Counter @AssistedInject constructor(  @Assisted private val initialValue: Int ) {  val count = MutableStateFlow(initialValue) }  @AssistedFactory interface CounterFactory {  fun create(initialValue: Int): Counter } これで定義は完了です。FactoryクラスをAssistedFactoryアノテーションで、本体をAssistedInjectとAssistedアノテーションを使って定義します。 square/AssistedInject とは違い AssistedModule が必要なくなりました。
そして次のように使います。
@Inject lateinit var factory: CounterFactory  val counter = factory.create(100) ... 定義した CounterFactoryをinjectして、 Counterインスタンスを生成しています。こちらはいつものDaggerの記法になります。
まとめ ついに公式にAssisted Injectionが入ります:D
サンプルコードは satoshun/daggersampleにあります。</description>
    </item>
    
    <item>
      <title>マルチモジュール環境での、dummyモジュール導入によるビルドの高速化</title>
      <link>https://satoshun.github.io/2020/12/multimodule_dummy_module/</link>
      <pubDate>Sat, 12 Dec 2020 04:18:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/12/multimodule_dummy_module/</guid>
      <description>最初にまとめ 各モジュール間の結合度(publicなクラス、インターフェース)を低く保ち、settings.gradleを工夫することで、最小限のコードでdummyモジュールを導入できる。dummyモジュールのコード量は限りなく少ないので、ビルド時間の短縮につながる。
サンプルは https://github.com/satoshun-android-example/GradleDummyProject にあります。少し本記事とモジュール名などが異なります。
本題 プロジェクトの規模が大きくなると、ビルド時間は増加する傾向にあります。マルチモジュールによるアプローチは、差分ビルドを効率良く動作させることが出来ます。本記事では、マルチモジュールプロジェクトに、dummyモジュールを差し込むことでビルド時間の改善をする方法を紹介します。
また、この記事では触れませんが、機能（画面）ごとにappモジュールを作るアプローチも良いと思います。
dummyモジュールとは 例えば、注文を行うorderモジュールがあるとします。今回の開発では、その注文画面は使う必要がないとします。使う必要がないので、orderモジュールは一時的に削除しても良いことになります。しかし、単純にモジュールを削除してしまうと、何かしらの参照エラーになってしまうので、order-dummyモジュールを作り、参照エラーになるクラスを実装します。具体的には、orderモジュールで定義されているpublicなクラス、インターフェースです。
今回、orderモジュールには唯一Orderクラスのみがpublicとして定義されているとすると、次のように書きます。
class Order {  fun canOrder(): Boolean { ... }  fun order() { ... } } class Order {  fun canOrder(): Boolean { TODO(&amp;#34;dummy&amp;#34;) }  fun order() { TODO(&amp;#34;dummy&amp;#34;) } } 必要に応じて、orderモジュール、order-dummyモジュールを切り替えることでビルド時間を短縮することが出来ます。
どのようにモジュールを切り替えるか? settings.gradleとGradleプロパティを用います。
まず、settings.gradleは次のようになります。
if (properties[&amp;#34;dummyorder&amp;#34;]) {  include &amp;#34;order&amp;#34;  project(&amp;#39;:order&amp;#39;).projectDir = file(&amp;#39;dummyorder&amp;#39;) } else {  include &amp;#39;:order&amp;#39; } dummyorderプロパティに、何かしらの値がセットされていたら、dummyorderモジュールを使う設定になります。
dummyorderプロパティの設定はコマンドラインからは -P、Android StudioからはCommand-Line Optionsから指定します。</description>
    </item>
    
    <item>
      <title>Android: 既存のDagger AndroidからHiltへの移行について</title>
      <link>https://satoshun.github.io/2020/10/dagger-android-migrate-to-hilt/</link>
      <pubDate>Sat, 24 Oct 2020 13:19:26 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/10/dagger-android-migrate-to-hilt/</guid>
      <description>dagger hiltもalphaになって久しいので、既存のプロジェクトを徐々に置き換える方法を簡単なサンプルと共に説明します。
より詳細な説明は公式のドキュメント https://dagger.dev/hilt/migration-guide を見ると良きです。
既存の構成 既存ではdagger androidが使われていて、MainActivityとSubActivityがそれぞれ定義されているとします。そのうち、MainActivityをhiltに移行したいと思います。
class App : DaggerApplication() {  override fun androidInjector(): AndroidInjector&amp;lt;App&amp;gt; {  return ...  } }  @Singleton @Component(  modules = [  AndroidInjectionModule::class,  MyActivityModule::class  ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt;  @Module(  includes = [	... ] ) interface MyActivityModule {   // 今回移行したいdaggerの定義  @ContributesAndroidInjector(modules = [MainFragmentModule::class])  fun contributeMainActivity(): MainActivity   @ContributesAndroidInjector(modules = .</description>
    </item>
    
    <item>
      <title>Android: RIP AsyncTask</title>
      <link>https://satoshun.github.io/2020/07/android-asynctask-deprecated/</link>
      <pubDate>Wed, 22 Jul 2020 02:58:19 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/07/android-asynctask-deprecated/</guid>
      <description>javadocコメントとコミットログは次のようになっています。
 AsyncTask was intended to enable proper and easy use of the UI thread. However, the most common use case was for integrating into UI, and that would cause Context leaks, missed callbacks, or crashes on configuration changes. It also has inconsistent behavior on different versions of the platform, swallows exceptions from {@code doInBackground}, and does not provide much utility over using {@link Executor}s directly.
 https://android-review.googlesource.com/c/platform/frameworks/base/+/1156409
AsyncTaskの目的は、UIスレッドを簡単に扱うためのものだけど、Contextのリークや、configuration changeなどでクラッシュしてしまうのでそもそも目的を達成していない。また、Androidのバージョンごとに振る舞いに一貫性がないのも問題だと。ただでさえ、非同期プログラミングは難しいのに、バージョンごとに振る舞いが異なっていたらしんどさ倍増って話だと言う話です。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: IOSchedをJetpack Composeで書く part1</title>
      <link>https://satoshun.github.io/2020/07/compose-iosched-scaffold/</link>
      <pubDate>Sun, 12 Jul 2020 05:14:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/07/compose-iosched-scaffold/</guid>
      <description>この記事では、Jetpack Composeを学ぶために、公式の IoSched のUIをJetpack Composeに書き換えていく記事になります。 完全に見た目を同一にするという所まではやらずに、大体一緒の見た目で妥協するのでご了承下さい。
Part1では、ホーム画面のAppbarを作るところまでをやります。
また、この記事のコードのライセンスはGoogle I/Oアプリと同等です。
Copyright 2014 Google Inc. All rights reserved. Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>Jetpack Compose: PreviewParameterアノテーションを使っていろいろなプレビューを作る</title>
      <link>https://satoshun.github.io/2020/07/compose-preview/</link>
      <pubDate>Wed, 08 Jul 2020 11:36:04 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/07/compose-preview/</guid>
      <description>この記事では、PreviewParameterアノテーションを使って複数のプレビューを出す方法について説明します。
Previewアノテーションについて Jetpack Composeでは、@Previewを使うことでプレビューを表示することが出来ます。
例えば、TestScreenのプレビューは次のように定義することが出来ます。
@Composable fun TestScreen(  user: User,  count: Int ) {  ... }  @Preview(&amp;#34;test screen&amp;#34;) @Composable fun PreviewTestScreen() {  TestScreen(user = User(id = &amp;#34;1&amp;#34;, name = &amp;#34;tom&amp;#34;), count = 10) } ここで、いろいろなUserインスタンスでプレビューを表示したいとします。愚直にやるなら、@Previewを複数定義することですが、@PreviewParameterを使うことでよりスマートに書くことが出来ます。
具体的には、次のように書くことが出来ます。
class PreviewUserProvider : PreviewParameterProvider&amp;lt;User&amp;gt; {  override val values: Sequence&amp;lt;User&amp;gt;  get() = sequenceOf(  User(id = &amp;#34;1&amp;#34;, name = &amp;#34;tom&amp;#34;),  User(id = &amp;#34;2&amp;#34;, name = &amp;#34;スズキ&amp;#34;)  ) }  @Preview(&amp;#34;test screen parameter&amp;#34;) @Composable fun PreviewParameterTestScreen(  @PreviewParameter(PreviewUserProvider::class) user: User ) {  TestScreen(user = user, count = 10) } 最初に、PreviewParameterProviderインターフェースを実装します。PreviewParameterProviderでは、プレビューしたいインスタンス（パラメータ）を定義してあげます。 実装したクラスを @PreviewParameter(PreviewUserProvider::class) と指定することで、プレビューを複数出すことが出来ます。</description>
    </item>
    
    <item>
      <title>Android: Dagger HiltとDagger Androidの生成コードの違いについて</title>
      <link>https://satoshun.github.io/2020/06/dagger-hilt-generated-code/</link>
      <pubDate>Sun, 21 Jun 2020 07:43:11 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/06/dagger-hilt-generated-code/</guid>
      <description>結論  Dagger Hiltは1つのSubcomponentが作られる Dagger AndroidはActivityごとに専用のSubcomponentが作られる  （ドキュメントに書いてる通りです）
生成コードの違いについて Dagger Hiltが爆誕したので、Dagger Androidと比較したときに、生成コードにはどのような違いがあるかを検証してみました。今回は、Activityのみに焦点を当てています。
Daggerのバージョンは2.28、Hiltのバージョンは2.28-alphaで検証しました。
Dagger Androidの生成コード Dagger Androidでは、@ContributesAndroidInjectorを使うことで、ActivityのSubcomponentを自動生成してくれます。
例えば、MainActivityを指定すると、次のようなコードが生成されます。
@Module(subcomponents = MainActivityModule_ContributeMainActivity.MainActivitySubcomponent.class) public abstract class MainActivityModule_ContributeMainActivity {  private MainActivityModule_ContributeMainActivity() {}   ...   @Subcomponent  public interface MainActivitySubcomponent extends AndroidInjector&amp;lt;MainActivity&amp;gt; {  @Subcomponent.Factory  interface Factory extends AndroidInjector.Factory&amp;lt;MainActivity&amp;gt; {}  } } このSubcomponentは、MainActivity専用に作られていることが分かります。MainActivity専用に作っているので、このSubcomponent配下では、MainActivityを直接injectすることが可能です。
class MainCounter @Inject constructor(private val mainActivity: MainActivity) {...} このMainCounterを他のActivityに対してinjectしようとすると、エラーが出ます。これが、専用のSubcomponentをActivity毎に独立で作るメリットです。
次に、Dagger Hiltを見てみます。
Dagger Hiltの生成コード Dagger Hiltでは、@AndroidEntryPointを使うことで、ActivityのSubcomponentを自動生成してくれます。</description>
    </item>
    
    <item>
      <title>Android: エミュレータでFreeformモードを使う</title>
      <link>https://satoshun.github.io/2020/06/android-emulator-freeform/</link>
      <pubDate>Sat, 13 Jun 2020 08:38:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/06/android-emulator-freeform/</guid>
      <description>おそらく 30.0.10 から、Freeformモードなるものがエミュレータで実行できるようになっていたので、それの紹介です。
この記事では、Android Studio 4.2 Preview1を使っています。
使い方 セットアップは簡単で、AVD Manager -&amp;gt; Create Virtual Device から、 13.5&amp;quot; Freeform を指定します。
 動作例 Clockアプリで試してみました。次のgifアニメーション画像のように動作をします。
 アプリを立ち上げた後に、簡単に画面サイズを変更することが出来ます。
まとめ 複数の端末サイズで確認したい時などに、便利なのかなと思いました（こなみかん）</description>
    </item>
    
    <item>
      <title>Android: ActivityResultContractを使ってRuntime Permissionsを実装する</title>
      <link>https://satoshun.github.io/2020/06/jetpack-activity-permission-contract/</link>
      <pubDate>Thu, 11 Jun 2020 10:47:24 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/06/jetpack-activity-permission-contract/</guid>
      <description>Activity 1.2.0-alpha02から導入された、ActivityResultContractを使うことで、Runtime Permissionsをいい感じに実装することが可能になりました。
この記事では、どのように実装すれば良いかを簡単に説明します。
単一のPermissonを要求する 新しく追加された registerForActivityResult 拡張関数に、ActivityResultContracts.RequestPermission()を指定することで、単一のPermissionを要求することが出来ます。
例えば、android.permission.ACCESS_FINE_LOCATIONが欲しい時は、次のように書くことが出来ます。
class HogeActivity : AppCompatActivity() {   // 定義側  private val requestLocation = registerForActivityResult(  ActivityResultContracts.RequestPermission(),  ACCESS_FINE_LOCATION  ) { isGranted -&amp;gt;  // Permissionの取得に成功したかどうか、Boolean値で返ってくる  Toast.makeText(this@AppActivity, &amp;#34;isGranted $isGranted&amp;#34;, Toast.LENGTH_LONG).show()  }   private fun hoge() {  // 呼び出し側  requestLocation.launch(Unit)  } } 複数のPermissonを要求する 複数の場合は、ActivityResultContracts.RequestMultiplePermissions()を指定します。
例えば、android.permission.ACCESS_FINE_LOCATION、android.permission.READ_EXTERNAL_STORAGEが欲しい時は、次のように書くことが出来ます。
class HogeActivity : AppCompatActivity(R.layout.app_act) {  // 定義側  private val requestPermissions = registerForActivityResult(  ActivityResultContracts.</description>
    </item>
    
    <item>
      <title>avocadoとGitHub Actionsを使って、Vector Drawableを最適化する</title>
      <link>https://satoshun.github.io/2020/05/android-avocado-with-github-actions/</link>
      <pubDate>Wed, 27 May 2020 03:52:50 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/05/android-avocado-with-github-actions/</guid>
      <description>Vector Drawableを最適化する avocadoと、GitHub Actions組み合わせた話です。
🥑avocado🥑? avocadoを使うことで、Vector Drawableを最適化することができます。使い方は簡単です。
avocado [file name] Vector Drawableによっては、結構最適化されます。
GitHub Actionsに組み込む 1週間単位でavocadoを実行して、PRを作るGitHub Actionsになります。
name: avocado  on:  schedule:  - cron: &amp;#39;0 0 * * 0&amp;#39;  jobs:  build:  runs-on: ubuntu-latest   steps:  - name: Checkout  uses: actions/checkout@v2   - name: Setup node  uses: actions/setup-node@v1  with:  node-version: &amp;#39;12&amp;#39;   - name: Setup avocado  run: npm install -g avocado   - name: Run avocado  run: find .</description>
    </item>
    
    <item>
      <title>Android: ConstraintLayoutの子にRecyclerViewを配置して、Match Constraintsを設定すると良くない挙動をする</title>
      <link>https://satoshun.github.io/2020/05/recyclerview-with-match-constraints/</link>
      <pubDate>Fri, 15 May 2020 13:25:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/05/recyclerview-with-match-constraints/</guid>
      <description>備忘録です。
次のようなレイアウトは良くないぞという話です。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;wrap_content&amp;#34;&amp;gt;   &amp;lt;androidx.recyclerview.widget.RecyclerView  android:id=&amp;#34;@+id/recycler&amp;#34;  android:layout_width=&amp;#34;0dp&amp;#34;  android:layout_height=&amp;#34;wrap_content&amp;#34;  app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 今回の例では、LinearLayoutManagerをLayoutManagerとして使っています。他のLayoutManagerの場合、どういう挙動をするか分かりません。 また、ConstraintLayout 2.0.0-beta06、RecyclerView 1.1.0で試しています。
どんな挙動をするか? このレイアウトはファーストビューのタイミングで、すべてのアイテムをバインドしようとします。
例えば500個のRecyclerViewアイテムがあったときに、画面に収まるかどうかに関わらず500個のバインドが走ります。
with(recycler) {  // 横方向のLinearLayoutManager  layoutManager = LinearLayoutManager(  this@ConstraintMatchConstraintsActivity,  RecyclerView.HORIZONTAL,  false  )   // 500個のアイテムを生成  adapter = SampleAdapter().apply {  submitList((0..500).map { &amp;#34;$index$it&amp;#34; })  } }  private class SampleAdapter : ListAdapter&amp;lt;String, RecyclerView.</description>
    </item>
    
    <item>
      <title>GitHub Actions: AndroidプロジェクトのGradle周りの設定メモ</title>
      <link>https://satoshun.github.io/2020/05/github-actions-android/</link>
      <pubDate>Tue, 05 May 2020 06:11:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/05/github-actions-android/</guid>
      <description>GitHub Actionのスペック
 7Gメモリの2 CPU  こんな感じが良さそう org.gradle.daemon=false org.gradle.parallel=true org.gradle.jvmargs=-Xmx5120m org.gradle.workers.max=2  kotlin.incremental=false kotlin.compiler.execution.strategy=in-process  kapt.use.worker.api=false kapt.incremental.apt=false  android.databinding.incremental=false android.lifecycleProcessor.incremental=false  CatchUpアプリを参考にして、上の設定をCI実行時に ~/gradle/gradle.properites に配置するようにした  プロジェクト直下の gradle.properties より優先度が高いのでそうした   kaptの設定はいらないかもしれない  worker使わないほうが安定するんじゃないかなーと思って、falseにしてみた   incremental系は、全部offで良いと思っている  考慮したほうが良さそうなプロパティ  org.gradle.jvmarg  Xmx -XX:MaxPermSize -XX:+HeapDumpOnOutOfMemoryError   org.gradle.daemon org.gradle.parallel org.gradle.workers.max org.gradle.caching org.gradle.configureondemand kotlin.incremental kotlin.compiler.execution.strategy kotlin.parallel.tasks.in.project kapt.use.worker.api kapt.incremental.apt プロジェクト固有のやつ  android.databinding.incremental android.lifecycleProcessor.incremental=false firebasePerformanceInstrumentationEnabled    参考プロジェクト insetterライブラリ https://github.com/chrisbanes/insetter/tree/master/.github
JAVA_TOOL_OPTIONS: -Xmx5120m GRADLE_OPTS: -Dorg.</description>
    </item>
    
    <item>
      <title>ちょっと複雑なレイアウトをConstraintLayoutで組んでみるpart2</title>
      <link>https://satoshun.github.io/2020/04/constraintlayout-practical2/</link>
      <pubDate>Thu, 30 Apr 2020 04:38:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/04/constraintlayout-practical2/</guid>
      <description>今回の記事では次の4つのレイアウトを、ConstraintLayoutで組みたいと思います。
 ポイントは以下の２つです。
 各画像は、前の画像に被っている 各レイアウトは、4 or 3 or 2 or 1枚、いずれかの枚数を取る  上記で上げたポイントを中心に説明していきます。
各画像は、前の画像に被っている View同士を被せる方法はいくつかあると思うんですが、今回はlayout_constraintStart_toStartOfとlayout_marginStartを使い表現します。
まずに、1番左に配置するImageViewを定義します。
&amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/image1&amp;#34;  android:layout_width=&amp;#34;32dp&amp;#34;  android:layout_height=&amp;#34;32dp&amp;#34;  android:layout_marginStart=&amp;#34;20dp&amp;#34;  android:layout_marginBottom=&amp;#34;12dp&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; /&amp;gt; 1番左に配置したいので、Start_toStartOfにはparentを設定しています。
次に、2番目に配置するImageViewを考えます。このImageViewは、1枚目のImageViewに被るように配置します。なので、この1枚目のViewのend(終端)に制約を合わせてしまうと上手く配置できません。 よって、1枚目のViewのstart(先端)に制約を合わせます。合わせてmarginStartも設定することで良い感じの配置が出来ます。
&amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/image2&amp;#34;  android:layout_width=&amp;#34;32dp&amp;#34;  android:layout_height=&amp;#34;32dp&amp;#34;  android:layout_marginStart=&amp;#34;24dp&amp;#34;  android:layout_marginBottom=&amp;#34;12dp&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;@id/image1&amp;#34; /&amp;gt; 3番目、4番目のViewにも同様の制約を設定してあげます。最終形は次のようになります。
&amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/image1&amp;#34;  android:layout_width=&amp;#34;32dp&amp;#34;  android:layout_height=&amp;#34;32dp&amp;#34;  android:layout_marginStart=&amp;#34;20dp&amp;#34;  android:layout_marginBottom=&amp;#34;12dp&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; /&amp;gt;  &amp;lt;com.</description>
    </item>
    
    <item>
      <title>ちょっと複雑なレイアウトをConstraintLayoutで組んでみるpart1</title>
      <link>https://satoshun.github.io/2020/04/constraintlayout-practical1/</link>
      <pubDate>Tue, 07 Apr 2020 00:41:08 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/04/constraintlayout-practical1/</guid>
      <description>今回の記事では次のレイアウトを、ConstraintLayoutで組みたいと思います。
   ポイントは以下の3つです。
 4つの画像を組み合わせて、1つの円形画像を作る部分 01/01の部分は右に、@your_idの部分はYour Nameの右に配置される Your Nameの部分の文字数が多いときに、&amp;hellip;で省略される  今回は、4つの画像を組み合わせる部分で、Material ComponentのShapeableImageViewを使っています。ShapeableImageViewの説明はここを見てください。
上記で上げたポイントを中心に説明していきます。
4つの画像を組み合わせて、1つの円形画像を作る部分 この部分は、Picasso、Glideなどの画像ライブラリに頼るパターンもあると思うんですが、今回はShapeableImageViewを使いたいと思います。
4つのShapeableImageViewを使い、それぞれ「左上、右上、左下、右下」の部分が丸くなるShapeを定義します。 左上を丸くするShapeは次のように定義できます。
&amp;lt;style name=&amp;#34;ShapeAppearanceOverlay.Example.TopLeft&amp;#34; parent=&amp;#34;&amp;#34;&amp;gt;  &amp;lt;item name=&amp;#34;cornerFamilyTopLeft&amp;#34;&amp;gt;rounded&amp;lt;/item&amp;gt;  &amp;lt;item name=&amp;#34;cornerSizeTopLeft&amp;#34;&amp;gt;100%&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt; 右の画像が、上のShapeを指定した場合になります。
 右上、左下、右下のShapeも同じように作ってあげます。そして、それら4つViewの制約を次のように作ってあげます。
&amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/top_left&amp;#34;  android:layout_width=&amp;#34;30dp&amp;#34;  android:layout_height=&amp;#34;30dp&amp;#34;  android:adjustViewBounds=&amp;#34;true&amp;#34;  android:scaleType=&amp;#34;centerCrop&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;  app:shapeAppearanceOverlay=&amp;#34;@style/ShapeAppearanceOverlay.Example.TopLeft&amp;#34;  tools:src=&amp;#34;@tools:sample/avatars&amp;#34; /&amp;gt;  &amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/top_right&amp;#34;  android:layout_width=&amp;#34;30dp&amp;#34;  android:layout_height=&amp;#34;30dp&amp;#34;  android:adjustViewBounds=&amp;#34;true&amp;#34;  android:scaleType=&amp;#34;centerCrop&amp;#34;  app:layout_constraintStart_toEndOf=&amp;#34;@id/top_left&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;@id/top_left&amp;#34;  app:shapeAppearanceOverlay=&amp;#34;@style/ShapeAppearanceOverlay.Example.TopRight&amp;#34;  tools:src=&amp;#34;@tools:sample/avatars&amp;#34; /&amp;gt;  &amp;lt;com.</description>
    </item>
    
    <item>
      <title>Dagger2: Dagger2.27の新しいエラーメッセージを少し試してみる</title>
      <link>https://satoshun.github.io/2020/03/dagger-improve-error-message/</link>
      <pubDate>Tue, 17 Mar 2020 09:33:04 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/03/dagger-improve-error-message/</guid>
      <description>Dagger 2.27でエラーメッセージの改善が入っていたので、軽く試してみました。試してみた系の記事になります。
まず有効にする この機能はexperimentalなので、明示的に有効にする必要があります。kaptを使っているなら、次のように有効にします。
allprojects {  afterEvaluate {  extensions.findByName(&amp;#34;kapt&amp;#34;)?.arguments {  arg(&amp;#34;dagger.experimentalDaggerErrorMessages&amp;#34;, &amp;#34;enabled&amp;#34;)  }  } } 適当にエラーを出してみる まずは、Providesの指定を外してみます。
// @Provides &amp;lt;-- エラーを出したいのでコメントアウト fun provideTestObject(): TestObject = TestObject()  @Inject lateinit var testObject: TestObject すると、次のようになります。
新しいエラーログ  
古いエラーログ  
 次に、複数Providesの指定をしてみます。
@Provides fun provideTestObject(): TestObject = TestObject()  @Provides fun provideTestObject2(): TestObject = TestObject()  @Inject lateinit var testObject: TestObject すると、次のようになります。
新しいエラーログ  
古いエラーログ</description>
    </item>
    
    <item>
      <title>Jetpack Compose: Ambientを使ってインスタンスを注入、取得する</title>
      <link>https://satoshun.github.io/2020/03/compose-ambient/</link>
      <pubDate>Thu, 05 Mar 2020 10:38:47 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/03/compose-ambient/</guid>
      <description>こんにちわっふる🍰
今回は、ComposeにあるAmbientを説明したいと思います。この記事はdev06で検証しています。
前提・課題 一般的に、Composableなコンポーネントにデータを渡すとき、関数の引数から渡します。
@Composable fun MyView(someData: Data) {  ... } これがシンプル かつ 分かりやすい方法です。 しかし、中間に多くのComposableなコンポーネントがある場合、全てのコンポーネントの引数でデータを受け取り、さらに渡す必要があります。これは少々面倒で冗長です。
ここで、Ambientを使うとすっきりと書くことが出来ます。
Ambientを使う まず、最初にAmbientの定義をします。Ambientの定義はambientOfメソッドから行えます。
今回は例として、ExampleViewModelをAmbientで定義して、コンポーネントから使用します。
まず、定義を行います。
val exampleViewModelAmbient = ambientOf&amp;lt;ExampleViewModel&amp;gt;() これで定義は完了です。ambientOfメソッドを呼び出すだけです。
次に、これをコンポーネントから使ってみます。
val exampleViewModelAmbient = ambientOf&amp;lt;ExampleViewModel&amp;gt;()  @Composable fun ExampleApp() {  val viewModel = ExampleViewModel()   Providers(exampleViewModelAmbient provides viewModel) {  MyView()  } }  @Composable private fun MyView() {  val viewModel = exampleViewModelAmbient.current  ... } これで完了です。コードを説明してきます。
 Providers(exampleViewModelAmbient provides viewModel)</description>
    </item>
    
    <item>
      <title>Jetpack Compose: Modelとstate</title>
      <link>https://satoshun.github.io/2020/02/compose-model-state/</link>
      <pubDate>Sat, 29 Feb 2020 23:32:01 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/compose-model-state/</guid>
      <description>Jetpack Composeのデータ監視方法について紹介します。
state まず、stateメソッドの紹介をします。
stateメソッドを使うと値を監視することができ、値が変更されたときに自動で再構成（recomposition）してくれます。
次のように、Viewの状態を表すのに便利に使えます。
@Composable fun MyCheckbox() {  // 初期値false  var checked by state { false }   Checkbox(  checked = checked,  onCheckedChange = {  // stateで定義した値を更新すると、自動でUIの再構成（recomposition)が走る  checked = it  }  ) } state { 初期値 }って感じで定義して、その値を更新するとUIの再構成をしてくれます。
この例の場合、Checkboxがクリックされると、checkedの状態が変わり、Viewが再構成されます。
Model 次にModelです。Modelはアノテーションで定義されています。 Modelアノテーションをつけたクラスのプロパティが監視対象になり、プロパティが更新されたときに自動で再構成してくれます。
例えば、クリックされたカウントを保持するModelは次のように作ります。
@Model class Count(  var count: Int = 0 )  @Composable fun MyText() {  // Modelの定義。引数から渡すこともある  val count = Count()   Ripple(bounded = false) {  Clickable(onClick = {  // Modelの値を更新すると、自動で再構成（recomposition)が走る  count.</description>
    </item>
    
    <item>
      <title>Android: findViewTreeLifecycleOwnerでViewからLifecycleOwnerを取得する</title>
      <link>https://satoshun.github.io/2020/02/jetpack-find-view-tree-lifecycle-owner/</link>
      <pubDate>Sun, 23 Feb 2020 01:50:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/jetpack-find-view-tree-lifecycle-owner/</guid>
      <description>lifecycle-2.3.0に、ViewからLifecycleOwnerを取得するメソッドが追加されそうなので、それのメモ。
まだ2.3.0-alphaはリリースされていないので、androidxのSNAPSHOTで試します。 SNAPSHOTの使い方は、Using AndroidX Snapshot Buildsを参考にしました。
使い方 関数の定義と使い方になります。
// 関数の定義 fun View.findViewTreeLifecycleOwner(): LifecycleOwner?   // 使い方 val owner = view.findViewTreeLifecycleOwner() // 使い方 + Coroutine view.findViewTreeLifecycleOwner()?.lifecycleScope?.launch {  ... } Viewに拡張関数が定義されており、そこから使うことが出来ます。
Fragmentで生成したViewからfindViewTreeLifecycleOwnerをした場合には、 Fragmentのライフサイクルが取得出来るので、適切なライフサイクルを使うことが出来ます。
内部実装 シンプルな作りになっており、ViewのタグにActivityやFragmentのLifecycleOwnerを登録しています。
public class ViewTreeLifecycleOwner {  public static void set(@NonNull View view, @Nullable LifecycleOwner lifecycleOwner) {  view.setTag(R.id.view_tree_lifecycle_owner, lifecycleOwner);  }   @Nullable  public static LifecycleOwner get(@NonNull View view) {  LifecycleOwner found = (LifecycleOwner) view.</description>
    </item>
    
    <item>
      <title>Gradle: BOMを使って依存を指定する</title>
      <link>https://satoshun.github.io/2020/02/gradle-bom-android/</link>
      <pubDate>Tue, 18 Feb 2020 13:08:10 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/gradle-bom-android/</guid>
      <description>Gradleの5から、Bill Of Materials(BOM)が使えるようになりました。これが、結構いいものだと思ったので紹介します。
ついでにdependabotの話もちょっとします。
BOM? BOMを使うことで、 複数のライブラリのバージョンを省略することが出来ます。
ドキュメントの例にはspring-bootが挙げられています。
dependencies {  // import a BOM  implementation platform(&amp;#39;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&amp;#39;)   // define dependencies without versions  implementation &amp;#39;com.google.code.gson:gson&amp;#39;  implementation &amp;#39;dom4j:dom4j&amp;#39; } gson、dom4jのバージョンを省略していることが分かると思います。
Androidでよく使うライブラリでBOMに対応しているライブラリには、例えば次があります。
 OkHttp Kotlin Coroutine Firebase  例えば、OkHttpならこんな感じで書けます。
dependencies {  implementation platform(&amp;#34;com.squareup.okhttp3:okhttp-bom:4.4.0&amp;#34;)  implementation &amp;#34;com.squareup.okhttp3:okhttp&amp;#34;  implementation &amp;#34;com.squareup.okhttp3:logging-interceptor&amp;#34; } BOMを使うことで、関連ライブラリをまとめてアップデートすることが出来るのでとても便利です。
dependabot? 直接はBOMに関係ないんですけど、最近、dependabotが便利だと自分の中で話題になっていて、これはライブラリのアップデートを自動でやってくれるbotになります。
例えば、こんな感じのPRを作ってくれます。
Bump versions.retrofit from 2.7.0 to 2.7.1
   それでdependabotって、versions.retrofit = &#39;2.7.1&#39;って感じで、変数で定義すると検知できないって思っていたんですけど、 いろいろ試してみたら、普通に出来ました:D</description>
    </item>
    
    <item>
      <title>doOnNextLayout、doOnLayout、doOnPreDrawの違いと、Coroutineでこれらを動かしてみる</title>
      <link>https://satoshun.github.io/2020/02/android-doonxxx/</link>
      <pubDate>Tue, 11 Feb 2020 14:02:02 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/android-doonxxx/</guid>
      <description>タイトルにあるメソッドはJetpack core-ktxに定義されています。
 doOnNextLayout doOnLayout doOnPreDraw  これらを雰囲気で使っていたので、軽く調べてみました。
doOnNextLayout これは、指定したViewがレイアウトされたときに実行されます。 なので、measure、layoutの後にコールバックされます。
注意としては、「既にレイアウト済み かつ 再レイアウトが行われない時」はコールバックされません。
doOnLayout doOnNextLayoutと似ているのですが、異なる点は、「レイアウト済み かつ 再レイアウトの要求がない」場合には、即時実行されます。
inline fun View.doOnLayout(crossinline action: (view: View) -&amp;gt; Unit) {  if (ViewCompat.isLaidOut(this) &amp;amp;&amp;amp; !isLayoutRequested) {  action(this)  } else {  doOnNextLayout {  action(it)  }  } } doOnPreDraw 描画される前に実行されます。よって、このタイミングではmeasure、layoutは完了していて、描画するぞっていうタイミングでコールバックされます。
doOnNextLayoutと違うところは、goneでもコールされる点なのかなと思います。 Viewがgoneの場合、doOnNextLayoutはコールされないですが、doOnPreDrawではコールされます。
コルーチンと一緒に使う chrisbanes/tiviが凄く参考になります。
PreDrawをCoroutineと協調して動くようにしたいなら、次のようになります。
/* * Copyright 2019 Google LLC * * Licensed under the Apache License, Version 2.</description>
    </item>
    
    <item>
      <title>Dagger2: 2.26時点でのKotlinサポート状況</title>
      <link>https://satoshun.github.io/2020/02/dagger-kotlin-support-2.26/</link>
      <pubDate>Sun, 02 Feb 2020 04:51:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/dagger-kotlin-support-2.26/</guid>
      <description>Daggerの2.25から少しずつKotlin向けの対応が入っています。
この記事ではそれらについて紹介していきます。
objectクラスにJvmStaticが必須ではなくなった 2.25から入った変更です。
前 @Module object AppModule {  @JvmStatic // JvmStaticの指定が必須だった  @Provides  fun provideFuga(): Fuga = Fuga() } 今 @Module object AppModule {  @Provides  fun provideFuga(): Fuga = Fuga() } Qualifierを使うときに、fieldの指定がいらなくなった これも2.25から入った変更です。
前 @Inject @field:HogeQualifier // @field:の指定が必須だった lateinit var namedObject: NamedObject 今 @Inject @HogeQualifier lateinit var namedObject: NamedObject companion objectにModuleをつけなくて良くなった これは2.26から入った変更です。
前 @Module interface MainActivityModule {  @Module // 必須だった  companion object {  @JvmStatic // 必須だった  @Provides  fun provideTestHoge(): TestHoge = TestHoge()  } } 今 @Module interface MainActivityModule {  companion object {  @Provides  fun provideTestHoge(): TestHoge = TestHoge()  } } まとめ ハマりがちだった部分が少しずつ解消されていく😊</description>
    </item>
    
    <item>
      <title>fitsSystemWindowsの話をつらつらと</title>
      <link>https://satoshun.github.io/2020/01/android-fitssystemwindows/</link>
      <pubDate>Sun, 26 Jan 2020 04:40:11 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/01/android-fitssystemwindows/</guid>
      <description>fitsSystemWindowsについてマスターしつつあるので、つらつらと学んだことをまとめておきます。
SystemUiVisibilityの詳細な設定については説明を割愛するのでご了承ください。
そもそもfitsSystemWindowsとは? Android端末には、status bar、navigation barなどのSystem UIと総称されるViewがあります。 デフォルトでは、System UIにコンテンツの要素が被ることはありません。そこには制約があります。 しかし、SystemUiVisibilityの設定を変えることで、コンテンツの要素をSystem UIの裏側描くことが可能になります。
   右の図がSystemUiVisibilityの設定を変更したものです。画像がstatus bar、navigation barの背後に描画されていることが分かります。
ここからが本題です。上記の画像の場合は、画像をめいいっぱいに広げて表示しても違和感がありません。しかし、AppBarLayoutといったToolbarの場合はどうなるでしょうか?
   右の図のAppBarLayoutが、status barに食い込んでしまっていることが分かります。SystemUiVisibilityの設定を変えている場合、status barの高さを考慮する必要があることが分かります。
このときに、fitsSystemWindowsを使うとSystem UIに被らないようにコンテンツを配置することが出来ます。
&amp;lt;LinearLayout android:fitsSystemWindows=&amp;#34;true&amp;#34;&amp;gt;  &amp;lt;com.google.android.material.appbar.AppBarLayout /&amp;gt;  ... &amp;lt;/LinearLayout&amp;gt;    見た目が元に戻りました。fitsSystemWindowsをつけると、どのViewの要素が変化するかをLayout Inspectorで確認します。
   paddingTopと、paddingBottomに値が指定されていることが分かります。これはfitsSystemWindowsのデフォルトの振る舞いによるものです。
fitsSystemWindowsはデフォルトで、paddingTopにstatus barの高さを、paddingBottomにnavigation barの高さを設定します。それにより、コンテンツがSystem UIに被らないようになります。
まとめると「fitsSystemWindowsはSystem UIの高さに応じてpaddingに値をセットする」振る舞いをします。
しかし、これはデフォルトの動作で、fitsSystemWindowsの動作を変更することが出来ます。
AppBarLayoutはfitsSystemWindowsのデフォルトの動作を変更しているViewなので、AppBarLayoutにfitsSystemWindowsをつけた場合にどのように動作するかを見てみます。
AppBarLayoutのfitsSystemWindowsの解釈 fitsSystemWindowsをAppBarLayoutに設定します。
&amp;lt;LinearLayout&amp;gt;  &amp;lt;com.google.android.material.appbar.AppBarLayout  android:fitsSystemWindows=&amp;#34;true&amp;#34; /&amp;gt;  ... &amp;lt;/LinearLayout&amp;gt;     見た目はおかしくないのですが、paddingが変更されていません。じゃあどこが変わったかというと、heightの値が変わっています。
   省略するのですが、fitsSystemWindowsを指定しない場合のAppBarLayoutの高さは154でした。上記の図の220という数字は 154(元の高さ) + 66(status barの高さ) = 220です。</description>
    </item>
    
    <item>
      <title>FragmentでViewの参照を持つとメモリリークする話と実装</title>
      <link>https://satoshun.github.io/2020/01/fragment-view-memory-leak/</link>
      <pubDate>Sat, 18 Jan 2020 13:09:08 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/01/fragment-view-memory-leak/</guid>
      <description>View Bindingのドキュメントが更新され、onDestroyViewのタイミングで保持しているBindingの参照を解放する節が追記されました。
Use view binding in fragments
Fragment自体のライフサイクルのほうが、FragmentのViewのライフサイクルより長いので、FragmentでBindingの参照を保持するとリークしてしまうためです。
この記事では、メモリリークをしないために、どのような実装が考えられるかを紹介していきます。
1. onDestoryViewで解放する 公式ドキュメントに載っている方法です。
// onCreatedViewで初期化 private var _binding: ResultProfileBinding? = null private val binding get() = _binding!!  override fun onCreateView(  inflater: LayoutInflater,  container: ViewGroup?,  savedInstanceState: Bundle? ): View? {  _binding = ResultProfileBinding.inflate(inflater, container, false)  val view = binding.root  return view }  override fun onDestroyView() {  _binding = null } onDestroyViewで参照を解放するコードを書きます。シンプルですが、冗長なのかなと思います。
2. AACサンプルで使っているAutoClearedValueを使う takahiromさんにTwitterで教えてもらったんですが、AACサンプルではDelegationを使って、自動で参照を解放しているようです。</description>
    </item>
    
    <item>
      <title>Material Components: ShapeableImageViewで丸く切り抜かれた画像を表示する</title>
      <link>https://satoshun.github.io/2019/12/material-shapeable-image-view/</link>
      <pubDate>Tue, 24 Dec 2019 00:40:05 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/12/material-shapeable-image-view/</guid>
      <description>Material androidの1.2.0-alpha03にShapeableImageViewが爆誕したのでそれの紹介です。
material-components-android/1.2.0-alpha03
ShapeableImageView? 名は体を表しており、shapeに対応したImageViewになります。shapeには丸やひし形などを設定することが可能です。
さっそくいじっていきたいと思います。
丸を設定してみる スタイルから定義する場合は、次のようにやります。
&amp;lt;!-- スタイル定義 --&amp;gt; &amp;lt;style name=&amp;#34;ShapeAppearance.Example.PILL&amp;#34; parent=&amp;#34;&amp;#34;&amp;gt;  &amp;lt;item name=&amp;#34;cornerFamily&amp;#34;&amp;gt;rounded&amp;lt;/item&amp;gt;  &amp;lt;item name=&amp;#34;cornerSize&amp;#34;&amp;gt;50%&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt;  &amp;lt;!-- レイアウト --&amp;gt; &amp;lt;com.google.android.material.imageview.ShapeableImageView  android:id=&amp;#34;@+id/circle&amp;#34;  android:layout_width=&amp;#34;200dp&amp;#34;  android:layout_height=&amp;#34;200dp&amp;#34;  android:layout_gravity=&amp;#34;center&amp;#34;  android:layout_margin=&amp;#34;10dp&amp;#34;  android:adjustViewBounds=&amp;#34;true&amp;#34;  android:elevation=&amp;#34;4dp&amp;#34;  app:shapeAppearanceOverlay=&amp;#34;@style/ShapeAppearance.Example.PILL&amp;#34;  app:srcCompat=&amp;#34;@drawable/img&amp;#34; /&amp;gt;  画像が丸くなっていることが分かると思います。cornerSizeを50%指定すると、ちょうど丸のshapeになります。
コードから設定する場合は、ShapeAppearanceModelを介して行います。
val model = ShapeAppearanceModel.builder().setAllCornerSizes(ShapeAppearanceModel.PILL).build() imageView.shapeAppearanceModel = model ひし形を設定してみる &amp;amp; strokeをつける スタイルから定義する場合は、次のようにやります。
&amp;lt;!-- スタイル定義 --&amp;gt; &amp;lt;style name=&amp;#34;ShapeAppearance.Example.Diamond&amp;#34; parent=&amp;#34;&amp;#34;&amp;gt;  &amp;lt;item name=&amp;#34;cornerFamily&amp;#34;&amp;gt;cut&amp;lt;/item&amp;gt;  &amp;lt;item name=&amp;#34;cornerSize&amp;#34;&amp;gt;50%&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt;  &amp;lt;!</description>
    </item>
    
    <item>
      <title>ViewModelとKotlin Coroutinesの書き方あれこれ</title>
      <link>https://satoshun.github.io/2019/12/android-viewodel-kotlin-coroutine/</link>
      <pubDate>Sun, 15 Dec 2019 07:15:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/12/android-viewodel-kotlin-coroutine/</guid>
      <description>ViewModel + Kotlin Coroutineを使う場合、どんな感じでViewModelでCoroutineを表現するかについてあれこれ書いてみました。
MVVM + Repositoryを想定しており、UIに反映する部分はLiveDataを考えています。
環境はandroidx.lifecycle:lifecycle-viewmodel-ktxは2.2.0-rc03、Coroutineは1.3.3です。
この記事は次の順序で進んでいきます。
 viewModelScopeとは? suspend関数をコールするとき Flowをコール/購読するとき  viewModelScopeとは? androidx.lifecycle:lifecycle-viewmodel-ktxライブラリには、viewModelScope拡張関数が含まれています。定義は次の通りです。
/** * [CoroutineScope] tied to this [ViewModel]. * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called */ val ViewModel.viewModelScope: CoroutineScope ViewModelのライフサイクルに合わせたCoroutineScopeを取得することが出来ます。 このスコープ上でCoroutineを実行すれば、ViewModelの破棄に合わせて、自動でdisposeしてくれます。
また、viewModelScopeは、メインスレッド上で実行してくれるため、LiveData.setValueを使い、値を更新します。
val userLiveData = MutableLiveData(...)  viewModelScope.launch {  val user = userRepository.getUser() // 適当なsuspend関数をコール   userLiveData.setValue(user) // メインスレッド上で実行されることが保証されているのでsetValueを使う  // userLiveData.postValues(user) } viewModelScopeを使っている場合は、postValueメソッドを使うケースは無いと思います。
suspend関数をコールするとき ネットワークコールなどのAPIは、suspendで表現することになると思います。 また、Retrofitでは2.</description>
    </item>
    
    <item>
      <title>メモ Android: Navigation Component &#43; Toolbar(ActionBar)周りのコードを読んで見る</title>
      <link>https://satoshun.github.io/2019/11/navigation-toolbar-internal-code/</link>
      <pubDate>Sat, 30 Nov 2019 06:14:19 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/navigation-toolbar-internal-code/</guid>
      <description>Navigation Component + Toolbarのデフォルトの挙動をカスタマイズしたかったので、その周辺のコードを読んでみたメモブログになります。
この記事のコードは、次のライセンスに従います。
/*  * Copyright 2018 The Android Open Source Project  *  * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;);  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>Material Components: ShapeとBottomSheetDialogとMaterialButton</title>
      <link>https://satoshun.github.io/2019/11/material-shape/</link>
      <pubDate>Tue, 26 Nov 2019 00:30:46 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/material-shape/</guid>
      <description>Shapeがmaterial androidの1.1.0-alpha01から実装されました。
Shapeとは、こんなやつです。
 参照: About shape
この記事では、BottomSheetDialogとMaterialButtonを参考に、Shapeをどのように設定するかを説明します。
より詳しい説明は公式ドキュメント/Shape.mdを参照してください。
まずはテーマを設定する Theme.MaterialComponentsを使う必要があります。
 Theme.MaterialComponents.Light Theme.MaterialComponents.DayNight  などをテーマに指定します。
&amp;lt;style name=&amp;#34;AppTheme&amp;#34; parent=&amp;#34;Theme.MaterialComponents.DayNight&amp;#34;&amp;gt; ... こんな感じです。
準備は終わったので、BottomSheetDialogにShapeを適用してみます。
BottomSheetDialogにShapeを指定していく （多分）大きく3つの指定方法があります。
 shapeAppearanceLargeComponentを指定する bottomSheetDialogThemeを指定する 独自でテーマを作り、BottomSheetDialogの引数などから与える  shapeAppearanceLargeComponentを指定する デフォルトだとBottomSheetDialogのスタイルとして、@style/Widget.MaterialComponents.BottomSheet.Modalを使うようになっています。
このスタイルの定義は、次のようになっています。
&amp;lt;style name=&amp;#34;Widget.MaterialComponents.BottomSheet.Modal&amp;#34; parent=&amp;#34;Widget.MaterialComponents.BottomSheet&amp;#34;&amp;gt; ...  &amp;lt;style name=&amp;#34;Widget.MaterialComponents.BottomSheet&amp;#34; parent=&amp;#34;Widget.Design.BottomSheet.Modal&amp;#34;&amp;gt;  ...  &amp;lt;item name=&amp;#34;shapeAppearance&amp;#34;&amp;gt;?attr/shapeAppearanceLargeComponent&amp;lt;/item&amp;gt;  ... &amp;lt;/style&amp;gt; shapeAppearanceに、?attr/shapeAppearanceLargeComponentが使われています。shapeAppearanceは、Shapeの設定を流し込む部分です。 なので、これを変えればBottomSheetDialogのShapeを変える事ができます。
たとえば、次のように設定してみます。
&amp;lt;style name=&amp;#34;AppTheme&amp;#34; parent=&amp;#34;Theme.MaterialComponents.DayNight&amp;#34;&amp;gt;  &amp;lt;!-- ?attr/shapeAppearanceLargeComponentの設定 --&amp;gt;  &amp;lt;item name=&amp;#34;shapeAppearanceLargeComponent&amp;#34;&amp;gt;@style/ShapeAppearance.Sample.LargeComponent&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt;  &amp;lt;style name=&amp;#34;ShapeAppearance.Sample.LargeComponent&amp;#34; parent=&amp;#34;&amp;#34;&amp;gt;  &amp;lt;item name=&amp;#34;cornerFamily&amp;#34;&amp;gt;cut&amp;lt;/item&amp;gt;   &amp;lt;!</description>
    </item>
    
    <item>
      <title>Android: Groupieの内部でやっている差分更新周りの話</title>
      <link>https://satoshun.github.io/2019/11/groupie-diffutil/</link>
      <pubDate>Thu, 21 Nov 2019 12:35:25 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/groupie-diffutil/</guid>
      <description>GroupieにはGroupAdapter#updateメソッドという便利なメソッドがあります。
この記事ではupdateメソッドをコールした時に、どのように差分更新されるかを、簡単な説明と実際に動かしてみて見ていきます。
そもそもRecyclerViewの差分更新って何よ RecyclerViewでは、DiffUtil.Callbackクラスを実装することで、前のAdapterの状態と、新しいAdapterの状態の差分を計算することが出来ます。その計算結果をもとに、RecyclerViewでは効率的にViewを更新してくれます。またいい感じにアニメーションを実行してくれます。
Groupieでは、内部でDiffUtil.Callbackを実装したDiffCallbackクラスがあり、そのクラスをもとに差分更新が行われます。
DiffCallbackクラスの実装を見ていく まずはareItemsTheSameメソッドから。areItemsTheSameメソッドは、Itemが同一かどうかを判定します。
@Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {  Item oldItem = GroupUtils.getItem(oldGroups, oldItemPosition);  Item newItem = GroupUtils.getItem(newGroups, newItemPosition);  return newItem.isSameAs(oldItem); } まず、1つ前のItemと新しいItemを取ってきて、newItem.isSameAs(oldItem);をコールしています。
isSameAsメソッドは次の定義になっています。
public boolean isSameAs(Item other) {  if (getViewType() != other.getViewType()) {  return false;  }  return getId() == other.getId(); } ItemのviewTypeが等しい かつ Idが等しい場合にtrueを返します。
Idは、Itemクラスのコンストラクタから与えることが出来ます。
protected Item(long id) {  this.id = id; } なので、GroupAdapterがupdateされる可能性があるなら、適切なIdを渡すのが良いです。 例えば、Userクラス的なものがあって、運良くUserを一意に判定できるidが定義されていたら、それを渡すと良いと思います。</description>
    </item>
    
    <item>
      <title>Android マルチモジュール: Gradle周りで便利だと思う設定</title>
      <link>https://satoshun.github.io/2019/11/multi-module-gradle-properties/</link>
      <pubDate>Mon, 11 Nov 2019 00:50:18 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/multi-module-gradle-properties/</guid>
      <description>マルチモジュールなアプリを作ることをテーマにブログを書いていこうの、2本目です。
1本目はこちらになります。
 Android マルチモジュール: ライブラリのバージョン管理について  今回は、マルチモジュール環境における、Gradle周りの便利であろう設定について、次の4つを紹介します。
 モジュール内のリソース名にルールを持たせる BuildConfigを作らない モジュール内でProGuard/R8の設定をする Rファイルを小さく保つ  モジュール内のリソース名にルールを持たせる resourcePrefixは、リソース名のプレフィックスにルールを設けるプロパティです。
例えば、次のように書くと、このモジュール内のリソース（レイアウト、Drawable、Stringなど）はhome_から始まる必要があります。
// build.gradle android {  ...  resourcePrefix &amp;#39;home_&amp;#39; }  // strings.xml &amp;lt;resource&amp;gt;  // home_から始まる必要がある  &amp;lt;string name=&amp;#34;home_app_name&amp;#34;&amp;gt;適当な文字列&amp;lt;/string&amp;gt; &amp;lt;/resource&amp;gt; これを定義することで、名前のコンフリクトを防ぐことが出来ます。また、名前からリソースがどのモジュールで定義されているかを推測すること出来ます。
BuildConfigを作らない モジュールのBuildConfigの生成を無効にすることが出来ます。例えば、uber/AudoDisposeでは、次のように設定しています。
// build.gradle project.android {  libraryVariants.all {  it.generateBuildConfigProvider.configure {  it.enabled = false  }  } } モジュールで、BuildConfigが必要になることは稀なので、基本つけておくと良いと思います。
モジュール内でProGuard/R8の設定をする consumerProguardFilesを使うことで、モジュールのProguard/R8の設定を定義することが出来ます。
例えば、次のように使います。
// build.gradle android {  defaultConfig {  consumerProguardFiles &amp;#39;consumer-rules.</description>
    </item>
    
    <item>
      <title>Android: Navigationのdialogタグ周りのコードちょっと読んでみた</title>
      <link>https://satoshun.github.io/2019/11/navigation-dialog-internal-code/</link>
      <pubDate>Sat, 09 Nov 2019 06:23:13 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/navigation-dialog-internal-code/</guid>
      <description>Navigation Component 2.1.0からdialogタグが使えるようになりました。 どんな感じで処理をしているのか気になったので、ざっくりとメモ書き。
1. abstract Navigatorクラス このクラスは最終的にどのように、対象クラスをnavigateされるかを決めるクラスです。 Activityなら、ActivityNavigator。FragmentならFragmentNavigatorが使われます。 dialogの場合は、DialogFragmentNavigator経由でdialogが発火するようになっています。
2. NavInlaterでdialogタグの場合、DialogFragmentNavigatorを使うようにしている NavInflaterは単純なXMLパーサーになっています。&amp;lt;dialog &amp;hellip;&amp;gt; を発見したら、DialogFragmentNavigatorからNavDestinationを作成するようになっています。 このNavDestinationは実際にコールされるときに、DialogFragmentNavigatorを呼び出すような仕組みなっています。
3. DialogFragmentNavigatorの中身 一部分を抜粋します。
/* * Copyright 2019 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>Android Studio: Firebaseなどのクラッシュログから関数ジャンプできるようにする</title>
      <link>https://satoshun.github.io/2019/10/analyze-stack-trace/</link>
      <pubDate>Tue, 29 Oct 2019 01:32:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/10/analyze-stack-trace/</guid>
      <description>Android Studio: Debugging Tips n&amp;rsquo; Tricks (Android Dev Summit &amp;lsquo;19)で、便利な機能があったので、それの紹介です。
 テキスト形式のクラッシュログを、Android Studio上で関数ジャンプ出来るようになります。 Firebaseのクラッシュログを例にして説明してきます。
まず、 Firebaseからクラッシュログをコピーします。
  次に、Android StudioのAnalyze Stack Trace or Thread Dumpを使い、さきほどコピーしたクラッシュログをペーストします。
  そうすると、Android Studio上で、関数ジャンプが出来るようになります！
 </description>
    </item>
    
    <item>
      <title>Android Gradle Plugin 4.0でjava.timeがバックポートされるようになりました</title>
      <link>https://satoshun.github.io/2019/10/desugar-java-time/</link>
      <pubDate>Sat, 26 Oct 2019 02:21:55 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/10/desugar-java-time/</guid>
      <description>Java 8 library desugaring in D8 and R8で、desugarがA subset of java.timeに対応したとのことで、ThreeTenABPが置き換えられるのでは？と思い、ウキウキで試してみました。
環境は com.android.tools.build:gradle:4.0.0-alpha01になります。
セットアップ build.gradleに、coreLibraryDesugaringEnabledを追加します。
compileOptions {  sourceCompatibility JavaVersion.VERSION_1_8  targetCompatibility JavaVersion.VERSION_1_8   coreLibraryDesugaringEnabled true } これで完了です。
java.timeのAPIを呼び出してみる 29, 21のエミュレーターで次のコードを試したところ、クラッシュすることなく、無事に実行することが出来ました！
// Instant API val date = Date() val instant = date.toInstant() binding.instant.text = instant.epochSecond.toString()  // ZoneId API val zoneId = ZoneId.systemDefault() binding.zoneId.text = zoneId.id println(instant.atZone(zoneId).dayOfMonth) println(instant.atZone(zoneId).month)  // LocalDate API val now = LocalDate.now() binding.localDate.text = now.dayOfMonth.toString() println(now.</description>
    </item>
    
    <item>
      <title>ViewPager2で要素をループさせる</title>
      <link>https://satoshun.github.io/2019/10/viewpager2-loop/</link>
      <pubDate>Sun, 13 Oct 2019 05:23:44 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/10/viewpager2-loop/</guid>
      <description>ViewPager2で要素をループさせる方法の紹介です。いわゆる循環リストです。
ViewPager2ではRecyclerViewを使うことが出来るので、RecyclerViewと同じような実装で実現することが出来ます。
最終的にこんなのが作れます。（a、b、cの要素でループしている）
 今回の検証に用いたコードは、satoshun/ViewPager2にあります😃
では、コードを説明していきます。今回は、1つのViewTypeを扱います。
実際のコード まず、RecyclerView.Adapterのサイズを決めるgetItemCountメソッドの実装です。 限りなく大きい値、Int.MAX_VALUEを返します。
override fun getItemCount(): Int = Int.MAX_VALUE 次に、onBindViewHolderメソッドを次のように実装します。
private val itemData: List&amp;lt;Data&amp;gt;  override fun onBindViewHolder(holder: InfiniteViewHolder, position: Int) {  val data = itemData[position % itemData.size]  ... } itemDataにはViewの生成に必要な実際のデータが入っています。position % itemData.sizeとindexを取ることで、ループ中のどこの位置にいるかを特定することが出来ます。
最終的な、RecyclerView.Adapterは次のようになります。（onCreateViewHolderメソッドは重要でないので、省略しています）
class InfiniteAdapter(  private val itemData: List&amp;lt;Data&amp;gt; ) : RecyclerView.Adapter&amp;lt;InfiniteViewHolder&amp;gt;() {   override fun getItemCount(): Int = Int.MAX_VALUE   override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = .</description>
    </item>
    
    <item>
      <title>Android マルチモジュール: ライブラリのバージョン管理について</title>
      <link>https://satoshun.github.io/2019/09/multi-module-dependency-management/</link>
      <pubDate>Mon, 23 Sep 2019 12:07:59 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/09/multi-module-dependency-management/</guid>
      <description>マルチモジュールなアプリを作ることをテーマにいくつかの記事を書いていきたいと思っています。
まだ正確には決まっていないのですが、以下のような内容をまとめていこうと思っております。
 ライブラリのバージョン管理について マルチモジュール構築に役立つGradleの設定 モノリシックなアプリからマルチモジュールへ 外部ライブラリとして切り出すタイミングを考える DFM、モジュール間の遷移方法 モジュールの階層について ビルドの高速化について   今回は、ライブラリのバージョン管理について書いてきます。
ライブラリのバージョン管理？ Android開発では、Gradleで外部ライブラリの依存を定義するのが一般的です。マルチモジュールプロジェクトの場合、外部ライブラリのバージョンを合わせるため、変数のような形で定義しておくと便利です。
変数の定義方法には、直接記述する方法を除くと、大きく2つの方法があります。
1. Gradleのextraプロパティを使う Androidの公式ドキュメント: Configure project-wide propertiesで紹介されている方法です。 extにバージョンを定義します。
例えば、OkHttpでは、次のように定義しています。
buildscript {  ext.versions = [  &amp;#39;animalSniffer&amp;#39;: &amp;#39;1.17&amp;#39;,  &amp;#39;assertj&amp;#39;: &amp;#39;3.11.0&amp;#39;,  &amp;#39;bouncycastle&amp;#39;: &amp;#39;1.62&amp;#39;,  &amp;#39;brotli&amp;#39;: &amp;#39;0.1.2&amp;#39;,  ...   ext.deps = [  &amp;#39;picocli&amp;#39;: &amp;#34;info.picocli:picocli:${versions.picocli}&amp;#34;,  &amp;#39;android&amp;#39;: &amp;#34;org.robolectric:android-all:9-robolectric-4913185-2&amp;#34;,  &amp;#39;animalSniffer&amp;#39;: &amp;#34;org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}&amp;#34;,  &amp;#39;assertj&amp;#39;: &amp;#34;org.assertj:assertj-core:${versions.assertj}&amp;#34;,  &amp;#39;bouncycastle&amp;#39;: &amp;#34;org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}&amp;#34;,  &amp;#39;brotli&amp;#39;: &amp;#34;org.brotli:dec:${versions.brotli}&amp;#34;,  ... extプロパティにライブラリのバージョンをセットします。</description>
    </item>
    
    <item>
      <title>ViewPager2でカルーセルっぽいものを実装する</title>
      <link>https://satoshun.github.io/2019/08/viewpager2-like-a-carousel/</link>
      <pubDate>Thu, 29 Aug 2019 13:29:06 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/08/viewpager2-like-a-carousel/</guid>
      <description>横のアイテムをチラ見せする画面をViewPager2で書けるよって話です。
最終的にこんなのが作れます。
 では、コードを説明していきます。
1. 横のアイテムをチラ見せする まず、ViewPager2をLayout内に定義します。
&amp;lt;androidx.viewpager2.widget.ViewPager2  android:id=&amp;#34;@+id/viewpager&amp;#34;  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;200dp&amp;#34;  android:orientation=&amp;#34;horizontal&amp;#34;  /&amp;gt; 次に、横のアイテムをどれだけチラ見せるかを定義します。
&amp;lt;dimen name=&amp;#34;offset&amp;#34;&amp;gt;32dp&amp;lt;/dimen&amp;gt; 次に、各アイテム間にどれだけのマージンをつけるかを定義します。
&amp;lt;dimen name=&amp;#34;page_margin&amp;#34;&amp;gt;16dp&amp;lt;/dimen&amp;gt; 次に、ViewPager2内で使うレイアウトのトップレベルのViewにmarginLeft、Rightをセットします。
&amp;lt;com.google.android.material.card.MaterialCardView  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;match_parent&amp;#34;  android:layout_marginLeft=&amp;#34;48dp&amp;#34; // これは、offset + page_marginの値  android:layout_marginRight=&amp;#34;48dp&amp;#34;  app:cardCornerRadius=&amp;#34;16dp&amp;#34;&amp;gt;  ... marginには前で定義したoffset、page_marginを足し合わせたものを指定します。
そして、最後にPageTransformerを設定します。
viewpager.offscreenPageLimit = 2 // これは左右のアイテムを描画するために必要  val pageMarginPx = root.context.resources.getDimensionPixelOffset(R.dimen.page_margin) val offsetPx = root.context.resources.getDimensionPixelOffset(R.dimen.offset) viewpager.setPageTransformer { page, position -&amp;gt;  val offset = position * (2 * offsetPx + pageMarginPx)  page.</description>
    </item>
    
    <item>
      <title>GitHubのNotificationsで、androidxライブラリのリリースの通知を受け取れるリポジトリを作りました</title>
      <link>https://satoshun.github.io/2019/07/androidx-releases/</link>
      <pubDate>Sat, 20 Jul 2019 02:57:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/androidx-releases/</guid>
      <description>androidxのライブラリのリリースをGitHubのReleases onlyを使って検知するためのリポジトリを作りました。 androidx-releasesにそれぞれのリポジトリがあります。
例えば、Appcompatのリリースを検知したかったら、次の画像のように、androidx-releases/appcompatのNotificationsのReleases Onlyをチェックします。
 この状態で、Appcompatに新しいリリースがあったら、GitHubに登録してあるメールアドレスにメールが届きます。
 まとめ  作ってみたものの、これが便利なのかは良く分かってないです:D 他のandroidxライブラリのリリースの通知を受けたいなら、androidx-releasesから登録を。 何か他に欲しいandroidxリポジトリがあったら教えてください😃  </description>
    </item>
    
    <item>
      <title>Material Components: MaterialTextViewでlineHeightがTextAppearanceから指定出来るようになりました</title>
      <link>https://satoshun.github.io/2019/07/material-textview/</link>
      <pubDate>Mon, 15 Jul 2019 03:09:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/material-textview/</guid>
      <description>従来のTextView（AppCompatTextView）では、lineHeightの指定をTextAppearanceから出来ませんでした。
それが、material-component 1.1.0-alpha08にMaterialTextViewが爆誕し、lineHeightがTextAppearanceから指定出来るようになりました🎉
使い方 まずはstyleを定義します。
&amp;lt;style name=&amp;#34;TextAppearance.LineHeight&amp;#34;&amp;gt;  &amp;lt;item name=&amp;#34;lineHeight&amp;#34;&amp;gt;20sp&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt; 次に、TextViewから指定します。
&amp;lt;TextView  android:layout_width=&amp;#34;wrap_content&amp;#34;  android:layout_height=&amp;#34;wrap_content&amp;#34;  android:text=&amp;#34;テスト&amp;#34;  android:textAppearance=&amp;#34;@style/TextAppearance.LineHeight&amp;#34; /&amp;gt; これで完了です😃
MaterialTextViewをXMLから直接指定してもいいのですが、AppCompatActivityを使っていれば、自動的にMaterialTextViewがinflateされるようになっています。 詳しくはMaterialComponentsViewInflater.javaをご覧下さい。
まとめ  material-component 1.1.0-alpha08にアップデートすると、自動的にMaterialTextViewが使われ、TextAppearanceからlineHeightが指定できる😃  </description>
    </item>
    
    <item>
      <title>Android: RestrictToアノテーションのIDE上での振る舞い</title>
      <link>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</link>
      <pubDate>Wed, 03 Jul 2019 12:30:11 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</guid>
      <description>androidx.annotation:annotationには、RestrictToアノテーションクラスが定義されています。 このアノテーションは次の用途を持ちます。
 Denotes that the annotated element should only be accessed from within a specific scope (as defined by Scope).
 指定したScope以外からのアクセスを制限するアノテーションです。
この記事では、このRestrictToアノテーションがついたクラスに様々な場所からアクセスしたときに、どのようにIDE上で警告が出るかについて見ていきます。
また、Android Studio 3.5.0-beta05で検証しました。
この記事内に出てくるRestrictTo関連のコードは以下のライセンスに従います。
/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.</description>
    </item>
    
    <item>
      <title>Retrofit: Coroutineを使うときの、Response&lt;T&gt;と生のTの使い分け</title>
      <link>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</link>
      <pubDate>Tue, 02 Jul 2019 13:46:54 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</guid>
      <description>psideさんの、Retrofit2でRxJavaを使う時の Result, Response, そのままT の使い分け所感のCoroutineバージョンの記事となります。
上記の記事に書いてある、Rxとは違い、Result型は用意されていないので、Response型で包むか、生で値ｗ受け取るかのどちらかが基本となります。
interface HogeService {  suspend fun getHoge(): Hoge  or  suspend fun getHoge(): Response&amp;lt;Hoge&amp;gt; } Retrofitの2.6.0で、挙動の違いを確認しました。
    生 Response     200 成功 成功   404 例外 成功   ネットワークに繋がっていない 例外 例外   シリアライズが出来ない（型がおかしい） 例外 例外     生の場合、HTTPのstatus Code的に失敗とされるものは例外になる Response型で包めば、HTTPのstatus Code的に失敗だとしても例外が発生しない  っていう感じの挙動になります。
どっちを使えばいいの? サーバがエラーコードを返してきた時に、特別な振る舞いをしたいエンドポイントってあると思うので、そういうときはResponseで包んであげて、それ以外は生でいいんじゃない？って思ってます（小並感</description>
    </item>
    
    <item>
      <title>Google I/O&#39;19: Build a Modular Android App Architectureのまとめ・感想</title>
      <link>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</link>
      <pubDate>Sun, 09 Jun 2019 12:04:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</guid>
      <description>以下の動画のまとめです。
Build a Modular Android App Architecture (Google I/O&#39;19)
なぜモジュール化をするか? スケール モジュール化することで、開発者が独立して開発出来るようになる
 人数が増えてきた時、アプリが大きくなってきた時にモジュール化は有効  保守性 例えば、モノリシックアプリだとレイアウトファイルを1つのディレクトリに持つことになる
 何をしているのか、何をしたいのかが理解しにくい 長いレイアウトファイル名になりがち  ビルド時間の短縮 変更があったモジュール + その依存関係にあるモジュールが再ビルドされるため、ビルド時間が短くなる
CIの高速化 再ビルドが必要なモジュールのみテストをすれば良いので、テスト時間が短くなる
 androidx/dependencyTrackerを使うといい感じにテストが出来る（らしい）  APKサイズの縮小 App Bundle、Dynamic Deliveryの恩恵を受けられる
モジュール どのようにモジュール分けをするか?
1. Feature（機能）ごとに分ける ライブラリモジュールとDynamic Featureモジュールの2種類がある。
 ライブラリモジュール  com.android.libraryを指定する   Dynamic Featureモジュール  onDemand trueとfalseがある  Paidのような一部のユーザが使う機能の場合はtrueが良い Onboardingのように、後でいらなくなる機能の場合はfalseが良い      Plaidでは以下のようなモジュール構成にした。
 dribbleと、designernewsがDynamic Featureモジュールになっている。
2. Layer（層、階層）ごとに分ける Plaidでは以下のように分けた。
   Web Servicesの知識はUIはいらないので、implementationを指定する  そうすることで、UIがDTOやRetrofitの知識を知らないですむ   Entitiesの知識はUIが必要なので、apiを指定する  ただし、この場合、DAOsの知識までUIが知ってしまうので微妙  そこでCommon Value Objectsの導入       こうすることで、UIがDAOの知識を知らずに済む</description>
    </item>
    
    <item>
      <title>Dagger2: 2.23に入ったHasAndroidInjectorについて</title>
      <link>https://satoshun.github.io/2019/06/dagger-android-injector/</link>
      <pubDate>Sun, 02 Jun 2019 09:08:57 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/dagger-android-injector/</guid>
      <description>Dagger 2.23に新しく、HasAndroidInjectorインターフェースが入りました。 これは、従来のHasActivityInjectorやHasFragmentInjectorなどを置き換えるために作られました。
この記事では、どのように置き換えるかを説明していきたいと思います。
また、DaggerApplicationやDaggerActivityなどの基底クラスは使っていないものとします。
置き換えていく AppComponent AndroidSupportInjectionModuleを使っているなら、AndroidInjectionModuleに置き換えます。 今後は、AndroidSupportInjectionModuleを使う必要はありません。
@Singleton @dagger.Component(  modules = [  AndroidInjectionModule::class, // AndroidInjectionModuleを使う  ...  ] ) interface AppComponent ... Application Applicationで実装している、HasActivityInjector、HasServiceInjectorなどのHasxxxInjectorをHasAndroidInjectorに置き換えます。
class App : Application(),  // HasAndroidInjectorのみでおｋ  HasAndroidInjector {   // 型変数がAnyになる  @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt;   // 返り値の型変数がAnyになる  override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; {  DaggerAppComponent.factory().create(this).inject(this)  return androidInjector  } } 今まではActivity用、Fragment用、Service用などのクラスごとにDispatchingAndroidInjectorがありましたが、それが1つのDispatchingAndroidInjector&amp;lt;Any&amp;gt;まとまりました。
Activity, Fragment HasSupportFragmentInjectorなどのInjectorは、HasAndroidInjectorに置き換えます。</description>
    </item>
    
    <item>
      <title>ViewModel SavedState &#43; Dagger</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</link>
      <pubDate>Sat, 25 May 2019 10:38:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</guid>
      <description>ViewModel + SavedStateでDaggerを使う方法を考えてみました。
前提知識・課題 SavedStateを使う場合、ViewModelにSavedStateHandleインスタンスを渡さなければいけません。
class MyViewModel(  private val state: SavedStateHandle ) : ViewModel() {  ... } SavedStateHandleインスタンスを作るために、SavedStateVMFactoryもしくは、AbstractSavedStateVMFactoryを使う必要があります。
生成したいViewModelのコンストラクタの引数がSavedStateHandleのみなら、SavedStateVMFactoryを使います。
// thisはFragmentActivity ViewModelProvider(this, MyViewModel(this))  .get(MyViewModel::class.java) コンストラクタの引数がSavedStateHandle以外にもあるなら、AbstractSavedStateVMFactoryを拡張します。
class TestViewModel(  private val state: SavedStateHandle,  private val name: String ) : ViewModel()  class TestViewModelFactory(  owner: SavedStateRegistryOwner,  defaultArgs: Bundle? = null ) : AbstractSavedStateVMFactory(owner, defaultArgs) {  override fun &amp;lt;T : ViewModel&amp;gt; create(  key: String, modelClass: Class&amp;lt;T&amp;gt;,  handle: SavedStateHandle  ): T {  return TestViewModel(handle, &amp;#34;test&amp;#34;) as T  } }  // 以下、生成コード ViewModelProvider(this, TestViewModelFactory(this))  .</description>
    </item>
    
    <item>
      <title>雑メモ: ViewModel SavedStateのコードリーディング</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate/</link>
      <pubDate>Tue, 21 May 2019 23:59:53 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate/</guid>
      <description>ViewModelのSavedStateがどのように実現しているのか、内部でどのように動作しているのか気になったので、ソースコードを読んでみました。
この記事のソースコードは全て、下記のライセンスに従います。
/*  * Copyright 2019 The Android Open Source Project  *  * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;);  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ViewPager2 with TabLayout</title>
      <link>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</link>
      <pubDate>Fri, 17 May 2019 04:08:42 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</guid>
      <description>Material ComponentsでViewPager2 + TabLayoutのコードが入ったのでそれの紹介。まだalphaへのリリースもされていないので、APIは大きく変わるかもしれません。おそらく1.1.0-alpha07に入ってくると思います。
TabLayoutはViewPagerでサポートされていましたが、それがViewPager2にも来たって感じです。
使い方 新しく追加されたTabLayoutMediatorを使います。
まず、TabLayoutMediatorインスタンスを生成します。
val viewPager: ViewPager2 = findViewById(R.id.viewpager) val tabLayout: TabLayout = findViewById(R.id.tab) val mediator = TabLayoutMediator(tabLayout, viewPager) { tab: TabLayout.Tab, position: Int -&amp;gt;  tab.text = &amp;#34;test $position&amp;#34; // タブにタイトルをセット } コンストラクタには、TabLayout、ViewPager2、OnConfigureTabCallbackを渡します。 OnConfigureTabCallbackは、tabとpositionを受け取り、tabに対して、タイトルをセットします。 ViewPagerのPageAdapterとは違い、RecyclerViewのAdapterからはタイトルを取得できないので、このような変更になったと思われます。
最後にattach関数を呼び出します。
mediator.attach() これで、ViewPager2 + TabLayoutを実現できます。とても簡単！！
まとめ  ViewPager2もエコシステムが整いつつある😊 今回試したサンプルコードは satoshun-android-example/ViewPager2にあります😃  </description>
    </item>
    
    <item>
      <title>Data Binding 3.5と3.6のまとめ/感想</title>
      <link>https://satoshun.github.io/2019/05/databinding-3dot5/</link>
      <pubDate>Thu, 16 May 2019 00:33:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/databinding-3dot5/</guid>
      <description>Google I/O 2019でDataBindingについて少し話されていたので感想とまとめを。 動画だとここらへんになります。
改善系 ビルドの高速化!  20%くらいビルドが早くなった distributed build cache対応 Incremental annotation processing対応  android.databinding.incremental=true を設定にすると使えます    Android Studioとの連携強化!!  Live Class Generation  XMLを変更したら、コンパイルせずともクラス、フィールドにアクセスすることが出来る   リファクタリング系  フィールド名の変更リファクタリングなどをしたときに、XML、コードの両方に反映される    Errorメッセージの改善!!!  DataBinding用のエラーセクションが出来たことで、どこでエラーが出たか特定しやすくなった   新規系 View Binding 簡易版Data Bindingのような立ち位置で、findViewByIdを省略 + コンパイルセーフ + コンパイルを高速にすることを目的に作られました。3.6で入るみたいです。
 Data Bindingと比較したときの、メリット、デメリット以下になります。（ただし、まだalphaも出ていない段階なのでI/O動画から見る限りの感想です）
メリット  コンパイルが早くなる  Data Bindingより機能が少なくなるのでそれはそう   &amp;lt;layout&amp;gt;で囲う必要がなくなった  これ個人的には好きでなかったので嬉しい。ネストが減る    デメリット  &amp;lt;data&amp;gt;セクションがなくなる  モデルの値とViewのマッピングはコード側ですることになりそう   多分BindingAdapterは使えない  これもコード側ですることになりそう   双方向バインディングとか使えない  おそらくなんですけど、Data Binding、View Bindingは1つにプロジェクトに混在させることが出来るので、基本View Bindingで、双方向使いたいときはData Bindingみたいな使い方も出来るはずです。</description>
    </item>
    
    <item>
      <title>CameraX: CameraView触ってみた</title>
      <link>https://satoshun.github.io/2019/05/camerax-camera-view/</link>
      <pubDate>Mon, 06 May 2019 05:47:14 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/camerax-camera-view/</guid>
      <description>CameraXのコードが公開されていたので、その中にあったCameraViewを触ってみました。まだ、alphaであることからAPIは大きく変わる可能性があります。
内部の実装であったり、細かい部分はpsideさんの「CameraXのコードがきたので気合い入れて読んでみた」が詳しいです。
環境構築 CameraViewはまだ公開されていないため、ソースコードからビルドする必要があります。また、設定でpublishフラグがfalseになっているので、trueにしてビルドします。
 androidx { name = &amp;#34;Jetpack Camera View Library&amp;#34; - publish = false + publish = true mavenVersion = LibraryVersions.CAMERA mavenGroup = LibraryGroups.CAMERA inceptionYear = &amp;#34;2019&amp;#34; } 使い方 CameraViewは普通のViewのように使うことができます。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout  ...&amp;gt;   &amp;lt;androidx.camera.view.CameraView  android:layout_width=&amp;#34;0dp&amp;#34;  android:layout_height=&amp;#34;0dp&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 次に初期化をします。
cameraView.bindToLifecycle(this) // thisはLifecycleOwner LifecycleOwnerとCameraViewを結びつけることでLifecycleに合わせて自動でリソースを調整してくれます。 CameraViewはLifecycle-Aware Componentとなっています。非常に扱いやすそうです。
これだけでカメラ機能が使えるようになります！とても簡単！!
以下、CameraViewで現状使えるAPIについて紹介します。
CameraViewで使えるAPI達 モードの変更 CameraViewでは次の3つのモードがあります。
 Image: 写真を取る Video: ビデオを取る Mixed: 両方。ただし、動かない端末もあるらしい  次のように使います。</description>
    </item>
    
    <item>
      <title>MvRxの雑な感想</title>
      <link>https://satoshun.github.io/2019/05/mvrx-architecture/</link>
      <pubDate>Sun, 05 May 2019 05:05:09 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/mvrx-architecture/</guid>
      <description>雑多なことを書いただけのブログになります。内容はあまりないよう〜。
 MvRxはAirbnbが開発をしているOSSフレームワークです。
特徴としては
 Kotlinファースト RxJavaを使っている AAC（Android Architecture Components）をベースにしている  AACをRxJavaであったり、便利関数、クラス群で補佐している感じ   多くの部分でReactのAPIを参考にしてる  State、renderなど   Epoxyと相性が良い  一緒に使うことを推奨している ReactのComponentのように振る舞わうことが出来る   ViewModelが保持しているState（状態）に対して、Viewがpure functionのように振る舞う  副作用がない（減らしたい）    ボイラープレートなコードを減らすことが期待できます😃
個人的に気になった部分、好きなとこ StateでView状態を管理するところ Stateを定義することのメリットは以下かなと思ってます。
 Stateを見れば、Viewの構成要素が分かる  MVPアーキテクチャのViewインターフェースのような役割を果たす   状態の管理が楽  Androidでは、configuration changes時の状態の保持が難しいが、Stateだけをケアすれば良い  MvRxの流儀に習って、正しく実装すればよしなに状態の管理をしてくれる     Viewからロジックを取ることが出来る  もちろん実装次第なのですが、StateでViewの状態を表現するようにすれば、Viewはマッピングするだけで良くなる    Asyncがすごい良い MvRxではAsyncというsealed classが定義されていて、
 Uninitialized Loading Success Fail  の4状態を表現することができます。画面の初期値は上記4状態で、大体のケースはケア出来ると思います。
プロジェクトに、Asyncだけ取り入れるのもアリだと思います。
Single Eventの処理をどうするのか State内で保持すると、毎回発火してしまうので、Stateとは違う、他のstreamで表現することになると思う</description>
    </item>
    
    <item>
      <title>Material Components: MotionSpecを使ってアニメーションをカスタマイズする</title>
      <link>https://satoshun.github.io/2019/04/fab-motion-spec/</link>
      <pubDate>Tue, 30 Apr 2019 05:59:41 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/fab-motion-spec/</guid>
      <description>MotionSpecはAndroid material componentsに定義されている1クラスになります。 MotionSpecを使うことで、次のアニメーション属性をカスタマイズすることができます。
 startOffset duration interpolator repeatCount repeatMode  例えば、アニメーションを長くしたいときは、durationの値を長く、アニメーションの開始時間を遅らせたいなら、startOffsetの値を長くします。
FloatingActionButtonを例に、実際にMotionSpecの値をいじってみます。
最初にMotionSpec用のanimator XMLを定義する デフォルトのXMLをコピペしてきて、それをベースにカスタマイズするのが良いと思います。
FloatingActionButton用のXMLはソースコードを読んでいくと、design_fab_show_motion_spec.xmlとdesign_fab_hide_motion_spec.xmlで定義されていることが分かります。MotionSpecは、show/hide用の2種類があり、カスタマイズしたいときは両方とも変更する必要があります。
まずはshow用のMotionSpecを変更していきます。以下がデフォルトで定義されているdesign_fab_show_motion_spec.xmlの中身になります。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;!-- Copyright 2017 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ConstraintLayout Flowの紹介</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-flow/</link>
      <pubDate>Sun, 28 Apr 2019 11:13:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/constraintlayout-flow/</guid>
      <description>ConstraintLayoutの2.0.0 alpha 5にFlow Virtual Layoutが導入されました🎉 Flowを使うことで、対象のViewを様々なルールで並べることができます。
メリットとしては、次のようなものがあります。
 Viewの階層をフラットに保つことが出来る Flowは普通のViewのように扱う事ができる MotionLayoutと相性が良い  では、どのように書くのかを見ていきます。
 1. 配置する方向を決める android:orientationから、horizontal or verticalを指定できます。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt;   &amp;lt;androidx.constraintlayout.helper.widget.Flow  android:id=&amp;#34;@+id/flow&amp;#34;  android:layout_width=&amp;#34;0dp&amp;#34;  android:layout_height=&amp;#34;0dp&amp;#34;  android:orientation=&amp;#34;horizontal&amp;#34;  android:background=&amp;#34;@android:color/white&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt;   ... これはorientationにhorizontalを持ちます。また、通常のViewのように各constraintsを指定し、配置することができます。
2. wrapModeを決める flow_wrapModeで指定することができます。
wrapModeでは、どのようにViewを並べるかを指定でき、3種類のmodeがあります。
 none  単純にsingle lineに並べる   chain  単純に順番に配置していく。その行（列）に収まらない場合は次の行（列）に配置する   aligned  各要素を整列するように配置していく。テーブルのようなイメージ     &amp;lt;androidx.</description>
    </item>
    
    <item>
      <title>Kotlin: プロパティの変更を検知する</title>
      <link>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</link>
      <pubDate>Wed, 24 Apr 2019 02:21:47 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</guid>
      <description>オブジェクト自身の変更ではなく、対象のオブジェクトが持つプロパティの変更を汎用的に検知する方法の紹介です。
次が、この記事で紹介したいコードです。
// 1つのプロパティの変更を検知したい fun &amp;lt;S, A1&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(prop1: KProperty1&amp;lt;S, A1&amp;gt;): LiveData&amp;lt;A1&amp;gt; =  this  .map { prop1.get(it) }  .distinctUntilChanged()  // 2つのプロパティの変更を検知したい fun &amp;lt;S, A1, A2&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(  prop1: KProperty1&amp;lt;S, A1&amp;gt;,  prop2: KProperty1&amp;lt;S, A2&amp;gt; ): LiveData&amp;lt;Pair&amp;lt;A1, A2&amp;gt;&amp;gt; =  this  .map { prop1.get(it) to prop2.get(it) }  .distinctUntilChanged()  // 3つのプロパティの変更を検知したい fun &amp;lt;S, A1, A2, A3&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(  prop1: KProperty1&amp;lt;S, A1&amp;gt;,  prop2: KProperty1&amp;lt;S, A2&amp;gt;,  prop3: KProperty1&amp;lt;S, A3&amp;gt; ): LiveData&amp;lt;Triple&amp;lt;A1, A2, A3&amp;gt;&amp;gt; =  this  .</description>
    </item>
    
    <item>
      <title>ConstraintLayoutのImageFilterViewって単体でも使えるんやなって</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</link>
      <pubDate>Mon, 15 Apr 2019 13:17:53 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</guid>
      <description>ConstraintLayout 2.0.0-alphaからImageFilterViewクラスが追加されました。今まで、MotionLayoutと一緒に使うものだから、使い所限られそうだなぁ〜と思っていたのですが、単体でも使えそうだったので、その報告記事になります。
この記事ではConstraintLayout 2.0.0-alpha4を使っています。
角丸にする round属性から指定する事ができます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView  android:id=&amp;#34;@+id/image&amp;#34;  android:layout_width=&amp;#34;100dp&amp;#34;  android:layout_height=&amp;#34;100dp&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34;  app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;  app:round=&amp;#34;0.5dp&amp;#34; /&amp;gt;  彩度 saturation属性から設定することが出来ます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView  android:id=&amp;#34;@+id/image&amp;#34;  android:layout_width=&amp;#34;100dp&amp;#34;  android:layout_height=&amp;#34;100dp&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;  app:round=&amp;#34;0.5dp&amp;#34;  app:saturation=&amp;#34;0.1&amp;#34; /&amp;gt;  コントラスト contrast属性から設定することが出来ます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView  android:id=&amp;#34;@+id/image&amp;#34;  android:layout_width=&amp;#34;100dp&amp;#34;  android:layout_height=&amp;#34;100dp&amp;#34;  app:contrast=&amp;#34;0.5&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;  app:round=&amp;#34;0.5dp&amp;#34; /&amp;gt;  暖色、寒色 warmth属性から、暖色、寒色？を設定することできます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView  android:id=&amp;#34;@+id/image&amp;#34;  android:layout_width=&amp;#34;100dp&amp;#34;  android:layout_height=&amp;#34;100dp&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34;  app:round=&amp;#34;0.</description>
    </item>
    
    <item>
      <title>Dagger 2.22にFactoryクラスが導入されました</title>
      <link>https://satoshun.github.io/2019/04/dagger-component-factory/</link>
      <pubDate>Sun, 07 Apr 2019 06:04:22 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/dagger-component-factory/</guid>
      <description>Dagger 2.22からComponent.Factoryクラスが導入されました。この記事では、簡単な使い方とユースケースを見ていきたいと思います。
Component.Factoryとは? 実は、Component.FactoryでやれることはComponent.Builderクラスとほぼ変わりません。
例えば、次のArticlePresenterインスタンスを生成する2つのコードは本質的にやっていることは同等です。
// Factoryを使う場合 @Component interface AppComponent {  val presenter: ArticlePresenter   @Component.Factory  interface Factory {  fun create(  @BindsInstance id: Long  ): AppComponent  } }  val component = DaggerAppComponent  .factory()  .create(50) val presenter = component.presentere  ---  // Builderを使う場合 @Component interface AppComponent {  val presenter: ArticlePresenter   @Component.Builder  interface Builder {  @BindsInstance fun bindId(id: Long): Builder  fun build(): AppComponent  } }  val component = DaggerAppComponent  .</description>
    </item>
    
    <item>
      <title>DataBindingとActivityのコンストラクタ Layout Id指定を一緒に使う</title>
      <link>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</link>
      <pubDate>Thu, 04 Apr 2019 00:46:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</guid>
      <description>JetpackのActivityとFragmentのコンストラクタに、Layout Idが指定できるようになりました。
 Activity Version 1.0.0-alpha06 Fragment Version 1.1.0-alpha06  これは、次のように使うことが出来ます。
class MainActivity : AppCompatActivity(R.layout.main_act)  class MainFragment : Fragment(R.layout.main_frag) Activityの場合は、setConentViewが。Fragmentの場合はonCreateViewがそれぞれ省略することが出来ます。
ここからが本題です。これをDataBindingと一緒に使うなら、次のようになるかなと思います。
Activityの場合 まずはActvityの例です。
// 拡張関数を定義しておく fun &amp;lt;T : ViewDataBinding&amp;gt; ComponentActivity.bindView(): T =  DataBindingUtil.bind(getContentView())!!  private fun Activity.getContentView(): View =  findViewById&amp;lt;ViewGroup&amp;gt;(android.R.id.content)[0]   // MainActivity.kt class MainActivity : AppCompatActivity(R.layout.main_act) {  private lateinit var binding: MainActBinding   override fun onCreate(savedInstanceState: Bundle?) {  super.onCreate(savedInstanceState)  binding = bindView()  .</description>
    </item>
    
    <item>
      <title>OkHttp: Java to KotlinのPRを見て勉強する</title>
      <link>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</link>
      <pubDate>Sun, 24 Mar 2019 02:36:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</guid>
      <description>OkHttpがKotlin化をするというISSUEが立てられました。 Upgrade OkHttp 3 to Kotlin and call it OkHttp 4
これの是非についてはさておき。現状、いくつかのJavaコードがKotlinへと置き換わっているので、それらのレビューで気になったこと、知らなかったこと、忘れがちなことを勉強がてらまとめたいと思います。
checkNotNullを使うかどうか could also be code no preference myself
Kotlinの標準ライブラリに、checkNotNullがあります。 これは、値がnullならIllegalStateException例外を投げるものです。
以下のコードは同じ意味を持ちます。
val state = someState ?: throw IllegalStateException(&amp;#34;State must be set beforehand&amp;#34;)  val state = checkNotNull(someState) { &amp;#34;State must be set beforehand&amp;#34; } ただ、no preference myselfと言っている通り、使うかどうかはプロジェクトで分かれそうです。 事前に使うかどうかを、決めておくと揉めなく良さそうだと思いました。
命名はto***が慣用的 idiomatic naming would be toUrl on the Kotlin side
OkHttpでは、HttpUrlをURLに変換するためのメソッドとしてfun url(): URLが定義されています。しかし、fun toUrl(): URLのほうがKotlinっぽいよと指摘がありました。
確かに、言われてみるとAtoBクラス変換のメソッド名は、to***が多い気がします。ただし、今回は下位互換を保つために、一旦この修正は入りませんでした。
constを使う discussion link
constを使うと、Compile Time Constantsとなり、付けない場合に比べ効率的に動作します。ただし、プリミティブか、String型のみに有効です。</description>
    </item>
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、 どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。
以下、2019年3月10日 2019年3月11日の調査結果になります。 また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。
Lifecycle
// Lifecycleに従うCoroutineScopeの生成 val Lifecycle.coroutineScope: CoroutineScope LifecycleOwner
// LifecycleOwnerに従うCoroutineScopeの生成 val LifecycleOwner.lifecycleScope: CoroutineScope ViewModel
// ViewModelに従うCoroutineScopeの生成 val ViewModel.viewModelScope: CoroutineScope WorkManager
abstract class CoroutineWorker(  appContext: Context,  params: WorkerParameters ) : ListenableWorker(appContext, params) {  // suspendメソッドで定義された  abstract suspend fun doWork(): Result } Room
// Dao内でsuspendメソッドが使える @Dao interface HogesDao {  @Insert  suspend fun add(hoge: Hoge)   @Query(&amp;#34;SELECT * FROM hoge WHERE id = :id&amp;#34;)  suspend fun get(id: String): Hoge   .</description>
    </item>
    
    <item>
      <title>Dagger2: ProvidesはKotlin extension methodと一緒に使うことが出来る</title>
      <link>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</link>
      <pubDate>Tue, 05 Mar 2019 00:10:42 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</guid>
      <description>Dagger2のちょっとしたtipsです。
次の2つのメソッドは同じ振る舞いをします。
@Module class MainActivityModule {  // 普通の書き方  @Provides fun provideMainContractView(activity: MainActivity): MainContract.View {  return activity  }   // 拡張関数を使った書き方  @Provides fun MainActivity.provideMainContractView(): MainContract.View {  return this  } } なぜなら、拡張関数はコンパイルされると次のように解釈されるためです。
...  @Provides  @NotNull  public final MainContract.View provideMainContractView(@NotNull MainActivity $receiver) {  Intrinsics.checkParameterIsNotNull($receiver, &amp;#34;receiver$0&amp;#34;);  return (MainContract.View)$receiver;  } ... 拡張関数として定義したMainActivityは$receiverとなり、引数に入っていることが分かります。拡張関数は上記のように解釈されるため、@Providesと組み合わせて使うことが出来ます。
まとめ 多分、使い所ないと思います😃😃😃</description>
    </item>
    
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。
Issueの内容 実際のIssueは HandlerScheduler.scheduleDirect supports async option? になります。
Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これはWorker.scheduleのスケジュールからのみのサポートでした。RxJavaではScheduler.scheduleDirectでもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。
そもそもこの問題に気づいたきっかけ RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。
調べ方 クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。
結果、Observable.observeOnではWorker.scheduleメソッドでタスクのスケジューリングをし、Maybe.observeOnではScheduler.scheduleDirectメソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。
その他・感想 JakeさんとZacさんにレビューをしてもらった 二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃</description>
    </item>
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。 まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、AndroidJUnit4ランナーが使えるなど、かなりの部分が共通化出来ます。
この記事では、ユニットテストでActivity.onActivityResultのテストをどこまでandroid testのように書けるかを検証します。
テスト対象コード まず最初に、テスト対象コードは次のようになっています。
class MainActivity : AppCompatActivity() {  ...  override fun onCreate(savedInstanceState: Bundle?) {  ...   button.setOnClickListener {  startActivityForResult(  Intent(this, Sub2Activity::class.java).apply {  putExtra(&amp;#34;fuga&amp;#34;, &amp;#34;hoge&amp;#34;)  },  1  )  }  }   override fun onActivityResult(  requestCode: Int,  resultCode: Int,  data: Intent?  ) {  super.onActivityResult(requestCode, resultCode, data)  if (requestCode == 1) {  if (resultCode == Activity.</description>
    </item>
    
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>マルチモジュール遷移方法Part2です。Part1はここになります😌
Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。
また、今回の検証に用いたコードはsatoshun/MultiModuleNavigationComponentExampleにあります。
モジュール構成について 細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。
 各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。
このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。
では、実装に入っていきます。今回はDagger2を使って実装をします。
featureモジュール側の遷移用インターフェースの定義 前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。
main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。
interface MainModuleRouter {  // sub1画面へ移動する  fun routeToSub1() } Mainモジュール用のインターフェースなので、MainModuleRouterという名前にし、sub1画面へ遷移するためのメソッドを定義しています。
そしてこのインターフェースを、MainFragmentで使います。
class MainFragment : Fragment() {  @Inject lateinit var moduleRouter: MainModuleRouter   ...   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {  super.onViewCreated(view, savedInstanceState)   view.findViewById&amp;lt;View&amp;gt;(R.id.route).setOnClickListener {  moduleRouter.routeToSub1()  }  } } これでfeatureモジュールでの遷移用インターフェースの定義は完了です。
次にこのインターフェースの実装をします。
routerモジュール側の遷移用インターフェースの実装 今回は、遷移用インタフェースの実装をrouterモジュールで行います。まずは、Navigation Componentを用いて、Graphを作ります。
&amp;lt;navigation xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;  xmlns:app=&amp;#34;http://schemas.</description>
    </item>
    
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）
例えば、以下のモジュール構成を考えます。
 頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。
そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。
 途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。
ただし、いくつか条件があります。
1. 中間モジュールで公開可能なものに限る 例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。 これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。
中間モジュールのコードイメージとしては以下のようになります。
fun createUserFragment(userName: String, age: Int): Fragment {  return UserFragment.createFragment(userName, age) }  fun createUserIntent(context: Context): Intent {  return Intent(context, UserActivity::class.java) } UserActivity、UserFragmentが公開されていないことが分かります。Androidのいわゆるfeatureモジュールでは、Activity、Fragmentを公開する場合が多いと思うので、その場合には有効に使うことができます。
2. implementationで依存を定義する apiを使うと、依存が推移するため再ビルドが行われてしまうためです。implementationで依存を記述する必要があります。
3. Dagger2使ってると多分無理 Dagger2では、解決する依存をAppComponentで知っている必要があります。上記の構成だと、appでAppComponentを持つことになるので、appからsub1、sub2が見えていないと最終的にDagger2で解決できません。なので、中間モジュールで、appからsubの依存が見えなくなるこのパターンは使えません。
詳しくはDagger/#970にあります。
まとめ  やりすぎ感はある  ただでさえ複雑な、モジュール構成がさらに煩雑になりそう。ただし、最終的には消えるので、差分ビルドの恩恵を受けるためのステップだとすれば許せるかも? Dagger2を使っていると推移的依存が必要になり、使えない、もしくは工夫が必要になる   サンプルはsatoshun/ApplicationModulesSpeedUpExampleにあります  サブモジュールを変更したときのビルドは爆速でした😊    Daggerの部分のいい解決方法を知っている人がいたら、教えて頂けると幸いです😊😊😊</description>
    </item>
    
    <item>
      <title>DroidKaigi2019で「R8/ProGuard 徹底比較」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2019/02/droidkaigi-2019/</link>
      <pubDate>Thu, 07 Feb 2019 13:19:13 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/droidkaigi-2019/</guid>
      <description>DroidKaigi2019でセッションが採択されたので発表しました。
 https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao
 最初に発表の反省点です。
 多く詰め込みすぎて、1つ1つの掘り下げが疎かになった  結果的に広く浅い発表になってしまったため、1つの1つがあまり丁寧に説明できていなかったように感じています。重要な部分はもう少し丁寧に発表すべきでした。   早口すぎ、俺は生き急いでるのか？  本当に申し訳ありませんでした。前日に最終確認したところ20分近くオーバーしてしまい、そこからある程度は間引いたんですが、早口でいくという戦略を取ってしまいました😂 他の方の発表のように聞きやすい発表を今後は意識していきます！     次に良かった点です。
 発表前の休憩時間に、司会の@neonankitiさんの助けで、アイスブレイク?のようなことができた  @neonankitiさんとは初対面だったんですが、謎の掛け合いができ、会場の雰囲気も良くなったように思います😊   なんだかんだとR8のコードを触れたのは良かった  R8コンパイラのコードに触れるかどうか悩んだのですが、printデバッグなどを駆使して、理解が間違っていないことが確認できたので、載せてみました。概要だけですが、個人的には良かったと思っています。   最後に話した実践編のウケが良くてよかった  R8の凄さが分かりやすく伝えられたのかなと思います😊     最後に、僕の発表を聞きに来てくれた人、運営のみなさんありがとうございました😊
また来年もあれば登壇できるように頑張ります💪</description>
    </item>
    
    <item>
      <title>R8/Proguard: JarファイルからProGuard設定ファイルを読み込んでくれるようになりました</title>
      <link>https://satoshun.github.io/2019/01/r8-proguard-metainf/</link>
      <pubDate>Mon, 28 Jan 2019 00:08:35 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-proguard-metainf/</guid>
      <description>AGP3.3.0ProGuardはAGP3.3.0、R8は導入されたAGP3.2.0から、JarファイルのProGuard設定ファイルを組み込めるようになりました。その機能紹介です。 今まで、aarではconsumerProguardFilesで、ライブラリのProGuard設定を指定できました。それのJar、Javaバージョンとなります。
ライブラリ開発者側の設定 RetrofitなどのSquare社のライブラリでは、早くもこの機能に対応しているので、それを例にして説明します。
まず、resources/META-INF/prougardディレクトリの中にProGuardの設定ファイルを置きます。
square/retrofit
ライブラリ側の設定はこれで完了です。
使う側の設定 AGP3.3.0にアップデートするだけで使えます。META-INF/ProGuardはRetrofitの2.5.0から入っているので、まずはMETA-INFが入っていない、2.4.0でビルドをしてみます。
implementation &amp;#34;com.squareup.retrofit2:retrofit:2.4.0&amp;#34; &amp;gt; ./gradlew installRelease ... Warning: there were 267 unresolved references to classes or interfaces. You may need to add missing library jars or update their versions. If your code works fine without the missing classes, you can suppress the warnings with &amp;#39;-dontwarn&amp;#39; options. (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedclass) Warning: Exception while processing task java.io.IOException: Please correct the above warnings first. Thread(Tasks limiter_2): destruction 失敗しました😂</description>
    </item>
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。
結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂
また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。
Room in memory? Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。
使い方は次のようになります。
Room  .inMemoryDatabaseBuilder(context, MyDatabase::class.java)  .build() in memoryを使う理由としては、
 ディスパッチするアクションを永続化する必要はないだろう マイグレーションが必要ない  になります。
実装に入っていく では、実装の説明をしていきます。
まずはActionをRoomのEntityとして定義します。
sealed class AuthorAction  @Entity(tableName = &amp;#34;author1&amp;#34;) data class Author1(  @PrimaryKey val _id: Long = 0, // always 0  val name: String,  val age: Int ) : AuthorAction()  @Entity(tableName = &amp;#34;author2&amp;#34;) data class Author2(  @PrimaryKey val _id: Long = 0, // always 0  val name: String,  val age: Int ) : AuthorAction() Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、@PrimaryKey(autoGenerate = true)を使っても良いと思います。</description>
    </item>
    
    <item>
      <title>R8/Proguard: Daggerの生成コードがR8でどのように変わるかを見る</title>
      <link>https://satoshun.github.io/2019/01/r8-dagger-optimize/</link>
      <pubDate>Sun, 20 Jan 2019 13:55:46 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-dagger-optimize/</guid>
      <description>コードの最適化の話です。この記事では実践に寄せて、Daggerの生成コードがR8によってどのように変化するかを見ます。
まずはサンプルコードです。
@Component(  modules = [  AppModule1::class,  AppModule2::class  ] ) interface AppComponent {  @Component.Builder  interface Builder {  fun build(): AppComponent  }   fun inject(activity: MainActivity) }  @Module class AppModule1 {  @Provides  fun provideService(): AppService {  val retrofit = Retrofit.Builder()  ...  return retrofit.create()  } }  @Module object AppModule2 {  @JvmStatic  @Provides  fun provideService2(): AppService2 {  val retrofit = Retrofit.</description>
    </item>
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。
Kotlin lambda Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。
例えば、次のコードを最適化なしでコンパイルしてみます。
fun main() {  lambdaTest1 { println(&amp;#34;Kotlin lambda1&amp;#34;) }  lambdaTest1 { println(&amp;#34;Kotlin lambda2&amp;#34;) }  lambdaTest1 { println(&amp;#34;Kotlin lambda3&amp;#34;) }  ... }  private fun lambdaTest1(body: () -&amp;gt; Unit) {  ...  body()  ... } // コンパイル後 public static final void main() {  LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE);  LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE);  LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE);  ... }  final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {  public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1();   LambdaTestKt$main$1() {  super(0);  }   public final void invoke() {  System.</description>
    </item>
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。
この記事は、R8 Optimization: Staticizationにとても影響を受けています。
Companion object 例えば、次のコードがあるとします。
class CompanionTest {  companion object {  fun show(i: Int) {  ...  }  } } これを最適化なしで変換すると次のようになります。
public final class CompanionTest {  public static final Companion Companion = new Companion();   public static final class Companion {  private Companion() {  }   public final void show(int i) {  ...  }  } } Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。</description>
    </item>
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>コードの最適化の話です。この記事ではClass Mergingについて紹介します。
Class Merging? その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。 Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。
まずは縦方向のClass Mergingについて説明します。
縦方向? 縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。
例えば、次の実装は最適化によって1つにまとめられます。
interface IVertical {  fun show(i: Int) }  class Vertical(  private val a: Int ) : IVertical {  override fun show(i: Int) {  println(&amp;#34;start called $i$a&amp;#34;)  } } &amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;
public final class Vertical {  ...   public final void show(int i) {  ...  } } IVerticalインターフェースが見事に消されていることが分かります。
また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。</description>
    </item>
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>Dependency injection in a multi module projectを見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。
結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。
また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。
検証に用いたコードはsatoshun-android-example/DynamicFeatureDaggerExampleにあります😊
前提知識 通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。 ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。
   この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。
   そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。
ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。
実装 Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。 実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。
では、実装を始めます。
最初に、SubActivityをDaggerApplicationのように振る舞わさせるためにModuleRootActivityクラスを定義します。 それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。
abstract class ModuleRootActivity : AppCompatActivity(),  HasModuleInjector {  @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt;   private lateinit var injector: ModuleActivityInjector   override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>dexdumpメモ</title>
      <link>https://satoshun.github.io/2019/01/reading_dexdump_result/</link>
      <pubDate>Sat, 05 Jan 2019 02:15:50 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/reading_dexdump_result/</guid>
      <description>Android build-toolsにはdexdumpというdexファイルを逆アセンブルするツールがあります。 逆アセンブルしたファイルを読みたかったのでそれのメモです。
内容はまとまっていません。自分用のメモレベルの記事になります。
dexファイルをコマンドから作るにはjavacとd8コマンドを使います。d8コマンドは https://r8.googlesource.com/r8 の手順通りにビルドします。
javac *.java // or kotlinc *.kt java -jar $R8_HOME/build/libs/d8.jar --lib $ANDROID_HOME/platforms/android-28/android.jar --release *.class d8コマンドで出来たdexファイルをdexdumpで逆アセンブルします。
$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex 例えば次のJavaコードを逆アセンブルしてみます。
class Test {  public void main() {  show(1, 10.0);  String[] array = {&amp;#34;&amp;#34;};  toggle(array);  fade();  drag();  hide();  click();  hover();  }   public String show(int a, double d) {  System.out.println(a);  return &amp;#34;showed&amp;#34;;  }   void toggle(String[] args) {  System.</description>
    </item>
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>Androidのトレンドの1つにマルチモジュール構成があります。 マルチモジュールによるメリットとして、
 ビルド時間の短縮 依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる  などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。
この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、
 型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい コード量を減らしたい  Part1では、遷移専用のモジュールを作る方法を考えてみます。
サンプルコード: satoshun-android-example/MultiActivityRouterExample
遷移専用のモジュールを作る まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。
例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。
 メインではサブ画面が必要なのでサブモジュールに依存する サブではメイン画面が必要なのでメインモジュールに依存する     これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。 直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。
そこで、
 メイン画面に遷移するメインルーターモジュール サブ画面に遷移するサブルーターモジュール  の2つのモジュールを作ります。
メインルーターモジュールでは次の遷移専用インターフェースを定義します。
interface MainRouter {  fun routeToMain(context: Context): Intent } そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。
internal class MainRouterImpl @Inject constructor() : MainRouter {  override fun routeToMain(context: Context): Intent {  return Intent(context, MainActivity::class.java)  } }  ---  @Module internal interface MainActivityModule {  @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter } これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。</description>
    </item>
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、ContinuationInterceptorを使えば上手くいきそうです。
ContinuationInterceptorとは? ContinuationInterceptorは次のようなインターフェースです。
/** * Marks coroutine context element that intercepts coroutine continuations. * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and * intercepts all coroutine continuations with [interceptContinuation] invocations. */ @SinceKotlin(&amp;#34;1.3&amp;#34;) public interface ContinuationInterceptor : CoroutineContext.Element {  public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;  public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;)  ... } interceptContinuationからContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。
class LifecycleContinuationInterceptor(  private val lifecycle: Lifecycle ) : ContinuationInterceptor {  override val key: CoroutineContext.</description>
    </item>
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>この記事ではFragmentでLiveDataにObserverを登録するときはFragment#getViewLifecycleを使うと良いという話をします。
まず、Fragmentのおおまかなライフサイクルは次のようになっています。
 onAttach onCreate  onCreateView onViewCreated  &amp;hellip;   onDestoryView   onDestroy onDetach  ここで重要なのは、onDestroyが呼ばれることなく、複数回onCreateViewが呼ばれる可能性がある点です。
例えば、次のコードは間違っている可能性があります。
class MainFragment: Fragment() {  ...  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {  super.onViewCreated(view, savedInstanceState)  viewModel.data.observe(this, Observer {  ...  })  } } なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。 このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。 しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。
前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。 よって、FragmentにはView用のLifecycleが用意されています。それが、Fragment#getViewLifecycleです。
前述のコードは次のように書くことが出来ます。
class MainFragment: Fragment() {  ...  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {  super.onViewCreated(view, savedInstanceState)  // ViewのLifecycleOwnerを渡す  viewModel.</description>
    </item>
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃
基本編 一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。
例えば、次のコードは間違っています。
class MainViewModel @Inject constructor(...): ViewModel()  class MainActivity {  @Inject lateinit var viewModel: MainViewModel   ... } この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。
class MainViewModel(...): ViewModel()  @Module class MainActivityModule {  @Provides  fun provideMainViewModel(...) : MainViewModel {  // ViewModelProviderを使ってインスタンスを生成する  return ViewModelProviders.of(...).get(MainViewModel::class.java)  } }  class MainActivity {  @Inject lateinit var viewModel: MainViewModel   ... } @Providesを使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。
また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。 このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。</description>
    </item>
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>JitPackからライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。 詳しくは次のリンクを参照してください。A Confusing Dependency
従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に Matching repositories to dependencies が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）
まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、cloudflareのSDKを依存関係に入れることを目指します。 また、今回の検証にはGradle 5.1-rc-1を使いました。サンプルコードはここにあります
まずは従来の書き方です。
// topのbuild.gradle allprojects {  repositories {  ...   maven {  url &amp;#34;https://storage.googleapis.com/cloudflare-maven/public/&amp;#34;  }  } }  ---  // projectのbuild.gradle dependencies {  ...   implementation &amp;#34;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;#34; } これだと全てのライブラリに対して、repositoriesで指定したhttps://storage.googleapis.com/cloudflare-maven/public/へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。
次に新機能を使った書き方です。
// topのbuild.gradle allprojects {  repositories {  ...   maven {  url &amp;#34;https://storage.googleapis.com/cloudflare-maven/public/&amp;#34;  content {  // group idがcom.</description>
    </item>
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>TruthはGoogleが開発をしているテストアサーションライブラリです。
従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。
 readableにアサーションが書ける デフォルトの失敗メッセージがわかりやすい  それぞれについて説明していきます。
readableにアサーションが書ける ドキュメントのbenefitにあるサンプルを取り上げ説明します。 http://google.github.io/truth/benefits
まず従来のJUnitスタイルを使って書きます。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertFalse(middleName.isPresent()); assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）
これがTruthを使うと次のようになります。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertThat(middleName).isAbsent(); assertThatはTruthに定義されているメソッドです。middleNameがabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。
上記のisAbsentはOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。 例えばIterableには、containsAnyInやisEmptyなどが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。
失敗メッセージがわかりやすい こちらもbenefitにあるサンプルを取り上げます。
まずは従来にJUnitスタイルから。
assertTrue(googleColors.contains(PINK)); この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。 失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。
次にTruthスタイルです。
assertThat(googleColors).contains(PINK); &amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。
以上がTruthのメリットになります。
補足 Truth-Androidライブラリ JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。 例えば、Intentには以下のアサーションメソッドを使うことが出来ます。
hasComponent hasComponentClass hasComponentPackage hasPackage hasAction hasNoAction hasData hasType extras categories hasFlags Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。
AssertJとの比較 これも公式ドキュメントにまとめてあります。http://google.github.io/truth/comparison
現状の主だった差分は次のようになっています。
 Truhtはまだ1.0.0になっていないのでAPIが変わる可能性がある TruthはChainスタイルで書くことを想定していない  これは現状のTruth哲学だが、AssertJのようなChainスタイルも普及してきたので、どちらが便利かはわからない    多少の差異はあれど、AssertJとTruthはとても似ているライブラリです。どちらか一方を使っているなら、乗り換えるメリットはおそらくないだろうという旨の内容です。</description>
    </item>
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングでnamespacedRClassフラグが新しく追加されたので紹介します。 本記事では3.4.0-alpha07で試しました。
まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。 それを解決するためにnamespacedRClassが追加されました。使い方は簡単で、次の記述をgradle.propertiesに追加するだけです。
android.namespacedRClass=true では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。 例として、appcompatに依存しているライブラリモジュールを用意します。
まずは、namespacedRClass=falseの時のRクラスです。
public final class R {  private R() {}   public static final class anim {  private anim() {}   public static final int abc_fade_in = 0x7f010000;  public static final int abc_fade_out = 0x7f010001;  public static final int abc_grow_fade_in_from_bottom = 0x7f010002;  public static final int abc_popup_enter = 0x7f010003;  ...  ... 依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。
では次に、namespacedRClass=trueの時です。</description>
    </item>
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>注意 この記事はapiとimplementationの説明をする類の記事ではありません。
GradleでcompileがDeprecatedになり、implementationまたはapiを使うことが推奨されています。 それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。
Dagger2でもcompileをimplementationに置き換えるPRが出されました。https://github.com/google/dagger/pull/1130
内容が興味深かったのでまとめてみようと思います。
まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。
// Add Dagger dependencies dependencies { - compile &amp;#39;com.google.dagger:dagger:2.x&amp;#39; + implementation &amp;#39;com.google.dagger:dagger:2.x&amp;#39; annotationProcessor &amp;#39;com.google.dagger:dagger-compiler:2.x&amp;#39; } - compile &amp;#39;com.google.dagger:dagger-android:2.x&amp;#39; - compile &amp;#39;com.google.dagger:dagger-android-support:2.x&amp;#39; // if you use the support libraries + implementation &amp;#39;com.google.dagger:dagger-android:2.x&amp;#39; + implementation &amp;#39;com.google.dagger:dagger-android-support:2.x&amp;#39; // if you use the support libraries ここでjakeさんが
 I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.</description>
    </item>
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。
それが3.4.0-alpha07以降で改善される見込みです🎉
詳細はここにあります。https://issuetracker.google.com/issues/116541301
この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。
サンプルコードはここにあります😃
エラーログの変化 まずどのようなエラーログが出力されるかを見ていきます。 適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。
まずはData Binding 3.2.1から。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root, ^ symbol: class DataBindingComponent location: class MainAct79Binding e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol boolean attachToRoot, @Nullable DataBindingComponent component) { ^ ... ... ... Data Binding周りのエラーログが無限に出ます。悲しい😂
次に3.4.0-alpha07です。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass() ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃
クライアント側の対応 これに伴い、一部APIがdeprecatedになります。例えば、main_act.</description>
    </item>
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>注意: 計測方法は実環境に全く即していないので意味がない可能性が高いです。
環境  AGP3.4.0-alpha06 Kotlin 1.3.10 Kotlinx.coroutine 1.0.1 Gradle 5.0  比較対象  kotlinx.coroutineを使ったサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている  300 * 7の2100箇所がCoroutine関連のコードになります     kotlinx.coroutineを使わないサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中で適当なメソッド（Handler().post {}）をコールしている   サンプルコード  計測コマンド Build Scanを使って計測します。その際。build-cacheはoffにします。
./gradlew clean ./gradlew build --no-build-cache --scan 両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。 また試行回数は10回程度で、最終結果のみを以下に掲載します。
kotlinx.coroutineを使う Time spent executing tasks 1m 16.034s All tasks	207	2m 42.833s Tasks avoided	12 (09.7%)	0.062s From cache	0 (00.0%)	0.</description>
    </item>
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>LiveDataの値を更新したい時、MutableLiveDataを使うのが一般的だと思います。
class MainViewModel {  val hoge = MutableLiveData&amp;lt;Int&amp;gt;() } この書き方だと、外のクラスから値を更新することが可能です。
val viewModel = MainViewModel()  // ok viewModel.hoge.postValue(10000) 外のクラスからは更新出来ないようにするためにはLiveDataに型変換する必要があります。
例えば次のように書きます。
class MainViewModel {  private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;()  val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換 } こうすることで、外のクラスからはMutableLiveDataが直接見えなくなり、明示的に型変換をしない限りLiveDataの値を更新できなくなります。
ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。 なので、それの解決策を以下で紹介します。
その1 まずコードをのせます。
abstract class ViewModel2 {  protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) {  postValue(value)  }   protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) {  setValue(value)  } } // ViewModel2と同じパッケージに定義 public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; {  @Override  protected void postValue(T value) {  super.</description>
    </item>
    
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>Retrofit 2.5.0からカスタムアノテーションが使えるようになったので、それの紹介です。
例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。
まず最初にアノテーションを定義します。
annotation class RequireAuth 次に、上記で定義したアノテーションを使い、Apiを定義します。
interface ApiService {  @RequireAuth  @GET(&amp;#34;login&amp;#34;)  fun login(: retrofit2.Call&amp;lt;Unit&amp;gt; } 次に、RequireAuthを処理するためのokhttp3.Interceptorを定義します。
class AuthInterceptor : Interceptor {  override fun intercept(chain: Interceptor.Chain): Response {  var request = chain.request()   val invocation = request.tag(Invocation::class.java)  val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)  if (authAnnotation != null) {  request = request  .newBuilder()  .addHeader(&amp;#34;Authorization&amp;#34;, &amp;#34;Basic AAAAA&amp;#34;).build()  }  return chain.proceed(request)  } } ここでのポイントは、val invocation = request.</description>
    </item>
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、 そんな夢をみたAndroidエンジニアは数多くいると思います。
この記事ではそんな夢を叶える方法を紹介します。
サンプルコードはここにあります。
FragmentFactory Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。
class MainFragment : Fragment() {  @Inject lateinit var userHandler: UserHandler  ... } これをコンストラクタインジェクションにしたい。
class MainFragment @Inject constructor(  private val userHandler: UserHandler ) : Fragment() {  ... } androidx.fragment:fragment:1.1.0-alpha01から、FragmentFactoryが追加されました!! これを使うことでコンストラクタインジェクションが可能になります。
MainFragmentインスタンスを生成するFragmentFactoryを作成します。
class MainFragmentFactory @Inject constructor(  private val fragment: Provider&amp;lt;MainFragment&amp;gt; ) : FragmentFactory() {  override fun instantiate(  classLoader: ClassLoader,  className: String,  args: Bundle?  ): Fragment {  if (className == MainFragment::class.</description>
    </item>
    
    <item>
      <title>Android: デバッグ時にMoshi、Daggerリフレクションライブラリを使いビルド時間を短縮する</title>
      <link>https://satoshun.github.io/2018/11/debug_reflection/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/debug_reflection/</guid>
      <description>ビルド時間の短縮は開発効率を上げる大きな要素です。 極力kapt（アノテーションプロセッサー）を使わなくすることで、ビルド時間を短縮出来ます。 アノテーションプロセッサーを使ったライブラリは、アノテーションプロセッサーを使わない、 リフレクションを用いたデバッグ用の機能を提供していることがあります。
今回は、MoshiとDaggerリフレクションライブラリの紹介をします。 Daggerリフレクションは絶賛開発中 + 公式ではないので、機能がかなり制限されている、どういう未来が待っているかわからない点に注意してください。
検証に用いたサンプルコードはここにあります。
Moshiリフレクション Moshiにはmoshi-codegenと呼ばれる、アノテーションプロセッサーでコード生成してくれるライブラリがあります。 これは実行時のパフォーマンスには優れているのですが、アノテーションプロセッサーを使っているため、ビルドに時間がかかってしまいます。
そこで、Moshiではmoshi-reflectionと呼ばれるライブラリを提供しており、これはアノテーションプロセッサーを使うことなく、 moshi-codegenと同等の機能を提供してくれます。 ただし、moshi-reflectionは内部でリフレクションを使っているため、実行時のパフォーマンスには優れていません。あくまでデバッグ用、という立ち位置だと思います。
デバッグ時にmoshi-reflectionを使い、リリース時にmoshi-codegenを使うことで、ビルド速度と実効速度の天秤を勝ち取ることが出来ます。
具体的には、デバッグ時、リリース時にbuild.gradleで指定するライブラリを、Moshiに登録するAdapterを変更します。
// bulid.gradle  implementation &amp;#34;com.squareup.moshi:moshi:1.8.0&amp;#34; debugImplementation &amp;#34;com.squareup.moshi:moshi-kotlin:1.8.0&amp;#34; kaptRelease &amp;#34;com.squareup.moshi:moshi-kotlin-codegen:1.8.0&amp;#34; // debug時 fun createMoshiBuilder() = Moshi.Builder()  .add(KotlinJsonAdapterFactory()) // KotlinJsonAdapterFactoryを指定する  .build()  // release時 fun createMoshiBuilder() = Moshi.Builder()  .build() このように書くことで、リリース時のみkaptを実行するようになります。
Daggerリフレクション これはSdkSearch内で開発が行われているライブラリです。有名なAndroidエンジニアであるJake Whartonさんが開発をしています。
これもMoshiと同様に、リフレクションを使っています。 Daggerリフレクションでは、必要最低限のクラスはアノテーションプロセッサーで作成するようになっています。 アノテーションプロセッサーの完全除去というわけではありません。例えば、アノテーションプロセッサーでDaggerAppComponentは作られます。 しかし、かなりの数のクラスを作成しないようになっています。
具体的なコードは、以下のようになります。 Mavenにアップデートされていないので、SdkSearchからソースコードをコピーして使います。
implementation &amp;#34;com.google.dagger:dagger:2.18&amp;#34; debugImplementation project(&amp;#39;:dagger-reflect:reflect&amp;#39;) // SdkSearchからコピー kaptDebug project(&amp;#39;:dagger-reflect:reflect-compiler&amp;#39;) // SdkSearchからコピー kaptRelease &amp;#34;com.google.dagger:dagger-compiler:2.18&amp;#34; デバッグ時にはDaggerリフレクションを使い、リリース時にはdagger-compilerを使っています。 変更差分はbuild.</description>
    </item>
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description>ふとAACのViewModelのonClearedメソッドをテストしたくなったので、 3つのやりかたを紹介します。
環境は
&amp;#34;junit:junit:4.12&amp;#34; &amp;#34;androidx.test:rules:1.1.1&amp;#34; &amp;#34;androidx.test:runner:1.1.1&amp;#34; &amp;#34;androidx.test.ext:junit:1.1.0&amp;#34; &amp;#34;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;#34; &amp;#34;org.robolectric:robolectric:4.1&amp;#34; になります。
また、サンプルコードは satoshun-android-example/Testsにあるので、参考してください😊
1. ViewModelStoreを使う ViewModelProviders.of(activity).get(class)からViewModelを取得したときに、取得したViewModelはViewModelStoreにキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。
@RunWith(AndroidJUnit4::class) class BaseViewModelTest {  @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java)   @Test  fun `dispose a coroutine when finished lifecycle of ViewModel`() {  activityRule.activity.viewModelStore.clear() // ViewModelが開放される  } } このテストはコード的には簡単ですが、ViewModelStoreがViewModelを管理していることを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。
なので、素直にonDestroyをコールするテストも書いてみます。
2. Instrumentation.callActivityOnDestroyを使う Instrumentationクラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。 InstrumentationはInstrumentationRegistryクラスから取得することができ、次のように書くことで、onDestroyをコールすることができます。
@Test fun `dispose a coroutine when finished lifecycle of ViewModel 2`() {  // onDestroyがコールされViewModelが開放される  InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity) } ActivityのonDestroyがコールされ、ViewModelのonClearedもコールされます！</description>
    </item>
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>（この記事は1.3-M2を使っています。）
Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。
例えば、次のように書くことが出来ます。
inline class UserId(val id: String) {  val url get() = &amp;#34;http://$id&amp;#34; }  val userId = UserId(&amp;#34;user-dayo&amp;#34;) println(userId.url) このコードは一見、UserIdインスタンスが生成されそうです。 しかし、コンパイルされたコードではUserIdインスタンスは生成されません。
public static final class UserId$Erased {  ...   @NotNull  public static final String getUrl(String $this) {  return &amp;#34;http://&amp;#34; + $this;  }   ... }  String userId = &amp;#34;user-dayo&amp;#34;; String var1 = UserId$Erased.getUrl(userId); System.out.println(var1); UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成されたUserId$Erasedクラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。
ここからが本題です。 Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。</description>
    </item>
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>みなさんこんにちは
今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として@Inject lateinit var になってしまうところがあると思います。
class HogeActivity {  @Inject lateinit var hoge: Hoge } これをなんとか出来ないかなと思って考えてみました。
結論から言うと最終形はこのようになります。
class HogeActivity {  private val hoge: Hoge by inject() } private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。
今回はIntoMapを使って実装することにしました。
IntoMapとはその名の通りMapにバインドするためのアノテーションです。 詳しくはドキュメントを見てください。
サンプルコードで説明していきます。
まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。
@Module interface HogeModule {  @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any  @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any }  class Hoge1 @Inject constructor() class Hoge2 @Inject constructor()  @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) @MapKey annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;) Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。</description>
    </item>
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これはMessage#setAsynchronousを使うことで、UIのパフォーマンス向上を狙った機能です。 下のリンクに詳細な内容が書かれています。
RxAndroid’s New Async API
この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。
検証に使用したサンプルプロジェクトは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample
サンプルプロジェクトをかいつまんで説明します。
まず2つのスケジューラを作成し、
private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false) private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true) 作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。
// asyncがfalseの場合 Observable  .fromCallable { System.currentTimeMillis() }  .delay(index, TimeUnit.MILLISECONDS)  .observeOn(mainScheduler)  .subscribe(...)  // asyncがtrueの場合 Observable  .fromCallable { System.currentTimeMillis() }  .delay(index, TimeUnit.MILLISECONDS)  .observeOn(asyncMainScheduler)  .subscribe(...) フルコードは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt
結果は、以下のようになりました。
// API27 エミュレータ main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和 main=130857ms, async=126582ms main=131401ms, async=126909ms main=130763ms, async=126504ms main=132758ms, async=127972ms // API21 エミュレータ main=129869ms, async=125795ms main=130050ms, async=125888ms main=129935ms, async=125853ms main=129908ms, async=125838ms main=129927ms, async=125824ms asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。</description>
    </item>
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>Dagge 2.17でfastInitオプションが追加されました。 https://google.github.io/dagger/compiler-options
これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。
確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。
確認に使用したシェルスクリプト adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。
for i in {0..10} do  adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt  sleep 10 done 下記を参考にしました。
 https://developer.android.com/topic/performance/vitals/launch-time  fastInit有効の場合 下記をbuild.gradleに追加します。
kapt {  javacOptions {  option(&amp;#34;-Adagger.fastInit=enabled&amp;#34;)  } } 結果:
平均: 1609ms fastInit無効の場合 結果:
平均: 1607ms まとめ ほぼ変わらない数字が出てきてしまいました。悲しい。 Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。
芳しくない結果になった推測として
 担当アプリのDaggerの書き方が正しくないからこの結果になった?  要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず   確認に使用したコマンドが良くないのかも?  なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊</description>
    </item>
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>結論  R8/Proguardをちゃんと使う  背景 Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。
実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。
まずは、R8無しで調べてみます。
fun hoge() {  println(&amp;#34;hogehoge&amp;#34;) } 当然メソッドカウントが1増えています。
次に、inlineを付けてみます。
inline fun hoge() {  println(&amp;#34;hogehoge&amp;#34;) } こちらもメソッドカウントが1増えました。 show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。
@Metadata(  mv = {1, 1, 10},  bv = {1, 0, 2},  k = 2,  d1 = {&amp;#34;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;#34;},  d2 = {&amp;#34;hoge&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;production sources for module app&amp;#34;} ) public final class MainActivityKt {  public static final void hoge() {  String var1 = &amp;#34;hogehoge&amp;#34;;  System.</description>
    </item>
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。 この記事ではSpaceを使ったネガティブマージンの実現について説明します。
例 ネガティブマージンと同等の大きさを持ったSpaceを定義して、そこにConstraintを設定するだけです。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout  xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;  xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34;  xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;match_parent&amp;#34;  android:clipToPadding=&amp;#34;false&amp;#34;  android:padding=&amp;#34;80dp&amp;#34;&amp;gt;   &amp;lt;Space  android:id=&amp;#34;@+id/negative&amp;#34;  android:layout_width=&amp;#34;15dp&amp;#34;  android:layout_height=&amp;#34;15dp&amp;#34;  app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34;  app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt;   &amp;lt;ImageView  android:id=&amp;#34;@+id/icon&amp;#34;  android:layout_width=&amp;#34;30dp&amp;#34;  android:layout_height=&amp;#34;30dp&amp;#34;  android:contentDescription=&amp;#34;icon&amp;#34;  app:layout_constraintBottom_toBottomOf=&amp;#34;@id/negative&amp;#34;  app:layout_constraintEnd_toEndOf=&amp;#34;@id/negative&amp;#34;  tools:src=&amp;#34;@tools:sample/avatars&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;  簡単に説明すると、Spaceに15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。 上記の例だと、
 android:layout_marginStart=&amp;quot;-15px&amp;quot; android:layout_marginTop=&amp;quot;-15px&amp;quot;  と同等の振る舞いをしています。
まとめ ConstraintLayoutではネイティブでネガティブマージンに対応していないため、Spaceを使った、ややテクニカルな方法で実現するのが良いと思われます。</description>
    </item>
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。 https://kotlinlang.org/docs/reference/type-aliases.html
典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。
typealias MyHandler = (Int, String, Any) -&amp;gt; Unit さらにtypealiasは、アノテーションをつけることも出来ます。
typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt; JvmSuppressWildcardsはDagger(参考リンク)やretrofit(参考リンク)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。</description>
    </item>
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>Daggerを使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。 Androidでは、すべてのActivityで共通のインスタンスを使うには SingletonスコープとAppComponentを組み合わせて使う方法がよく知られています。 しかし、__特定__のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。Singletonだと__すべて__のActivity間で共通のインスタンスが使えてしまいます。
この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。 また、基本的なDaggerの使い方は知っている前提で説明していきます。
サンプルコードはこちらになります。 コードを見ると理解がより深まると思うので、ぜひご覧になってください😊
 では説明していきます。今回のサンプルコードの目指すところは
 UserScopeを定義し、MainActivity、UserScopedActivityで同一のUserManagerインスタンスを使用する  とします。
まず最初にUserScopeを定義します。
@Scope @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) annotation class UserScope 次にUserSubcomponentを作ります。
@UserScope @Subcomponent interface UserSubcomponent {  @Subcomponent.Builder  interface Builder {  fun build(): UserSubcomponent  }   val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; } ここでは、UserSubcomponentにUserScopeスコープを持たせています。 このように書くことで、SubcomponentとScopeを結びつけることが出来ます。
次にAppComponentを作ります。
@Singleton @Component(  modules = [  AndroidSupportInjectionModule::class  ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {  @Component.Builder  interface Builder {  @BindsInstance  fun application(application: App): Builder   fun build(): AppComponent  }   override fun inject(app: App)   // AppComponentとUserSubcomponentを結びつける  val userComponentBuilder: UserSubcomponent.</description>
    </item>
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。 ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。
このライブラリの機能に、safeargsというものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。
safeargsを使ってみる 一般的にFragmentに適当な値を渡すときはBundleを通して渡します。
// 呼び出し側 val bundle = Bundle() bundle.putInt(&amp;#34;step&amp;#34;, 10)  // 呼び出され側 val step = arguments?.getInt(&amp;#34;step&amp;#34;) これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&amp;quot;step2&amp;quot;にしてしまうと、ランタイムエラーになります。
これを解決にするためにNavigationではsafe argsという機能を提供しています。 これは、DataBindingのように、クラスを生成することでtypesafeを実現します。
&amp;lt;navigation xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;  xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34;  xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;&amp;gt;  &amp;lt;fragment  android:name=&amp;#34;com.example.android.codelabs.navigation.HogeFragment&amp;#34;  android:label=&amp;#34;Hoge&amp;#34;&amp;gt;   &amp;lt;argument  android:name=&amp;#34;step&amp;#34;  app:type=&amp;#34;integer&amp;#34;  android:defaultValue=&amp;#34;1&amp;#34;/&amp;gt;  &amp;lt;/fragment&amp;gt; &amp;lt;/navigation&amp;gt; とnavigationを記述すると、
public class HogeFragmentArgs {  private int step = 1;   private HogeFragmentArgs() {  }   public static HogeFragmentArgs fromBundle(Bundle bundle) {  HogeFragmentArgs result = new HogeFragmentArgs();  if (bundle.</description>
    </item>
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。 適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。
定義は以下のようになります。
fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; {  // skip用の初期値を入れておく  return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null } }  fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) {  // 最初の値は常にskipすることで、キャッシュを無視する  val firstIgnore = AtomicBoolean(true)  this.observe(owner, Observer {  if (firstIgnore.getAndSet(false)) return@Observer  observer(it)  }) } 使う時はこんな感じで使います。
// TestViewModel.kt class TestViewModel: ViewModel() {  val errorEvent = singleLiveData&amp;lt;String&amp;gt;() }  // TestActivity.kt testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java) testViewModel.</description>
    </item>
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description>CoroutineBindingライブラリを作ったのでその紹介です。 https://github.com/satoshun/CoroutineBinding
Android開発でCoroutineの流れが来ていると思っていて、RxBindingのような感じで、 CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。
使い方 例えばclickのイベントを受け取りたいとします。 CoroutineBindingでは以下のように書くことが出来ます。
val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root) launch(UI) {  for (click in root.clicks()) {  Log.d(&amp;#34;clicked&amp;#34;, click.toString())  } } RxBindingのように使うことが出来ます! 他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。
まとめ  Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい! https://github.com/satoshun/CoroutineBinding 何かあればissueや、PRを貰えると嬉しいです  </description>
    </item>
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description>ポエムです。
結論 基本的にローカルで明示的に型を宣言するのは好ましくない
問題 Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。
val userName = dataSource.getUserName() 型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。
Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。
まとめ  ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする  </description>
    </item>
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>問題 Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。
理由としては、Data Bindingの生成が失敗すると、MainActivityBindingみたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。 デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)
解決法 全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです
kapt {  javacOptions {  option(&amp;#34;-Xmaxerrs&amp;#34;, 5000)  } } これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。
これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。
before(一部ログ修正しています)
... // 長いエラーログ ... ... symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:91: error: cannot find symbol @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:102: error: cannot find symbol @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding :app:kaptProductDebugKotlin FAILED after</description>
    </item>
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。
例えば以下のようなActivityがあるとします。
class HogeActivity : Activity() {  ...  ...   private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {  return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)  } } これを見た時、「なんで loginCount &amp;lt;= 100にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。
class HogeActivity : Activity() {  private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {  // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない  return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)  } } 「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。</description>
    </item>
    
    <item>
      <title>感想: Androidアプリ設計パターン入門</title>
      <link>https://satoshun.github.io/2018/03/android-architecture-started/</link>
      <pubDate>Fri, 02 Mar 2018 00:28:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/03/android-architecture-started/</guid>
      <description>Androidアプリ設計パターン入門を読んだのでざっくりと感想。
https://peaks.cc/books/architecture_patterns
感想  MVP  PresenterがViewとModelへの仲介役なので、Presenterはどうしてもfatになりそう  PresenterでView、Modelが何を出来るかを知らなければならない   Contractみたいなインタフェースを切るのは好き  それを見ただけで何をそのページでやっているのかが掴めるので   PresenterはContextを知らなく良い、Pure Javaなのでテスタブルだし綺麗になりそう   MVVM  個人的にはMVPより好き  ViewModelがViewの参照を持たなくて良いので少しスッキリする  ただViewへの参照がないだけで、LiveDataなりObservableFieldに値を書き出すので実質的にはViewがどんなことをしたいか知っているから同等といえば同等     Viewへの参照を持たないので、AACのViewModelへの適合性は高いと思う  DataBindingのObservableFieldとかを使わない前提。使うとViewへの参照を持ってメモリリークしちゃう     Flux  単一方向データフローは凄い良いと思う  単一方向はFluxだけに限らないけど、Fluxを象徴する1つの特徴   ViewModelとかPresenterって処理が集中する傾向にあると感じていて、FluxだとStore、ActionCreatorって形で切り出せるから良い FluxもAACとの相性は良いと思う   負債の話  負債に対する解決策の1つとしてReact Nativeを出すのは発想として凄いと思ったし、そういう解決方法もあるのかと思った   メモ  データ層の抽象化に関してはRepository的なものを作るで良さそう データ側はRx、UI側に反映する時はLiveDataが良さそう    </description>
    </item>
    
    <item>
      <title>DroidKaigi2018で「なんとなく動いているProguardから脱出するために」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2018/02/droidkaigi-2018/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/02/droidkaigi-2018/</guid>
      <description>DroidKaigi2018でセッションが採択されたので発表しました。
 https://goo.gl/S95MJs
正直、Proguardは目新しいトピックでないのでそんなに聞きに来てくれないだろうなと思っていました。 しかし、Room3という広い部屋が割り当てられて、さらに当日はかなりの人が聞きに来てくれました。本当に聞きに来てくれた人ありがとうございます😊😊😊
Twitterの反応を見る限りだと、分かりやすいと言っている人が多くいたので嬉しかったです。 Proguardは苦手意識を持っている人が多いと思っていて、なのでstep by stepで順序良く聞けるような発表を心掛けたのでその効果が少しは出たのかなと思っています。
反省点としては、自分が想定したより時間に余裕があったので何か面白いことを喋ろうとしたら何も思いつかないでフガフガしてしまったところです。 今後はフガフガせずに、アドリブ力みたいなものを身につけていきたいと思います!
あと、もう一つ反省点としてすべるのが怖くて積極的にネタみたいなものをスライドに入れられなかったことです。一応考えていたものは
 「Self-Styled Proguardエバンジェリストです」と自己紹介しようとした。 僕の発表資料はProguardに失敗してやや冗長になってしまいましたけど、みなさんのAPKサイズはProguardに成功して小さくなることを期待しています。みたいなことを言おうとした。  みたいなことを言って笑いを取りたかったなと後悔しています(笑いを取れるとは言っていない)。
来年もDroidKaigiあるとしたらCfP出してまた登壇できるように頑張ります。 そして運営の皆さん本当にありがとうございました。凄い楽しかったです(•ө•)♡</description>
    </item>
    
    <item>
      <title>Android: ViewがどのFragmentに属しているかをViewから取得する</title>
      <link>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</guid>
      <description>ViewがどのFragmentに属しているかを取得する方法の紹介になります。 前々からtag、id以外の仕組みで取得出来ないかなと考えていたら、GlideでViewからFragmentを取得するコードがありました。
@Nullable private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {  tempViewToSupportFragment.clear();  findAllSupportFragmentsWithViews(  activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);  Fragment result = null;  View activityRoot = activity.findViewById(android.R.id.content);  View current = target;  while (!current.equals(activityRoot)) {  result = tempViewToSupportFragment.get(current);  if (result != null) {  break;  }  if (current.getParent() instanceof View) {  current = (View) current.getParent();  } else {  break;  }  }   tempViewToSupportFragment.</description>
    </item>
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description>LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。
package android.arch.lifecycle;  public abstract class LiveData&amp;lt;T&amp;gt; {  protected void onActive() {  } } onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。
package android.arch.lifecycle  fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() {  onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる } 同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。
package android.arch  fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() {  onActive() // コンパイルエラー &amp;#34;Cannot access &amp;#39;onActive&amp;#39;: it is protected in &amp;#39;LiveData&amp;#39;&amp;#34; } なぜかこのような挙動になるか? protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。
まとめ protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう
参考  https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a  </description>
    </item>
    
    <item>
      <title>RxJava: as, toの違いについて</title>
      <link>https://satoshun.github.io/2017/12/rx-as-to-operator/</link>
      <pubDate>Sat, 23 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/12/rx-as-to-operator/</guid>
      <description>RxJavaでobservable型(Flowable、Observableなど)を他の型に変換したいときには、toまたはasを使います。
この記事ではそれぞれの違いを説明します。
toについて toのシグニチャは以下のようになります。
&amp;lt;R&amp;gt; R to(Function&amp;lt;? super Flowable&amp;lt;T&amp;gt;, R&amp;gt; converter) &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Observable&amp;lt;T&amp;gt;, R&amp;gt; converter) &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Maybe&amp;lt;T&amp;gt;, R&amp;gt; convert) &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Single&amp;lt;T&amp;gt;, R&amp;gt; convert) &amp;lt;U&amp;gt; U to(Function&amp;lt;? super Completable, U&amp;gt; converter)  public interface Function&amp;lt;T, R&amp;gt; {  R apply(@NonNull T t) throws Exception; } それぞれconverterをFunctionインターフェースで指定でき、upstream(オリジナルのObservable)を任意の型に変換することが出来ます。
asについて asのシグニチャは以下のようになります。
&amp;lt;R&amp;gt; R as(@NonNull FlowableConverter&amp;lt;T, ? extends R&amp;gt; converter) &amp;lt;R&amp;gt; R as(@NonNull ObservableConverter&amp;lt;T, ? extends R&amp;gt; converter) &amp;lt;R&amp;gt; R as(@NonNull MaybeConverter&amp;lt;T, ?</description>
    </item>
    
    <item>
      <title>Dagger: MembersInjectorを使い依存を注入する</title>
      <link>https://satoshun.github.io/2017/12/dagger-memberinjector/</link>
      <pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/12/dagger-memberinjector/</guid>
      <description>悩んでいたこと Dagger Androidを使いカスタムViewクラスに対して依存を注入する方法
背景/前提知識 Dagger AndroidはActivity, Fragment, Serviceなどのコンポーネントを起点にして依存関係を解決してくれます。しかし、カスタムViewのコンスタラクタはAndroid Frameworkから呼び出されるため、 コンストラクタインジェクションを使うことは出来ません。ということはセッター/フィールドインジェクションを使いカスタムViewに対して、依存を注入する必要があります。
上のことをDagger Androidで実現するにはどうすれば良いのかを考えてみました。
解決策 MembersInjector&amp;lt;T&amp;gt;を使い依存を注入する方法が良いのではと思っています。MembersInjector&amp;lt;T&amp;gt; はとあるクラスに依存を注入するためのインターフェースになります。Component, Module側に特別な記述すること無く使えるDaggerサイドから提供されているインターフェースです。
public interface MembersInjector&amp;lt;T&amp;gt; {  void injectMembers(T instance); } 具体的な疑似コードは下のようになります。
// カスタムView class MainView extends View {  @Inject UserRepository repository; // 適当なRepositoryクラスを注入したい }  // エントリポイントActivity class MainActivity extends Activity {  @Inject MembersInjector&amp;lt;MainView&amp;gt; injector;   @Override  protected void onCreate(@Nullable Bundle savedInstanceState) {  AndroidInjection.inject(this);  super.onCreate(savedInstanceState);  MainView view = findViewById(R.</description>
    </item>
    
    <item>
      <title>LiveDataのpostValueは全て流れてくるとは限らない</title>
      <link>https://satoshun.github.io/2017/12/livedata-postvalue-unsafe/</link>
      <pubDate>Wed, 06 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/12/livedata-postvalue-unsafe/</guid>
      <description>結論  LiveData.postValueを短い間に複数回コールすると最後の値しかObseverに流れてこないことがある  背景 RxJavaのSubjectの代替としてMutableLiveData(postValueとsetValueがpublicになっている)を使っている部分があり、短い間に2回コールされたとき、全ての値が流れて欲しかったが何故か1回しか叩かれていなかった。 どこに原因があるか調査したところ、どうもpostValueメソッドの仕様(LiveDataクラス全体の仕様?)的に短い間に複数回コールされた場合は、最後にpostValueした値のみをpostするようになっていた。
実装詳細 LiveDataのpostValueのコードは以下のようになっています(v1.0.0)
protected void postValue(T value) {  boolean postTask;  synchronized (mDataLock) {  postTask = mPendingData == NOT_SET;  mPendingData = value;  }  if (!postTask) {  return;  }  ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); } postValueメソッドでは
  mPendingDataフィールドにObserverに渡すデータをセットする   メインスレッドでmPostValueRunnableを実行する (ただしmPendingDataにまだ以前のデータが残っていたら、以前のデータを更新する)  といったことをやっています。
このコードを見て分かる通り、前にセットしたmPendingDataがObserverに渡される前に、新しい値で上書きされる可能性があることが分かります。 よって、短い間に複数回のpostValueをコールすると最後の値のみしかObserverに流れてこない可能性があります。
まとめ  RxJavaのSubjectのように、全ての値を流す動作を意図しているとハマる そもそもLiveDataは最新のViewの状態を保持する用途だと思うので、短い間に複数回コールされたら、最後の値のみを流すのは正しい。LiveDataは悪くない。悪いのは俺。  </description>
    </item>
    
    <item>
      <title>Android: Roomにおけるデータ変更通知の仕組みについて(InvalidationTracker)</title>
      <link>https://satoshun.github.io/2017/11/jetpack-room-invalidationtracker/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/11/jetpack-room-invalidationtracker/</guid>
      <description>こんにちはʕ•ӫ̫͡•ʔ
この記事ではどのようにしてRoomがテーブルの変更を検知し、LiveDataなどからデータの変更をオブザーバーに通知しているかについて説明します。
前置き/前提知識 RoomはGoogleが提供しているSQLiteをいい感じに扱うためのライブラリです。
RoomにはDao(Data access object)と呼ばれるインターフェース/抽象クラスがあり、そこを起点にクエリを実行します。
@Dao interface UserDao {  @Query(&amp;#34;SELECT * FROM users&amp;#34;)  fun getUsers(): Flowable&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; } 返り値として、observableデータ型を取ることができ、RoomではLiveDataとRxJava2の型(Flowableとか)などのobservable型サポートしています。
そして、LiveDataまたはFlowableで返り値を定義すると対象のテーブルがInsertなどで変更されたときに、変更通知を受け取ることが出来ます。
// クライアント側のコード userDao.getUsers()  .subscribeOn(Schedulers.io)  .subscribe {  println(it) // ここが対象のテーブルが変更されるたびに評価される。  } テーブルの変更検知はRoomの内部クラスのInvalidationTrackerクラスで行っています。 これからInvalidationTrackerの内部実装を見ていきます。
InvalidationTrackerの流れ  InvalidationTracker#startTrackingTableメソッドでTrigger(SQL)を生成 obsevableが生成されたら、対応するInvalidationTracker.Observer(変更通知用コールバック)をInvalidationTrackerに登録 RoomData#endTransactionのタイミングで各テーブルが更新されたかを確認 テーブルが更新されていたら変更通知コールバックを実行  というのが大まかな流れになります。2はobserver(変更通知用コールバック)を登録するだけ、4は登録したコールバックにデータを流すだけです。なので1, 3について詳しく見ていきます。
InvalidationTracker#startTrackingTableメソッドによりTriggerを生成する 最初に各テーブルのバージョンを管理する room_table_modification_logが生成されます。
CREATE TEMP TABLE room_table_modification_log (  version INTEGER PRIMARY KEY AUTOINCREMENT,  table_id INTEGER ) このクエリの意味することは、テーブル操作があったときに、対象のテーブルのversionを更新するようにすることで、version変更されていたら更新を検知することが出来ます。このversionを更新するためにRoomではSQLにある機能の1つTriggerを使っています。具体的には次のTriggerを利用しています。
CREATE TEMP TRIGGER IF NOT EXISTS room_table_modification_trigger_users_UPDATE AFTER UPDATE ON users BEGIN  INSERT OR REPLACE INTO room_table_modification_log VALUES (null, 0); # 0はtable_id END これは一見複雑に見えますがものすごい単純で、usersテーブルがUPDATEされたら上記のクエリがフックされて実行されるだけです。上のクエリINSERT OR REPLACE INTO room_table_modification_log VALUES (null, 0); は room_table_modification_logテーブルに最新のid + 1のrowを追加/更新するものになります。</description>
    </item>
    
    <item>
      <title>Android: RxJava &#43; OkHttpを使って401の処理をいい感じにする</title>
      <link>https://satoshun.github.io/2017/08/rx-okhttp-401/</link>
      <pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/08/rx-okhttp-401/</guid>
      <description>(この記事はRxJavaとOkHttpを知っている前提で進めていきます。またこの記事はRxJavaすごーいしたいだけの記事です。401のハンドリングのところは、RxJavaを使いたいだけのユースケースというか1例になります。)
この記事のサンプルコードは ここ(Github)にあります。
 API周りの開発をしていて、401のときの処理をどうするかという永遠の課題があると思います。 クライアント側で頑張るとしたら以下の感じになるかなと思います。
 OkHttpのAuthenticatorを使い、そこで401のときのハンドリングをする。公式ドキュメントのリンク OkHttpのInterceptorを使い、そこで401のときのハンドリングをする。公式ドキュメントのリンク 各処理(例えばRxJavaのTransformerとか)に401用の処理を埋め込んで、retryを掛ける。  などがあるかなと(OkHttp、RxJavaを使うことを前提とする)
このブログではOkHttpのAuthenticatorを使う方法で401の処理をいい感じにしたいと思います。
またrefresh tokenは非同期、APIリクエストが必要であるとします。擬似コードはこんな感じです。
fun refreshToken(): Observable&amp;lt;String&amp;gt; { return Observable.just(Credentials.basic(&amp;#34;sato&amp;#34;, &amp;#34;passwordhoge&amp;#34;)) .doOnNext { println(&amp;#34;GET credential: $it&amp;#34;) } // Log出力 .delay(2000, TimeUnit.MILLISECONDS) } 時間が掛かるんだなあくらいに思って下さい。
401の処理を書いていく OkHttpのAuthenticatorは401のときにフックされます。なのでこの中で401ならrefresh tokenをし、結果をauthorization headerにセットして再リクエストをすれば良さそうです。
ただここで1つ問題があります。それは、APIリクエストは並列に行われるということです。ということは、何も考えないとrefresh tokenが複数回叩かれてしまいます。なのでrefresh tokenをしているときは、後続の401はそれを待つようにしないといけません。
愚直に表現するなら、refresh tokenをしていますよフラグをどこかに立てておいて、それがtrueなら待つ。falseならrefersh tokenをして、結果を待つといった処理になります。 並列にリクエストが行われるとしたら、マルチスレッドからコールされるのでsynchorizeなどの制御をする必要があり、めっちゃムズい。
RxJavaを使ってみる 上記の縛りをRxJavaのpublish + refCountを使うとめっちゃいい感じに表現できます。
private val authenticator: Authenticator = object : Authenticator {   // ここがポイント。publishとrefCountを使う。  private val tokenStream = refreshToken().publish().refCount()   // これだと駄目  // private val tokenStream = refreshToken()   // ここは並列に呼ばれる  override fun authenticate(route: Route, response: Response): Request?</description>
    </item>
    
    <item>
      <title>RxJava multicastについて</title>
      <link>https://satoshun.github.io/2017/05/rx-multicast/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/05/rx-multicast/</guid>
      <description>RxJavaには, stream上のアイテムを複数のSubscriberに渡せるmulticast(再利用のような感じ)の機能があります. multicastは主に「キャッシュとして使う」, イベントをが発火したときに複数で処理をおこなう」 として使います.
RxJavaでは2つの方法でmulticastを実現します.
 publishを使い, ConnectableObservableを作る Subjectを使う  また, RxJava2だとFlowableがありますが, Flowableの場合は Processorを使います.
説明だけだと分かりにくいので, サンプルコードも合わせてどうぞ.
 ConnectableObservable Subject  ConnectableObservableについて ConnectableObservableはpublishがコールされたタイミングで生成されます. ここがStreamの開始地点, 再利用する地点になります. なので, mapやfilterなど, 共通の処理があるのなら, publishのUpstreamに書いて共通化したほうが効率が良いです.
ConnectableObservableはconnectメソッドがコールされたタイミングで, Streamの開始をします. 従来はSubscriberを登録した(subscribeメソッドをコールした)タイミングなので, 注意が必要です.
そして, publish + connectを組みわせることで1つのStreamに対して複数のSubscriberを登録することが出来ます.
(source: https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators)
他にも, shareやrefcountがありますが, 基本的な考え方は変わりません.
Subjectを使う Subjectは, ObservableとObserverの機能を同時に使うことができる実装です. 1例としては, Observerの機能を使い, 複数のObservableからデータを取得し, Observableの機能を使いそのデータをObserverに渡す, いわゆるBridgeのような事ができます.
BehaviorSubject, ReplaySubjectなどのバラエティがあるので, 必要に応じて使い分ける必要があります. (https://github.com/ReactiveX/RxJava/wiki/subject)
まとめ multicastを上手に使いこなすことで, データの取得回数を減らし, アプリがパフォーマンスに優れた構造になることが期待できます. そのためには, どこにmulticastを入れるか, どこからConnectableObservableにするか(publishをコールするか)を決定する必要があります. アプリごとに適切なポイント, 書き方は異なると思うので, サンプルを参考に頂けたら幸いです.
Happy RxJava2 life!!
参考  Multicasting in RxJava RxJava  </description>
    </item>
    
    <item>
      <title>RxJava 並行でリクエストをして, リクエストした順番で値を受け取る</title>
      <link>https://satoshun.github.io/2017/05/rx-concateager-parallel-request/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/05/rx-concateager-parallel-request/</guid>
      <description>結論  concatEagerを使う  concat, concatEager RxJavaにはconcatEagerと, concatオペレータがあります. 似た名前ですが, 振る舞いは異なります. concatEagerはconcatと違い, 並列にObservableは処理するけど, 返してくる順番は保証されています
 concat: 直列にObservableを処理し, 返してくる順番は保証されている concatEager: 並列にObservableを処理し, 返してくる順番は保証されている  コードで説明すると,
// o1 ----&amp;gt; | // o2 |------&amp;gt;| // | | // s ------o1------o2 Observable.concat(o1, o2)  .subscribe(); // o1 -----------&amp;gt;| // o2 --&amp;gt;---------|-| // | | // s ------------o1-o2 Observable.concatEager(o1, o2)  .subscribe(); みたいな感じになります. 繰り返しになりますが ,concatEagerは同時に与えたObservableを解釈し, 順番を守ってくれます.</description>
    </item>
    
    <item>
      <title>RxJava: AutoDisposeで自動的にdisposeする</title>
      <link>https://satoshun.github.io/2017/05/rx-autodispose/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/05/rx-autodispose/</guid>
      <description>非同期処理を開始した後に, Activityのライフサイクルなどに連動して非同期処理をキャンセルする必要があります.
RxJavaでは, Disposableからキャンセルの処理を行います.
Disposable d;  public void onCreate() {  d = myObservable  .map(a -&amp;gt; b)  .subscribe(); }  public void onPause() {  d.dispose(); } このコードだと, ストリームの定義と, キャンセルのコードが離れ過ぎているため, 可読性が低いです.
AutoDisposeを使うことで, コード離れすぎ問題を解決することが出来ます.
public void onCreate() {  myObservable  .to(new ObservableScoper&amp;lt;&amp;gt;(this))  .subscribe(); } このような感じで, ストリームの定義の中にAutoDisposeが提供しているScoperを埋め込むことで自動的にdisposeしてくれます.
また, Scoperは, カスタムで柔軟に定義することが出来ます. 例えば,
 Activityのライフサイクル Fragmentのライフサイクル RecyclerViewのライフサイクル  など, こちら側で実装することが出来ます(実装の手間は少し掛かります)
これで, Disposableをマニュアルで呼び出すことから解放されます!
Error Proneと組み合わせると最強 とはいえ, そもそもScopeをストリームに埋め込むのを忘れる問題があります(だって人間だもの)
そこで, Googleが出したError Proneを組み合わせることで埋め込むのを忘れる問題を解決出来ます.</description>
    </item>
    
    <item>
      <title>RxJava: Connectable Observableについて</title>
      <link>https://satoshun.github.io/2017/05/rx-connectable-observable/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/05/rx-connectable-observable/</guid>
      <description>結論  同じStreamを複数のObserverで扱いたいときはConnectable Observableを使う  効率的!!   Connectable Observableはsubscribeをコールしても, Streamが開始しない  connectメソッドをコールした時に, Streamが開始する    基本的な使い方 同じデータを必要としているObserverがあるとします. これを単純に書くと以下のようになります.
Obervable&amp;lt;User&amp;gt; getUsers() { return Observalbe.just(User1, User2, User3);}  Obervable&amp;lt;User&amp;gt; users = getUsers(); users.subscribe(o1); users.subscribe(o2); users.subscribe(o3); これだと, subscribeされるたびに新しいStreamが作られてしまいます. 上の例だと3つの独立したObservableが作成されてしまい, 非常に効率が悪いです.
Connectable Observableを使うことで, 1つのStreamからsubscribeすることが出来ます.
ConnectableObservable&amp;lt;User&amp;gt; users = getUsers().publish(); users.subscribe(o1); users.subscribe(o2); users.subscribe(o3); users.connect(); // 重要!! publishオペレータを適用することで, Connectable Observableに変換出来ます. そして, Connectable Observableに対してObserverをsubscribeし, 最後にconnectをコールすることで, 共通のStreamからsubscribeすることが出来ます.
流れとしては以下のようになります.
 publishをコールすると, Connectable Observableが作成出来る Connectable ObservableをいくつかのObserverでsubscribeする  ここではStreamは開始されず, 登録のみされる   最後にconnectをコールする  Streamが開始される.</description>
    </item>
    
    <item>
      <title>RxJava: SubjectでonErrorを取り扱う時</title>
      <link>https://satoshun.github.io/2017/05/rx-subject-materialize/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/05/rx-subject-materialize/</guid>
      <description>結論  materialize, dematerializeを使う.  背景 onErrorをSubjectに流すと, Subjectはdispose状態になるため, これ以降のEventを流すことが出来なくなります.
sub.subscribe(  v -&amp;gt; Log.d(&amp;#34;onNext&amp;#34;, String.valueOf(v)),  e -&amp;gt; Log.d(&amp;#34;onError&amp;#34;, e.getMessage())); sub.onNext(v1); sub.onNext(v2); sub.onError(e1); sub.onNext(v3); // ignore sub.onNext(v4); // ignore これだと, Subjectがこれ以降に値を受け付けないため不便になることがあります.(ユースケース次第)
materialize + dematerializeオペレータを使うと, この問題を解決出来ます.
Observable.create((ObservableOnSubscribe&amp;lt;String&amp;gt;) e -&amp;gt; {  e.onNext(&amp;#34;1&amp;#34;);  e.onNext(&amp;#34;2&amp;#34;);  e.onError(new RuntimeException(&amp;#34;e1&amp;#34;)); }).materialize().subscribe(sub::onNext); Observable.create((ObservableOnSubscribe&amp;lt;String&amp;gt;) e -&amp;gt; {  e.onNext(&amp;#34;3&amp;#34;);  e.onNext(&amp;#34;4&amp;#34;);  e.onError(new RuntimeException(&amp;#34;e2&amp;#34;)); }).materialize().subscribe(sub::onNext); materialize を使い, ErrorイベントをNextイベントに変換します
そして, Subscribeするタイミングで, dematerializeでNextイベントをErrorイベントに戻します.
sub.dematerialize().subscribe(  v -&amp;gt; Log.d(&amp;#34;onNext&amp;#34;, String.</description>
    </item>
    
    <item>
      <title>Android: Dagger2のScopeについてあれこれ</title>
      <link>https://satoshun.github.io/2016/11/dagger2-scope/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/11/dagger2-scope/</guid>
      <description>結論: Application(Singleton), Activity, Fragment, Viewの4つのScopeを作るのが良いと思います.
Scopeとは? とあるprovideするインスタンスの生存期間を指定するアノテーションです. SingletonアノテーションもScopeの一種です. 例えば, Singletonは, その名の表すとおり, Singletonで表現したいインスタンスに対してアノテートします.
Androidなら, OkHttpClientなどはSingletonで管理すべきなので, 下のように表現できます.
@Singleton @Provides public static OkHttpClient provideOkHttpClient() {  return new OkHttpClient.Builder()  .connectTimeout(10, TimeUnit.SECONDS)  .readTimeout(20, TimeUnit.SECONDS)  .build(); } Singletonアノテーションを付けないと, Injectするたびに新しいインスタンスが作られます.
また, ScopeアノテーションはDagger特有のアノテーションではなく, JSR-330で定義されているスペックなので, Daggerが廃れたとしても, JSR-330が廃れてない限り使える知識, 技術になります.
Androidに適したScope Androidには大きく, Application, Activity, Fragment, Viewの4つのライフサイクルがあります. なので, それらに対してScopeを定義すればいいと思ってます.
 Application: Singleton Activity: ActivityScope Fragment: FragmentScope View: ViewScope  ViewScopeはRecylerView, ListViewなどで有効に使えると思います.</description>
    </item>
    
    <item>
      <title>Android: Repository層についてあれこれ</title>
      <link>https://satoshun.github.io/2016/11/android-arch-repository/</link>
      <pubDate>Wed, 23 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/11/android-arch-repository/</guid>
      <description>参考: https://github.com/googlesamples/android-architecture/tree/todo-mvp
Repository層とは? data層を抽象する層. Repositoryではアプリのキャッシュポリシーを担当する. キャッシュはメモリ, ディスクのどちらかに保存するかに依存しないようにする. そこの実装はdata層に任せる.
具体的には, Repositoryは, remote dataオブジェクトと, local dataオブジェクトの2つのオブジェクトに依存するようにし, どこにキャッシュされるかはlocal dataオブジェクトに従う. こうすることで, Repositoryはどこにデータが保存されているかを気にしなくて良い. あくまでRepositoryはどこのdataオブジェクトからデータを取ってくるのかを決定する.
また, Repositoryは基本的にApplicationのライフサイクルに連動し, SingletonでActivity間でデータの共有を効率的に行える. 例えば, Activity Aで取得したデータはRepositoryのキャッシュポリシーに従いキャッシュをし, Activity Bでは, キャッシュポリシーに従い即座にデータを取得できる可能性がある.(ポリシーによっては毎回remoteからデータ取得する可能性もある)
RxJavaとともに RepositoryはRxJava(Observable)との相性が良いと思っています. 例えば以下のようにコールバック関数無く書けるからです.
@NonNull @Override public Observable&amp;lt;User&amp;gt; getUser(int id) { return localDataSource.getUser(id)  .onErrorResumeNext(remoteDataSource.getUser(id))  .doOnNext(new Action1&amp;lt;User&amp;gt;() {  @Override public void call(User user) {  localDataSource.saveUser(user);  }  })  .subscribeOn(Schedulers.io())  .observeOn(AndroidSchedulers.mainThread()); } 上のソースコードは, localDataSourceからデータを取得できなければ, remoteDataSourceに取得しに行くコードになります. クライアントでは, local, remoteの違いを気にしなくて良いというのが一番の利点です.</description>
    </item>
    
    <item>
      <title>LeakCanary: ソースコードリーディング</title>
      <link>https://satoshun.github.io/2016/10/android-leakcanary-code-reading/</link>
      <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/10/android-leakcanary-code-reading/</guid>
      <description>LeakCanaryはメモリリークを発見してくれるライブラリです.
どうやってメモリリークを検知しているのかが気になったのでまとめ.
おおまかな流れ  Application#registerActivityLifecycleCallbacksを使い, ActivityのonDestroyされたときにコールされるonActivityDestroyedをリッスンする onActivityDestroyedがコールされたら, onDestroyされたActivityへの参照がなくなっているかをチェックする refrenceが残っていたら(メモリリーク!), どこから参照されているかを探す 参照先が探せたら, notificationを作成し, メモリリークしていることを通達する notificationがクリックされたら, どこが原因でメモリリークが発生しているかを表示する  という流れになっています. 肝は2, 3だと思うのでそこがどのように実装されているかを説明します.
onDestroyされたActivityへの参照がなくなっているかをチェックする これにはReferenceQueueを利用します. ReferenceQueueは登録したオブジェクトがGarbage Collectorにより解放されたかどうかを調べるクラスです. これにonDestroyがコールされたActivityを登録し, GCにより解放されたかどうかを検知することでメモリリークを調べることを出来ます.
ここで, ReferenceQueueがGCを検知しなかったら, どこからの参照が原因でGCが呼ばれないのかを探します.
どこから参照されているかを探す どこからActivityが参照されているかを探すために, まず現在のheapのdumpを取ります. heapのdumpは Debug.dumpHprofData(/your/file/path);で取れます.
それを https://github.com/square/hahaを使ってどこからActivityが参照されているかを探索します. HAHAは, hprofファイルから木構造を作成し, 各オブジェクトがどのような参照関係になっているかを表現します. HAHAを使い, Activityを起点とし, それの親の参照, 親の参照, &amp;hellip;と探索することでrootの参照を探します.
あとは, 4, 5でrootの参照を通知します.
まとめ ざっくりとLeakCanaryの説明をしました. HAHAはhprofの読み込みをいい感じにしてくれるだけなので, 肝はReferenceQueueだと思います.
ReferenceQueueはなかなか使う機会は無いと思いますが, 覚えておくといつか得するかもしれません(適当)</description>
    </item>
    
    <item>
      <title>Android: Fragmentを使って、画面の向きの変更時にデータを保持する</title>
      <link>https://satoshun.github.io/2016/10/android-orientation-data/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/10/android-orientation-data/</guid>
      <description>onSaveInstanceState, onRestoreInstanceStateを使う方法もありますが, 今回はFragmentを使う方法を紹介します.
サンプルコードは https://github.com/satoshun-example/AndroidRetainData にあります.
ユースケース ネットワークはコストが掛かるので, 1度データを取得したら, 画面回転でアクティビティが再生成されたとしてもデータを使いまわしたい, というケースがあるとします.
やり方 まず, データを保持するFragmentを定義します.
最初にonCreateで, setRetainInstance(true)をコールします.
@Override public void onCreate(Bundle savedInstanceState) {  super.onCreate(savedInstanceState);  setRetainInstance(true);   refresh(); } 次に, refreshでデータを取得します. ここではRxJava2 + Retrofitを使っています.
void refresh() {  disposables.clear();  disposables.add(provideGithubAPI()  .getRepositories(&amp;#34;satoshun&amp;#34;)  .subscribeOn(Schedulers.computation())  .observeOn(AndroidSchedulers.mainThread())  .subscribe(  data -&amp;gt; subject.onNext(data),  e -&amp;gt; subject.onError(e))); } APIコールをして, 取得したデータをBehaviorSubject(subject)に与えます.
最後にobservableメソッドを定義し, データソース(subject)を他のオブジェクトからアクセス出来るようにします.
Observable&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; observable() {  return subject; } Fragmentのフルソースコードはここにあります.</description>
    </item>
    
    <item>
      <title>Android: MVPのPresenterの非同期周りのユニットテストの書き方</title>
      <link>https://satoshun.github.io/2016/07/android-test-mvp/</link>
      <pubDate>Sun, 31 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/07/android-test-mvp/</guid>
      <description>MVP(Model-View-Presenter)アーキテクチャが流行ってますね!
MVPはテスタブルであることが1つのウリとなっていますが, 実際にPresenterのユニットテストをどのようにして書くかを紹介したいと思います.
今回のコードは https://github.com/satoshun-example/AndroidTestSample に上げてあるので, 良かったら見て下さい.
使うツール/ライブラリ  JUnit4 Mockito  今回, テスト書きたい箇所 今回は, MainPresenterクラスをテストします.
public class MainPresenter implements MainContract.Presenter {   @NonNull  private final UserDataSource dataSource;   @NonNull  private final MainContract.View view;   public MainPresenter(@NonNull UserDataSource dataSource, @NonNull MainContract.View view) {  this.dataSource = dataSource;  this.view = view;  }   @Override  public void start() {  view.showLoadingIndicator();   dataSource.</description>
    </item>
    
    <item>
      <title>Android: テストメソッドの命名規則について</title>
      <link>https://satoshun.github.io/2016/02/android-test-method-naming-convention/</link>
      <pubDate>Fri, 12 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/02/android-test-method-naming-convention/</guid>
      <description>ソフトウェアの世界ではAndroidに限らず, テストを書くというのは非常に重要です.
ユニットテストの場合は, メソッドレベルでリグレッションが起きていないことを, 機能/受け入れテストの場合は, ユーザの行動レベルでリグレッションが起きていないことを保証するために必要になります.
今回の記事では, Androidにおけるユニットテスト(各テストメソッド)の命名規則の話をします. しかし, 他の言語/プラットフォームの場合でも同様の考え方を出来ると思います.
用語定義 アプリコード: アプリケーション本体のコード
なぜテストケースの命名規則を気にする必要があるか? Androidアプリを作っていて, アプリコードはリファクタリングや, 新機能の追加などで頻繁に目を通しますが, テストコードは1度書いたら, そのテストが失敗するまで放置するパターンが多いなと感じています(何にしてもアプリコードほどは目を通さない)
数週間前に書いたテストコードなんて忘れてしまうので, テストコードにはいろいろな情報をコメントなどで残しておく必要があります.
まず, テストケースの構成を考える 本題に入る前に, テストケースがどのような要素で構成されているかを説明をします.
一般的なテストケースは次の4つの要素に分割できます.
 事前準備(setup) 実行(exercise) 宣言(assertion) 後処理(teardown)  これだと分かりにくいので, コードで説明すると,
public class HogeTest {  List&amp;lt;String&amp;gt; lists;   @Before  public void setup() {  // 事前準備(setup)  lists = new ArrayList&amp;lt;&amp;gt;();  lists.add(&amp;#34;1&amp;#34;);  lists.add(&amp;#34;123&amp;#34;);  }   @After  public void teardown() {  // 後処理(teardown)  }   @Test  public void testGet() {  // 実行(exercise)  String actual = lists.</description>
    </item>
    
    <item>
      <title>Android: MVP, Dagger2, Retrofitなどなどでアプリを作りました</title>
      <link>https://satoshun.github.io/2015/09/android-app-events/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/09/android-app-events/</guid>
      <description>イベントを検索するAndroidアプリを作成したので, 使った技術のまとめです.
アプリの技術的機能, 特徴は以下になります.
 HTTPを介してイベントのデータを取得する  検索対象のサーバは複数あるため(今回は3つ), どこかでそれらのレスポンスデータを同期する必要がある  それら複数のサーバーはJSONを返すが, 微妙にJSONの構造が異なる     Data-Bindingライブラリを使う MVP(Model-View-Presenter)パターンを使う  Activity(Fragment)に機能が集中しないようにしたい!    上記を中心にどのように実装をしたかを説明をしていきます.
フルソースコードはここにあります. https://github.com/satoshun/AndroidEvents
HTTPを介してイベントのデータを取得する connpass, Atnd, Zusaarの3つのAPIを使うことにしました. RetrofitでAPIを定義し, JSONのパースにはGson, データの処理にはRxJavaを使いました.
例えば, connpass APIは以下のように定義しました.
/** Get data from Conpass */ public interface Connpass {  @GET(&amp;#34;/v1/event&amp;#34;)  Observable&amp;lt;ConnpassResponse&amp;gt; search(  @Query(&amp;#34;ymd&amp;#34;) List&amp;lt;String&amp;gt; ymds);   @GET(&amp;#34;/v1/event&amp;#34;)  Observable&amp;lt;ConnpassResponse&amp;gt; search(  @Query(&amp;#34;keyword&amp;#34;) String keyword,  @Query(&amp;#34;ymd&amp;#34;) List&amp;lt;String&amp;gt; ymds); } keywordとymdを指定してリクエストを生成します.</description>
    </item>
    
    <item>
      <title>Improving Android: 列挙にはenumではなくIntDef, StringDef annotationを使う</title>
      <link>https://satoshun.github.io/2015/08/improve-android-performance1/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/08/improve-android-performance1/</guid>
      <description>enumの典型的な使い方として, 月(month)や, ネットワークプロコトルなどの, 特定の種類を列挙するために使用されます.
列挙型としてのenumは, 以下のように書くことが出来ます.
enum Month {  JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE,  JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER }  /** 指定した月が何日まであるかを返す */ int getDate(Month month) {  //// } また, enumではなく定数を使うとしたら以下のように書くことが出来ます.
static final int JANUARY = 1; static final int FEBRUARY = 2; static final int MARCH = 3; static final int APRIL = 4; ... static final int NOVEMBER = 11; static final int DECEMBER = 12;  /** 指定した月が何日まであるかを返す */ int getDate(int month) {  //// } 定数を使うバージョンだと, getDate(int)のため, 予期せぬ値が入ってきてしまう可能性があります.</description>
    </item>
    
    <item>
      <title>Android: Picassoで使われているデザインパターン</title>
      <link>https://satoshun.github.io/2015/06/reading_picasso/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/reading_picasso/</guid>
      <description>Picassoで使われているデザインパターンを紹介する記事です.
Singletonパターン Singletonパターンは, インスタンスの生成を1つに制限するパターンになります.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L672
public static Picasso with(Context context) {  if (singleton == null) {  synchronized (Picasso.class) {  if (singleton == null) {  singleton = new Builder(context).build();  }  }  }  return singleton; } Picasso#withは, すでにPicassoのインスタンス singleton が生成されていればそれを返し, 生成されていなければ, インスタンスを生成して返します.
このパターンのメリットは, インスタンスを多くても1つしか作らないのでメモリ的に有利な点です(使い回せる) しかし, singletonなインスタンスは, 複数のクラスから使われる可能性があるので, スレッドセーフである必要があります.
スレッドセーフにするためには, 全てのfieldの値をfinalにする. 排他的制御を入れるなどの方法があります.
Builderパターン Builderパターンはインスタンス生成時に多数のパラメータが必要なときに便利なパターンです.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L702
public static class Builder {  private final Context context;  private Downloader downloader;  private ExecutorService service;  private Cache cache;  private Listener listener;  private RequestTransformer transformer;  private List&amp;lt;RequestHandler&amp;gt; requestHandlers;  private Bitmap.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>概要 この記事では, JakeWhartonさんのu2020から, AndroidでDagger2を使うときの実践的な方法を紹介します. u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.
DI, Dagger2の基本について知りたい方は, Part1を見て下さい.
目次
 debugとproductionでModuleを切り替える Debug専用のViewを作る Mockモードの定義 -　まとめ  debugとproductionでModuleを切り替える gradleは, productFlavorsを設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります. そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています. 具体的には,
 /src/production/java/com/jakewharton/u2020/Modules.java /src/internalDebug/java/com/jakewharton/u2020/Modules.java /src/internalRelease/java/com/jakewharton/u2020/Modules.javaに  それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています. これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.
こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.
 Debugのみログを有効にしたい APIのエンドポイントを変えたい debug専用のViewを出したい Test用のインスタンスをinjectしたい etc, etc&amp;hellip;  以下では, より細かく説明していきます.
Debug専用のViewを作る u2020では, Debug専用のView DebugAppContainerがあります. Debug専用のView はこんな感じです. Debugビルドの時は, このContainerをinjectしています.
DebugAppContainerは簡単にいえば, DrawerLayoutを1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.
Mockモードの定義 u2020ではMockモードがあり, Mockデータを表示機能があります.
public final class DebugDataModule {  .</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. 基本編 Part1</title>
      <link>https://satoshun.github.io/2015/05/dagger2/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2/</guid>
      <description>概要 この記事では, 最初にDIとは何かについて説明します. DIを理解した後にDagger2の基本的な使い方を紹介します. Dagger2はDI(Dependency Injection)をするライブラリです.
DIとは? DIとはDependency Injectionの略で, 訳すと「依存性の注入」です. ここでいう依存とは クラス同士の依存関係のことを表します. クラス同士の依存関係は, 委譲パターンの時に現れます.
例えば, 以下のコードがあったとします.
class Blogger {  public Blogger() {  }   public void post(String title) {  // 何かメインの処理  // ...   // fileにlogを取る  FileLogger logger = new FileLogger(title);  logger.logging();  } }  class FileLogger implements Logger {  @Override  public void logging(String... messages) {  // fileにmessagesを書き出す  File file = new File(&amp;#34;hoge.</description>
    </item>
    
    <item>
      <title>Android: DroidKaigiまとめ</title>
      <link>https://satoshun.github.io/2015/04/droid-kaigi/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/droid-kaigi/</guid>
      <description>DroidKaigiの記事まとめです.
DroidKaigi - Welcome talk   DroidKaigi - Welcome talk  from mhidaka エンジニアのための勉強会をやるよ!みたいな内容
Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法   Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法 -  from Yuki Anzai  CardboardのUXをカメラで向上する   CardboardのUXをカメラで向上する (droidkaigi 2015/04)  from Kenichi Takahashi  絶対落ちないアプリの作り方 あるゲームアプリケーションの構成とアップデートサイクル   あるゲームアプリケーションの構成とアップデートサイクル  from Kentaro Iizuka  開発を効率的に進めるられるまでの道程   開発を効率的に進めるられるまでの道程  from Takao Sumitomo  アプリの企画、プロトタイプからリリースに至るまで   初学者に嬉しいAndroid開発環境   【DroidKaigi2015】初学者に嬉しいAndroid開発環境(あとMVCとか)  from Hiroyuki Kusu  大容量データのダウンロード戦略  複数Threadでダウンロードしても, 帯域があまっていないと早くならない.</description>
    </item>
    
    <item>
      <title>Android: FragmentPagerAdapterでハマった話</title>
      <link>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</guid>
      <description>ハマったのでメモ. 以下のことをしたかった.
 データ取得するまで, Fragment内でProgress Barを出力 ネットワークからデータを取得し, Fragment内にあるAdapterのデータ更新 UIに反映  notifyDataSetChangedメソッドが効かない データが更新した後に FragmentPagerAdapter#notifyDataSetChangedメソッドを叩けばFramentが再生成されるんでしょ?と思っていた時期が僕にもありました. notifyDataSetChangedメソッドを叩いても, データがUIに反映されず, ProgressBarが表示されたままでした.
FragmentPagerAdapterでは, 基本的に一度作られたFragmentは削除されず, notifyDataSetChangedメソッドでデータを更新したよーと知らせても, Fragmentを再生成してくれません.(仕様通り)
これはどうしたものかと思っていろいろ調べたところ, FragmentStatePagerAdapterクラスにいきつきました.
FragmentStatePagerAdapterを使う FragmentPagerAdapterでなくて, FragmentStatePagerAdapterを使えばUIにデータが反映されました.
以下, 実装例になります. まずは, ダメパターンです. FragmentPagerAdapterクラスを使い, Activityでデータを受け取ったら, refreshメソッドを叩くようになっています.
public class PagerAdapter extends FragmentPagerAdapter {  ...  ...   public void refresh() {  notifyDataSetChanged();  } } FragmentPagerAdapterがスーパークラスになっているため, notifyDataSetChangedを何度叩いても, Fragmentが再生成されることはありません. つまり, データを更新した後にUIにデータが反映されません.
次にOKパターンです. FragmentStatePagerAdapterを使い, getItemPositionをOverrideするのがポイントです.
public class PagerAdapter extends FragmentStatePagerAdapter {  private List&amp;lt;Fragment&amp;gt; mFragments;   .</description>
    </item>
    
    <item>
      <title>Android: strings.xmlのまとめ</title>
      <link>https://satoshun.github.io/2015/02/android-resource_string/</link>
      <pubDate>Sun, 22 Feb 2015 04:10:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-resource_string/</guid>
      <description>res/values/strings.xmlは, 文字列関連のリソースを管理するファイルです. 文字列をプログラム外で定義することで, 多国語の対応, デバッグブルドの時にサーバのURLを変更する等が, コードをいじらずに容易に行えます.
また, 意外といろいろな機能があったので, 紹介したいと思います.
基本的な使い方 &amp;lt;string name=&amp;#34;app_name&amp;#34;&amp;gt;Application&amp;lt;/string&amp;gt; のように記述して使います. アプリケーション側では, 下のように取得します.
getString(R.string.app_name);  or  context.getString(R.string.app_name); 特に, 説明はいらないと思います.
arrayの定義 strings.xmlでは単純なkey-valueだけでなく, arrayも定義することができます.
string-array要素で定義してあげます.
&amp;lt;string-array name=&amp;#34;sports&amp;#34;&amp;gt;  &amp;lt;item&amp;gt;マラソン&amp;lt;/item&amp;gt;  &amp;lt;item&amp;gt;野球&amp;lt;/item&amp;gt;  &amp;lt;item&amp;gt;サッカー&amp;lt;/item&amp;gt;  &amp;lt;item&amp;gt;卓球&amp;lt;/item&amp;gt; &amp;lt;/string-array&amp;gt; アプリケーション側では下のように取得します.
getResources().getStringArray(R.array.sports)  or  context.getResources().getStringArray(R.array.sports) Contextから直接取得することが出来ないので, 一旦Resourcesを取得し, そこからarrayを取り出します.
値展開 strings.xmlでは, 文字列展開することが出来ます. printf formatのように使います.
&amp;lt;!-- %1: 引数1, $d: 数字 --&amp;gt; &amp;lt;string name=&amp;#34;hoge&amp;#34;&amp;gt;Hello %1$d&amp;lt;/string&amp;gt; &amp;lt;!-- %1: 引数1, %2: 引数2, $s: 文字列 --&amp;gt; &amp;lt;string name=&amp;#34;hogestr&amp;#34;&amp;gt;%1$s %2$d %1$s&amp;lt;/string&amp;gt; アプリケーション側では, 下のように指定します.</description>
    </item>
    
    <item>
      <title>Android: Pull to Refreshの実装(SwipeRefreshLayout)</title>
      <link>https://satoshun.github.io/2015/02/android-pull_to_refresh/</link>
      <pubDate>Sun, 22 Feb 2015 04:09:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-pull_to_refresh/</guid>
      <description>AndroidでPull to Refreshの実装方法です. ListViewなどを下方向に引っ張ると, データを更新するように出来ます. Gmailとかで使われているあれです.
具体的には, SwipeRefreshLayoutを使って実装します. 以下でコードで説明していきます.
XML側の記述 ListViewに覆いかぶさるように定義します.
&amp;lt;android.support.v4.widget.SwipeRefreshLayout  android:id=&amp;#34;@+id/refresh&amp;#34;  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;match_parent&amp;#34; &amp;gt;   &amp;lt;ListView  android:id=&amp;#34;@android:id/list&amp;#34;  android:layout_width=&amp;#34;match_parent&amp;#34;  android:layout_height=&amp;#34;match_parent&amp;#34; /&amp;gt; &amp;lt;/android.support.v4.widget.SwipeRefreshLayout&amp;gt; XML側はこれで完了です. これで, ListViewを引っ張ると「Pull to Refresh」のアニメーションが起こります.
Activity側の記述 Pull to Refreshをした時に, イベントが発生するのでListenerを記述します.
実装例です. setOnRefreshListenerでListenerを登録します.
 private SwipeRefreshLayout mSwipe;  @Override protected void onCreate(Bundle savedInstanceState) {  ...  mSwipe = (SwipeRefreshLayout) findViewById(R.id.refresh);  // Callback登録  mSwipe.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {  @Override  public void onRefresh() {  /* ここに適当な処理を書く */  mSwipe.</description>
    </item>
    
  </channel>
</rss>
