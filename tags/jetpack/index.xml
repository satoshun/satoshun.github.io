<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jetpack on stsnブログ</title>
    <link>https://satoshun.github.io/tags/jetpack/</link>
    <description>Recent content in jetpack on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sat, 11 Jun 2022 03:03:47 +0000</lastBuildDate><atom:link href="https://satoshun.github.io/tags/jetpack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>dev版のJetpack Composeを使って、新しいKotlinに対応する</title>
      <link>https://satoshun.github.io/2022/06/jetpack-compose-dev-compiler/</link>
      <pubDate>Sat, 11 Jun 2022 03:03:47 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/06/jetpack-compose-dev-compiler/</guid>
      <description>Jetpack Composeは、特定のKotlinのバージョンと結びついており、Kotlinをアップデートするには、対応するJetpack Composeのバージョンに合わせる必要があります。 しかし、Jetpack Composeは、やや遅れて最新のKotlinへのサポートが入るので、すぐに最新のKotlinを試せない現状があります。
ただ、devバージョンのJetpack Compose Compilerを指定することで、Kotlinを新しいバージョンに上げることが出来ます。
devバージョンのJetpack Compose Compilerは、下記のリンクから探すことができます。
https://androidx.dev/storage/compose-compiler/repository 例えば、Kotlin 1.7.0に対応した、Jetpack Compose Compilerは次のように使うことができます。
// build.gradle repositories { maven { url &amp;#34;https://androidx.dev/storage/compose-compiler/repository/&amp;#34; } } // app/build.gradle android { composeOptions { kotlinCompilerExtensionVersion &amp;#34;1.2.0-dev-k1.7.0-53370d83bb1&amp;#34; } } これで、Kotlinを1.7.0に上げることが出来ます。
注意 前述したリンクにも書いてあるんですが、devバージョンなので不具合がある可能性が高いです。なので、あくまでテスト、サンプルでのみ使ったほうが無難だと思います。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: debugInspectorInfoを使って、デバッグを少し楽にする</title>
      <link>https://satoshun.github.io/2022/03/compose-debug-inspector-info/</link>
      <pubDate>Sun, 06 Mar 2022 12:12:41 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2022/03/compose-debug-inspector-info/</guid>
      <description>Android Studioで、Layout Inspector を使うことで、レイアウトの配置や、実際にどのような値がセットされているかの詳細を見る事ができます。
Jetpack Composeでは、そのLayout Inspectorに情報を渡すことができます。
どのように渡すかを Modifier.border を例にして説明します。まず、Modifier.borderを次のように使ってみます。
Surface( modifier = Modifier .border(width = 2.dp, color = Color.Cyan) ) { ... } そして、Layout Inspectorで、このSurfaceの中身を見てみます。
modifierの中に、borderがあり、詳細な情報があることが分かります。
では次に、Modifier.border ではどのようにして、Layout Inspectorに値をセットしているかを見ていきます。
fun Modifier.border(width: Dp, brush: Brush, shape: Shape): Modifier = composed( factory = { ... }, inspectorInfo = debugInspectorInfo { name = &amp;#34;border&amp;#34; properties[&amp;#34;width&amp;#34;] = width if (brush is SolidColor) { properties[&amp;#34;color&amp;#34;] = brush.value value = brush.value } else { properties[&amp;#34;brush&amp;#34;] = brush } properties[&amp;#34;shape&amp;#34;] = shape } ) composedメソッドの、inspectorInfo引数から、debugInspectorInfoメソッドを介してなんか色々やっていることが分かります。 debugInspectorInfoメソッドは、InspectorInfoをレシーバーとして受け取ることができ、InspectorInfoを介してnameとpropertiesをセットすることができます。コードを見ると、nameに&amp;quot;border&amp;quot;、propertiesに&amp;quot;width&amp;quot;などをセットしていることが分かります。 これを実行すると、上の画像のようにLayout Inspector上に情報を出力することができます。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: IOSchedをJetpack Composeで書く part1</title>
      <link>https://satoshun.github.io/2020/07/compose-iosched-scaffold/</link>
      <pubDate>Sun, 12 Jul 2020 05:14:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/07/compose-iosched-scaffold/</guid>
      <description>この記事では、Jetpack Composeを学ぶために、公式の IoSched のUIをJetpack Composeに書き換えていく記事になります。 完全に見た目を同一にするという所まではやらずに、大体一緒の見た目で妥協するのでご了承下さい。
Part1では、ホーム画面のAppbarを作るところまでをやります。
また、この記事のコードのライセンスはGoogle I/Oアプリと同等です。
Copyright 2014 Google Inc. All rights reserved. Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>Jetpack Compose: PreviewParameterアノテーションを使っていろいろなプレビューを作る</title>
      <link>https://satoshun.github.io/2020/07/compose-preview/</link>
      <pubDate>Wed, 08 Jul 2020 11:36:04 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/07/compose-preview/</guid>
      <description>この記事では、PreviewParameterアノテーションを使って複数のプレビューを出す方法について説明します。
Previewアノテーションについて Jetpack Composeでは、@Previewを使うことでプレビューを表示することが出来ます。
例えば、TestScreenのプレビューは次のように定義することが出来ます。
@Composable fun TestScreen( user: User, count: Int ) { ... } @Preview(&amp;#34;test screen&amp;#34;) @Composable fun PreviewTestScreen() { TestScreen(user = User(id = &amp;#34;1&amp;#34;, name = &amp;#34;tom&amp;#34;), count = 10) } ここで、いろいろなUserインスタンスでプレビューを表示したいとします。愚直にやるなら、@Previewを複数定義することですが、@PreviewParameterを使うことでよりスマートに書くことが出来ます。
具体的には、次のように書くことが出来ます。
class PreviewUserProvider : PreviewParameterProvider&amp;lt;User&amp;gt; { override val values: Sequence&amp;lt;User&amp;gt; get() = sequenceOf( User(id = &amp;#34;1&amp;#34;, name = &amp;#34;tom&amp;#34;), User(id = &amp;#34;2&amp;#34;, name = &amp;#34;スズキ&amp;#34;) ) } @Preview(&amp;#34;test screen parameter&amp;#34;) @Composable fun PreviewParameterTestScreen( @PreviewParameter(PreviewUserProvider::class) user: User ) { TestScreen(user = user, count = 10) } 最初に、PreviewParameterProviderインターフェースを実装します。PreviewParameterProviderでは、プレビューしたいインスタンス（パラメータ）を定義してあげます。 実装したクラスを @PreviewParameter(PreviewUserProvider::class) と指定することで、プレビューを複数出すことが出来ます。</description>
    </item>
    
    <item>
      <title>Android: ActivityResultContractを使ってRuntime Permissionsを実装する</title>
      <link>https://satoshun.github.io/2020/06/jetpack-activity-permission-contract/</link>
      <pubDate>Thu, 11 Jun 2020 10:47:24 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/06/jetpack-activity-permission-contract/</guid>
      <description>Activity 1.2.0-alpha02から導入された、ActivityResultContractを使うことで、Runtime Permissionsをいい感じに実装することが可能になりました。
この記事では、どのように実装すれば良いかを簡単に説明します。
単一のPermissonを要求する 新しく追加された registerForActivityResult 拡張関数に、ActivityResultContracts.RequestPermission()を指定することで、単一のPermissionを要求することが出来ます。
例えば、android.permission.ACCESS_FINE_LOCATIONが欲しい時は、次のように書くことが出来ます。
class HogeActivity : AppCompatActivity() { // 定義側 private val requestLocation = registerForActivityResult( ActivityResultContracts.RequestPermission(), ACCESS_FINE_LOCATION ) { isGranted -&amp;gt; // Permissionの取得に成功したかどうか、Boolean値で返ってくる Toast.makeText(this@AppActivity, &amp;#34;isGranted $isGranted&amp;#34;, Toast.LENGTH_LONG).show() } private fun hoge() { // 呼び出し側 requestLocation.launch(Unit) } } 複数のPermissonを要求する 複数の場合は、ActivityResultContracts.RequestMultiplePermissions()を指定します。
例えば、android.permission.ACCESS_FINE_LOCATION、android.permission.READ_EXTERNAL_STORAGEが欲しい時は、次のように書くことが出来ます。
class HogeActivity : AppCompatActivity(R.layout.app_act) { // 定義側 private val requestPermissions = registerForActivityResult( ActivityResultContracts.RequestMultiplePermissions(), arrayOf(ACCESS_FINE_LOCATION, READ_EXTERNAL_STORAGE ) { grants -&amp;gt; // Permissionの取得に成功したかどうか、Map&amp;lt;String, Boolean&amp;gt;&amp;gt;で返ってくる Toast.makeText(this@AppActivity, &amp;#34;grants $grants&amp;#34;, Toast.</description>
    </item>
    
    <item>
      <title>Android: ConstraintLayoutの子にRecyclerViewを配置して、Match Constraintsを設定すると良くない挙動をする</title>
      <link>https://satoshun.github.io/2020/05/recyclerview-with-match-constraints/</link>
      <pubDate>Fri, 15 May 2020 13:25:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/05/recyclerview-with-match-constraints/</guid>
      <description>備忘録です。
次のようなレイアウトは良くないぞという話です。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34;&amp;gt; &amp;lt;androidx.recyclerview.widget.RecyclerView android:id=&amp;#34;@+id/recycler&amp;#34; android:layout_width=&amp;#34;0dp&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 今回の例では、LinearLayoutManagerをLayoutManagerとして使っています。他のLayoutManagerの場合、どういう挙動をするか分かりません。 また、ConstraintLayout 2.0.0-beta06、RecyclerView 1.1.0で試しています。
どんな挙動をするか? このレイアウトはファーストビューのタイミングで、すべてのアイテムをバインドしようとします。
例えば500個のRecyclerViewアイテムがあったときに、画面に収まるかどうかに関わらず500個のバインドが走ります。
with(recycler) { // 横方向のLinearLayoutManager layoutManager = LinearLayoutManager( this@ConstraintMatchConstraintsActivity, RecyclerView.HORIZONTAL, false ) // 500個のアイテムを生成 adapter = SampleAdapter().apply { submitList((0..500).map { &amp;#34;$index $it&amp;#34; }) } } private class SampleAdapter : ListAdapter&amp;lt;String, RecyclerView.ViewHolder&amp;gt;(...) { ... override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { println(getItem(position)) // ここが、0 ~ 500まで表示される } } 500個全部に対して、最初にバインドが走るのは非効率なので良くないです😂
なんでか? LinearLayoutManagerでは、内部でmInfinite っていうフィールドを持っていて、これは次の関数によって生成されます。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: Ambientを使ってインスタンスを注入、取得する</title>
      <link>https://satoshun.github.io/2020/03/compose-ambient/</link>
      <pubDate>Thu, 05 Mar 2020 10:38:47 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/03/compose-ambient/</guid>
      <description>こんにちわっふる🍰
今回は、ComposeにあるAmbientを説明したいと思います。この記事はdev06で検証しています。
前提・課題 一般的に、Composableなコンポーネントにデータを渡すとき、関数の引数から渡します。
@Composable fun MyView(someData: Data) { ... } これがシンプル かつ 分かりやすい方法です。 しかし、中間に多くのComposableなコンポーネントがある場合、全てのコンポーネントの引数でデータを受け取り、さらに渡す必要があります。これは少々面倒で冗長です。
ここで、Ambientを使うとすっきりと書くことが出来ます。
Ambientを使う まず、最初にAmbientの定義をします。Ambientの定義はambientOfメソッドから行えます。
今回は例として、ExampleViewModelをAmbientで定義して、コンポーネントから使用します。
まず、定義を行います。
val exampleViewModelAmbient = ambientOf&amp;lt;ExampleViewModel&amp;gt;() これで定義は完了です。ambientOfメソッドを呼び出すだけです。
次に、これをコンポーネントから使ってみます。
val exampleViewModelAmbient = ambientOf&amp;lt;ExampleViewModel&amp;gt;() @Composable fun ExampleApp() { val viewModel = ExampleViewModel() Providers(exampleViewModelAmbient provides viewModel) { MyView() } } @Composable private fun MyView() { val viewModel = exampleViewModelAmbient.current ... } これで完了です。コードを説明してきます。
Providers(exampleViewModelAmbient provides viewModel)
Ambientに対して値を注入しています。この場合、定義したexampleViewModelAmbientに、ExampleViewModelのインスタンスを注入、セットしています。
val viewModel = exampleViewModelAmbient.current
注入した値は .current から取得することが出来ます。この場合、上記で生成したExampleViewModelのインスタンスの値を取得することが出来ます。
ambientOfで定義して、Providersで値をセットすることで、コンポーネントに値を渡すことが可能になります。
注意点 注意としては、Providersで囲っていない場合にエラーになる点です。例えば、次のように書くことは出来ません。</description>
    </item>
    
    <item>
      <title>Jetpack Compose: Modelとstate</title>
      <link>https://satoshun.github.io/2020/02/compose-model-state/</link>
      <pubDate>Sat, 29 Feb 2020 23:32:01 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/compose-model-state/</guid>
      <description>Jetpack Composeのデータ監視方法について紹介します。
state まず、stateメソッドの紹介をします。
stateメソッドを使うと値を監視することができ、値が変更されたときに自動で再構成（recomposition）してくれます。
次のように、Viewの状態を表すのに便利に使えます。
@Composable fun MyCheckbox() { // 初期値false var checked by state { false } Checkbox( checked = checked, onCheckedChange = { // stateで定義した値を更新すると、自動でUIの再構成（recomposition)が走る checked = it } ) } state { 初期値 }って感じで定義して、その値を更新するとUIの再構成をしてくれます。
この例の場合、Checkboxがクリックされると、checkedの状態が変わり、Viewが再構成されます。
Model 次にModelです。Modelはアノテーションで定義されています。 Modelアノテーションをつけたクラスのプロパティが監視対象になり、プロパティが更新されたときに自動で再構成してくれます。
例えば、クリックされたカウントを保持するModelは次のように作ります。
@Model class Count( var count: Int = 0 ) @Composable fun MyText() { // Modelの定義。引数から渡すこともある val count = Count() Ripple(bounded = false) { Clickable(onClick = { // Modelの値を更新すると、自動で再構成（recomposition)が走る count.</description>
    </item>
    
    <item>
      <title>Android: findViewTreeLifecycleOwnerでViewからLifecycleOwnerを取得する</title>
      <link>https://satoshun.github.io/2020/02/jetpack-find-view-tree-lifecycle-owner/</link>
      <pubDate>Sun, 23 Feb 2020 01:50:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/02/jetpack-find-view-tree-lifecycle-owner/</guid>
      <description>lifecycle-2.3.0に、ViewからLifecycleOwnerを取得するメソッドが追加されそうなので、それのメモ。
まだ2.3.0-alphaはリリースされていないので、androidxのSNAPSHOTで試します。 SNAPSHOTの使い方は、Using AndroidX Snapshot Buildsを参考にしました。
使い方 関数の定義と使い方になります。
// 関数の定義 fun View.findViewTreeLifecycleOwner(): LifecycleOwner? // 使い方 val owner = view.findViewTreeLifecycleOwner() // 使い方 + Coroutine view.findViewTreeLifecycleOwner()?.lifecycleScope?.launch { ... } Viewに拡張関数が定義されており、そこから使うことが出来ます。
Fragmentで生成したViewからfindViewTreeLifecycleOwnerをした場合には、 Fragmentのライフサイクルが取得出来るので、適切なライフサイクルを使うことが出来ます。
内部実装 シンプルな作りになっており、ViewのタグにActivityやFragmentのLifecycleOwnerを登録しています。
public class ViewTreeLifecycleOwner { public static void set(@NonNull View view, @Nullable LifecycleOwner lifecycleOwner) { view.setTag(R.id.view_tree_lifecycle_owner, lifecycleOwner); } @Nullable public static LifecycleOwner get(@NonNull View view) { LifecycleOwner found = (LifecycleOwner) view.getTag(R.id.view_tree_lifecycle_owner); ... } } じゃあsetはどこから行われるかというと、ライブラリ側で自動的に行われます。なので、明示的にsetを呼び出す必要は特にありません。 具体的には、FragmentとComponentActivityを継承していればViewを生成したタイミングで、自動でセットしてくれます。
ただし、試したSNAPSHOTだとAppCompatActivityの継承の場合、自動でLifecycleOwnerが登録されていませんでした。 現状だと、AppCompatActivityの継承の場合は手動でLifecycleOwnerを登録する必要があります。
override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>FragmentでViewの参照を持つとメモリリークする話と実装</title>
      <link>https://satoshun.github.io/2020/01/fragment-view-memory-leak/</link>
      <pubDate>Sat, 18 Jan 2020 13:09:08 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2020/01/fragment-view-memory-leak/</guid>
      <description>View Bindingのドキュメントが更新され、onDestroyViewのタイミングで保持しているBindingの参照を解放する節が追記されました。
Use view binding in fragments
Fragment自体のライフサイクルのほうが、FragmentのViewのライフサイクルより長いので、FragmentでBindingの参照を保持するとリークしてしまうためです。
この記事では、メモリリークをしないために、どのような実装が考えられるかを紹介していきます。
1. onDestoryViewで解放する 公式ドキュメントに載っている方法です。
// onCreatedViewで初期化 private var _binding: ResultProfileBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view } override fun onDestroyView() { _binding = null } onDestroyViewで参照を解放するコードを書きます。シンプルですが、冗長なのかなと思います。
2. AACサンプルで使っているAutoClearedValueを使う takahiromさんにTwitterで教えてもらったんですが、AACサンプルではDelegationを使って、自動で参照を解放しているようです。
DroiKaigiでは、Adapterとか持ちたい場合もあるので、AACのサンプルにあるAutoCleardValueにしてみました https://t.co/IUNmeQLzfB
&amp;mdash; takahirom (@new_runnable) January 17, 2020 次のように使います。</description>
    </item>
    
    <item>
      <title>メモ Android: Navigation Component &#43; Toolbar(ActionBar)周りのコードを読んで見る</title>
      <link>https://satoshun.github.io/2019/11/navigation-toolbar-internal-code/</link>
      <pubDate>Sat, 30 Nov 2019 06:14:19 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/navigation-toolbar-internal-code/</guid>
      <description>Navigation Component + Toolbarのデフォルトの挙動をカスタマイズしたかったので、その周辺のコードを読んでみたメモブログになります。
この記事のコードは、次のライセンスに従います。
/* * Copyright 2018 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>Android: Navigationのdialogタグ周りのコードちょっと読んでみた</title>
      <link>https://satoshun.github.io/2019/11/navigation-dialog-internal-code/</link>
      <pubDate>Sat, 09 Nov 2019 06:23:13 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/11/navigation-dialog-internal-code/</guid>
      <description>Navigation Component 2.1.0からdialogタグが使えるようになりました。 どんな感じで処理をしているのか気になったので、ざっくりとメモ書き。
1. abstract Navigatorクラス このクラスは最終的にどのように、対象クラスをnavigateされるかを決めるクラスです。 Activityなら、ActivityNavigator。FragmentならFragmentNavigatorが使われます。 dialogの場合は、DialogFragmentNavigator経由でdialogが発火するようになっています。
2. NavInlaterでdialogタグの場合、DialogFragmentNavigatorを使うようにしている NavInflaterは単純なXMLパーサーになっています。&amp;lt;dialog &amp;hellip;&amp;gt; を発見したら、DialogFragmentNavigatorからNavDestinationを作成するようになっています。 このNavDestinationは実際にコールされるときに、DialogFragmentNavigatorを呼び出すような仕組みなっています。
3. DialogFragmentNavigatorの中身 一部分を抜粋します。
/* * Copyright 2019 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ViewPager2で要素をループさせる</title>
      <link>https://satoshun.github.io/2019/10/viewpager2-loop/</link>
      <pubDate>Sun, 13 Oct 2019 05:23:44 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/10/viewpager2-loop/</guid>
      <description>ViewPager2で要素をループさせる方法の紹介です。いわゆる循環リストです。
ViewPager2ではRecyclerViewを使うことが出来るので、RecyclerViewと同じような実装で実現することが出来ます。
最終的にこんなのが作れます。（a、b、cの要素でループしている）
今回の検証に用いたコードは、satoshun/ViewPager2にあります😃
では、コードを説明していきます。今回は、1つのViewTypeを扱います。
実際のコード まず、RecyclerView.Adapterのサイズを決めるgetItemCountメソッドの実装です。 限りなく大きい値、Int.MAX_VALUEを返します。
override fun getItemCount(): Int = Int.MAX_VALUE 次に、onBindViewHolderメソッドを次のように実装します。
private val itemData: List&amp;lt;Data&amp;gt; override fun onBindViewHolder(holder: InfiniteViewHolder, position: Int) { val data = itemData[position % itemData.size] ... } itemDataにはViewの生成に必要な実際のデータが入っています。position % itemData.sizeとindexを取ることで、ループ中のどこの位置にいるかを特定することが出来ます。
最終的な、RecyclerView.Adapterは次のようになります。（onCreateViewHolderメソッドは重要でないので、省略しています）
class InfiniteAdapter( private val itemData: List&amp;lt;Data&amp;gt; ) : RecyclerView.Adapter&amp;lt;InfiniteViewHolder&amp;gt;() { override fun getItemCount(): Int = Int.MAX_VALUE override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = ... override fun onBindViewHolder(holder: InfiniteViewHolder, position: Int) { val data = itemData[position % itemData.</description>
    </item>
    
    <item>
      <title>ViewPager2でカルーセルっぽいものを実装する</title>
      <link>https://satoshun.github.io/2019/08/viewpager2-like-a-carousel/</link>
      <pubDate>Thu, 29 Aug 2019 13:29:06 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/08/viewpager2-like-a-carousel/</guid>
      <description>横のアイテムをチラ見せする画面をViewPager2で書けるよって話です。
最終的にこんなのが作れます。
では、コードを説明していきます。
1. 横のアイテムをチラ見せする まず、ViewPager2をLayout内に定義します。
&amp;lt;androidx.viewpager2.widget.ViewPager2 android:id=&amp;#34;@+id/viewpager&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;200dp&amp;#34; android:orientation=&amp;#34;horizontal&amp;#34; /&amp;gt; 次に、横のアイテムをどれだけチラ見せるかを定義します。
&amp;lt;dimen name=&amp;#34;offset&amp;#34;&amp;gt;32dp&amp;lt;/dimen&amp;gt; 次に、各アイテム間にどれだけのマージンをつけるかを定義します。
&amp;lt;dimen name=&amp;#34;page_margin&amp;#34;&amp;gt;16dp&amp;lt;/dimen&amp;gt; 次に、ViewPager2内で使うレイアウトのトップレベルのViewにmarginLeft、Rightをセットします。
&amp;lt;com.google.android.material.card.MaterialCardView android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:layout_marginLeft=&amp;#34;48dp&amp;#34; // これは、offset + page_marginの値 android:layout_marginRight=&amp;#34;48dp&amp;#34; app:cardCornerRadius=&amp;#34;16dp&amp;#34;&amp;gt; ... marginには前で定義したoffset、page_marginを足し合わせたものを指定します。
そして、最後にPageTransformerを設定します。
viewpager.offscreenPageLimit = 2 // これは左右のアイテムを描画するために必要 val pageMarginPx = root.context.resources.getDimensionPixelOffset(R.dimen.page_margin) val offsetPx = root.context.resources.getDimensionPixelOffset(R.dimen.offset) viewpager.setPageTransformer { page, position -&amp;gt; val offset = position * (2 * offsetPx + pageMarginPx) page.translationX = -offset } PageTransformerはスクロールに応じてコールバックされる関数になります。 この中で、translationXをpositionの値に応じて動かすことで、左右のアイテムのチラ見せを実現出来ます。
2. さらにScaleも変更する 前述したチラ見せPageTransformerに加え、Scale用のPageTransformerも作ります。
viewpager.setPageTransformer(CompositePageTransformer().apply { addTransformer { page, position -&amp;gt; val offset = position * (2 * offsetPx + pageMarginPx) page.</description>
    </item>
    
    <item>
      <title>Android: RestrictToアノテーションのIDE上での振る舞い</title>
      <link>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</link>
      <pubDate>Wed, 03 Jul 2019 12:30:11 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</guid>
      <description>androidx.annotation:annotationには、RestrictToアノテーションクラスが定義されています。 このアノテーションは次の用途を持ちます。
Denotes that the annotated element should only be accessed from within a specific scope (as defined by Scope).
指定したScope以外からのアクセスを制限するアノテーションです。
この記事では、このRestrictToアノテーションがついたクラスに様々な場所からアクセスしたときに、どのようにIDE上で警告が出るかについて見ていきます。
また、Android Studio 3.5.0-beta05で検証しました。
この記事内に出てくるRestrictTo関連のコードは以下のライセンスに従います。
/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.</description>
    </item>
    
    <item>
      <title>ViewModel SavedState &#43; Dagger</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</link>
      <pubDate>Sat, 25 May 2019 10:38:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</guid>
      <description>ViewModel + SavedStateでDaggerを使う方法を考えてみました。
前提知識・課題 SavedStateを使う場合、ViewModelにSavedStateHandleインスタンスを渡さなければいけません。
class MyViewModel( private val state: SavedStateHandle ) : ViewModel() { ... } SavedStateHandleインスタンスを作るために、SavedStateVMFactoryもしくは、AbstractSavedStateVMFactoryを使う必要があります。
生成したいViewModelのコンストラクタの引数がSavedStateHandleのみなら、SavedStateVMFactoryを使います。
// thisはFragmentActivity ViewModelProvider(this, MyViewModel(this)) .get(MyViewModel::class.java) コンストラクタの引数がSavedStateHandle以外にもあるなら、AbstractSavedStateVMFactoryを拡張します。
class TestViewModel( private val state: SavedStateHandle, private val name: String ) : ViewModel() class TestViewModelFactory( owner: SavedStateRegistryOwner, defaultArgs: Bundle? = null ) : AbstractSavedStateVMFactory(owner, defaultArgs) { override fun &amp;lt;T : ViewModel&amp;gt; create( key: String, modelClass: Class&amp;lt;T&amp;gt;, handle: SavedStateHandle ): T { return TestViewModel(handle, &amp;#34;test&amp;#34;) as T } } // 以下、生成コード ViewModelProvider(this, TestViewModelFactory(this)) .</description>
    </item>
    
    <item>
      <title>雑メモ: ViewModel SavedStateのコードリーディング</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate/</link>
      <pubDate>Tue, 21 May 2019 23:59:53 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate/</guid>
      <description>ViewModelのSavedStateがどのように実現しているのか、内部でどのように動作しているのか気になったので、ソースコードを読んでみました。
この記事のソースコードは全て、下記のライセンスに従います。
/* * Copyright 2019 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ViewPager2 with TabLayout</title>
      <link>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</link>
      <pubDate>Fri, 17 May 2019 04:08:42 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</guid>
      <description>Material ComponentsでViewPager2 + TabLayoutのコードが入ったのでそれの紹介。まだalphaへのリリースもされていないので、APIは大きく変わるかもしれません。おそらく1.1.0-alpha07に入ってくると思います。
TabLayoutはViewPagerでサポートされていましたが、それがViewPager2にも来たって感じです。
使い方 新しく追加されたTabLayoutMediatorを使います。
まず、TabLayoutMediatorインスタンスを生成します。
val viewPager: ViewPager2 = findViewById(R.id.viewpager) val tabLayout: TabLayout = findViewById(R.id.tab) val mediator = TabLayoutMediator(tabLayout, viewPager) { tab: TabLayout.Tab, position: Int -&amp;gt; tab.text = &amp;#34;test $position&amp;#34; // タブにタイトルをセット } コンストラクタには、TabLayout、ViewPager2、OnConfigureTabCallbackを渡します。 OnConfigureTabCallbackは、tabとpositionを受け取り、tabに対して、タイトルをセットします。 ViewPagerのPageAdapterとは違い、RecyclerViewのAdapterからはタイトルを取得できないので、このような変更になったと思われます。
最後にattach関数を呼び出します。
mediator.attach() これで、ViewPager2 + TabLayoutを実現できます。とても簡単！！
まとめ ViewPager2もエコシステムが整いつつある😊 今回試したサンプルコードは satoshun-android-example/ViewPager2にあります😃 </description>
    </item>
    
    <item>
      <title>Data Binding 3.5と3.6のまとめ/感想</title>
      <link>https://satoshun.github.io/2019/05/databinding-3dot5/</link>
      <pubDate>Thu, 16 May 2019 00:33:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/databinding-3dot5/</guid>
      <description>Google I/O 2019でDataBindingについて少し話されていたので感想とまとめを。 動画だとここらへんになります。
改善系 ビルドの高速化! 20%くらいビルドが早くなった distributed build cache対応 Incremental annotation processing対応 android.databinding.incremental=true を設定にすると使えます Android Studioとの連携強化!! Live Class Generation XMLを変更したら、コンパイルせずともクラス、フィールドにアクセスすることが出来る リファクタリング系 フィールド名の変更リファクタリングなどをしたときに、XML、コードの両方に反映される Errorメッセージの改善!!! DataBinding用のエラーセクションが出来たことで、どこでエラーが出たか特定しやすくなった 新規系 View Binding 簡易版Data Bindingのような立ち位置で、findViewByIdを省略 + コンパイルセーフ + コンパイルを高速にすることを目的に作られました。3.6で入るみたいです。
Data Bindingと比較したときの、メリット、デメリット以下になります。（ただし、まだalphaも出ていない段階なのでI/O動画から見る限りの感想です）
メリット コンパイルが早くなる Data Bindingより機能が少なくなるのでそれはそう &amp;lt;layout&amp;gt;で囲う必要がなくなった これ個人的には好きでなかったので嬉しい。ネストが減る デメリット &amp;lt;data&amp;gt;セクションがなくなる モデルの値とViewのマッピングはコード側ですることになりそう 多分BindingAdapterは使えない これもコード側ですることになりそう 双方向バインディングとか使えない おそらくなんですけど、Data Binding、View Bindingは1つにプロジェクトに混在させることが出来るので、基本View Bindingで、双方向使いたいときはData Bindingみたいな使い方も出来るはずです。
まとめ/感想 今、3.5-beta01を使っているんですが、肌感、かなり良くなっています😃 Live Class Generation便利すぎワロリン View Bindingはとても良さそう Kotlin syntheticの代わりに使ってもよさそう </description>
    </item>
    
    <item>
      <title>CameraX: CameraView触ってみた</title>
      <link>https://satoshun.github.io/2019/05/camerax-camera-view/</link>
      <pubDate>Mon, 06 May 2019 05:47:14 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/camerax-camera-view/</guid>
      <description>CameraXのコードが公開されていたので、その中にあったCameraViewを触ってみました。まだ、alphaであることからAPIは大きく変わる可能性があります。
内部の実装であったり、細かい部分はpsideさんの「CameraXのコードがきたので気合い入れて読んでみた」が詳しいです。
環境構築 CameraViewはまだ公開されていないため、ソースコードからビルドする必要があります。また、設定でpublishフラグがfalseになっているので、trueにしてビルドします。
androidx { name = &amp;#34;Jetpack Camera View Library&amp;#34; - publish = false + publish = true mavenVersion = LibraryVersions.CAMERA mavenGroup = LibraryGroups.CAMERA inceptionYear = &amp;#34;2019&amp;#34; } 使い方 CameraViewは普通のViewのように使うことができます。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout ...&amp;gt; &amp;lt;androidx.camera.view.CameraView android:layout_width=&amp;#34;0dp&amp;#34; android:layout_height=&amp;#34;0dp&amp;#34; app:layout_constraintBottom_toBottomOf=&amp;#34;parent&amp;#34; app:layout_constraintEnd_toEndOf=&amp;#34;parent&amp;#34; app:layout_constraintStart_toStartOf=&amp;#34;parent&amp;#34; app:layout_constraintTop_toTopOf=&amp;#34;parent&amp;#34; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt; 次に初期化をします。
cameraView.bindToLifecycle(this) // thisはLifecycleOwner LifecycleOwnerとCameraViewを結びつけることでLifecycleに合わせて自動でリソースを調整してくれます。 CameraViewはLifecycle-Aware Componentとなっています。非常に扱いやすそうです。
これだけでカメラ機能が使えるようになります！とても簡単！!
以下、CameraViewで現状使えるAPIについて紹介します。
CameraViewで使えるAPI達 モードの変更 CameraViewでは次の3つのモードがあります。
Image: 写真を取る Video: ビデオを取る Mixed: 両方。ただし、動かない端末もあるらしい 次のように使います。
// Image cameraView.captureMode = CameraView.CaptureMode.IMAGE cameraView.takePicture(...) // Video cameraView.</description>
    </item>
    
    <item>
      <title>DataBindingとActivityのコンストラクタ Layout Id指定を一緒に使う</title>
      <link>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</link>
      <pubDate>Thu, 04 Apr 2019 00:46:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</guid>
      <description>JetpackのActivityとFragmentのコンストラクタに、Layout Idが指定できるようになりました。
Activity Version 1.0.0-alpha06 Fragment Version 1.1.0-alpha06 これは、次のように使うことが出来ます。
class MainActivity : AppCompatActivity(R.layout.main_act) class MainFragment : Fragment(R.layout.main_frag) Activityの場合は、setConentViewが。Fragmentの場合はonCreateViewがそれぞれ省略することが出来ます。
ここからが本題です。これをDataBindingと一緒に使うなら、次のようになるかなと思います。
Activityの場合 まずはActvityの例です。
// 拡張関数を定義しておく fun &amp;lt;T : ViewDataBinding&amp;gt; ComponentActivity.bindView(): T = DataBindingUtil.bind(getContentView())!! private fun Activity.getContentView(): View = findViewById&amp;lt;ViewGroup&amp;gt;(android.R.id.content)[0] // MainActivity.kt class MainActivity : AppCompatActivity(R.layout.main_act) { private lateinit var binding: MainActBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = bindView() ... } } また、Activityの場合に限り、by lazyと組み合わせることも可能です。
class MainActivity : AppCompatActivity(R.layout.main_act) { private val binding by lazy { bindView&amp;lt;MainActBinding&amp;gt;() } override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、 どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。
以下、2019年3月10日 2019年3月11日の調査結果になります。 また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。
Lifecycle
// Lifecycleに従うCoroutineScopeの生成 val Lifecycle.coroutineScope: CoroutineScope LifecycleOwner
// LifecycleOwnerに従うCoroutineScopeの生成 val LifecycleOwner.lifecycleScope: CoroutineScope ViewModel
// ViewModelに従うCoroutineScopeの生成 val ViewModel.viewModelScope: CoroutineScope WorkManager
abstract class CoroutineWorker( appContext: Context, params: WorkerParameters ) : ListenableWorker(appContext, params) { // suspendメソッドで定義された abstract suspend fun doWork(): Result } Room
// Dao内でsuspendメソッドが使える @Dao interface HogesDao { @Insert suspend fun add(hoge: Hoge) @Query(&amp;#34;SELECT * FROM hoge WHERE id = :id&amp;#34;) suspend fun get(id: String): Hoge .</description>
    </item>
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。 まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、AndroidJUnit4ランナーが使えるなど、かなりの部分が共通化出来ます。
この記事では、ユニットテストでActivity.onActivityResultのテストをどこまでandroid testのように書けるかを検証します。
テスト対象コード まず最初に、テスト対象コードは次のようになっています。
class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... button.setOnClickListener { startActivityForResult( Intent(this, Sub2Activity::class.java).apply { putExtra(&amp;#34;fuga&amp;#34;, &amp;#34;hoge&amp;#34;) }, 1 ) } } override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent? ) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == 1) { if (resultCode == Activity.RESULT_OK) { val value = data!!.getIntExtra(&amp;#34;test&amp;#34;, -1) button.text = value.toString() } } } } class Sub2Activity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。
結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂
また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。
Room in memory? Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。
使い方は次のようになります。
Room .inMemoryDatabaseBuilder(context, MyDatabase::class.java) .build() in memoryを使う理由としては、
ディスパッチするアクションを永続化する必要はないだろう マイグレーションが必要ない になります。
実装に入っていく では、実装の説明をしていきます。
まずはActionをRoomのEntityとして定義します。
sealed class AuthorAction @Entity(tableName = &amp;#34;author1&amp;#34;) data class Author1( @PrimaryKey val _id: Long = 0, // always 0 val name: String, val age: Int ) : AuthorAction() @Entity(tableName = &amp;#34;author2&amp;#34;) data class Author2( @PrimaryKey val _id: Long = 0, // always 0 val name: String, val age: Int ) : AuthorAction() Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、@PrimaryKey(autoGenerate = true)を使っても良いと思います。</description>
    </item>
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>この記事ではFragmentでLiveDataにObserverを登録するときはFragment#getViewLifecycleを使うと良いという話をします。
まず、Fragmentのおおまかなライフサイクルは次のようになっています。
onAttach onCreate onCreateView onViewCreated &amp;hellip; onDestoryView onDestroy onDetach ここで重要なのは、onDestroyが呼ばれることなく、複数回onCreateViewが呼ばれる可能性がある点です。
例えば、次のコードは間違っている可能性があります。
class MainFragment: Fragment() { ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewModel.data.observe(this, Observer { ... }) } } なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。 このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。 しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。
前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。 よって、FragmentにはView用のLifecycleが用意されています。それが、Fragment#getViewLifecycleです。
前述のコードは次のように書くことが出来ます。
class MainFragment: Fragment() { ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // ViewのLifecycleOwnerを渡す viewModel.data.observe(viewLifecycleOwner, Observer { ... }) } } このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！
補足1 Observerが開放されるタイミングはonDestroyがコールされるタイミングとは別にもう1つあります。 それは、Observerへの参照がなくなったタイミングです。内部的にObserverはWeakReferenceで保持されており、参照が無くなったタイミングでGCされます。
補足2 Observerの重複登録問題はattach/detachを繰り返す場合におこります。 サンプルコードは次のようになります。
while (true) { delay(3000) supportFragmentManager.</description>
    </item>
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃
基本編 一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。
例えば、次のコードは間違っています。
class MainViewModel @Inject constructor(...): ViewModel() class MainActivity { @Inject lateinit var viewModel: MainViewModel ... } この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。
class MainViewModel(...): ViewModel() @Module class MainActivityModule { @Provides fun provideMainViewModel(...) : MainViewModel { // ViewModelProviderを使ってインスタンスを生成する return ViewModelProviders.of(...).get(MainViewModel::class.java) } } class MainActivity { @Inject lateinit var viewModel: MainViewModel ... } @Providesを使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。
また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。 このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。
class MainViewModel(...): ViewModel() or class MainViewModel @Inject constructor(...): ViewModel() @Module class MainActivityModule { @Provides fun provideViewModelFactory(.</description>
    </item>
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。
それが3.4.0-alpha07以降で改善される見込みです🎉
詳細はここにあります。https://issuetracker.google.com/issues/116541301
この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。
サンプルコードはここにあります😃
エラーログの変化 まずどのようなエラーログが出力されるかを見ていきます。 適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。
まずはData Binding 3.2.1から。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root, ^ symbol: class DataBindingComponent location: class MainAct79Binding e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol boolean attachToRoot, @Nullable DataBindingComponent component) { ^ ... ... ... Data Binding周りのエラーログが無限に出ます。悲しい😂
次に3.4.0-alpha07です。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass() ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃
クライアント側の対応 これに伴い、一部APIがdeprecatedになります。例えば、main_act.</description>
    </item>
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>LiveDataの値を更新したい時、MutableLiveDataを使うのが一般的だと思います。
class MainViewModel { val hoge = MutableLiveData&amp;lt;Int&amp;gt;() } この書き方だと、外のクラスから値を更新することが可能です。
val viewModel = MainViewModel() // ok viewModel.hoge.postValue(10000) 外のクラスからは更新出来ないようにするためにはLiveDataに型変換する必要があります。
例えば次のように書きます。
class MainViewModel { private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;() val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換 } こうすることで、外のクラスからはMutableLiveDataが直接見えなくなり、明示的に型変換をしない限りLiveDataの値を更新できなくなります。
ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。 なので、それの解決策を以下で紹介します。
その1 まずコードをのせます。
abstract class ViewModel2 { protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) { postValue(value) } protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) { setValue(value) } } // ViewModel2と同じパッケージに定義 public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; { @Override protected void postValue(T value) { super.</description>
    </item>
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description>ふとAACのViewModelのonClearedメソッドをテストしたくなったので、 3つのやりかたを紹介します。
環境は
&amp;#34;junit:junit:4.12&amp;#34; &amp;#34;androidx.test:rules:1.1.1&amp;#34; &amp;#34;androidx.test:runner:1.1.1&amp;#34; &amp;#34;androidx.test.ext:junit:1.1.0&amp;#34; &amp;#34;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;#34; &amp;#34;org.robolectric:robolectric:4.1&amp;#34; になります。
また、サンプルコードは satoshun-android-example/Testsにあるので、参考してください😊
1. ViewModelStoreを使う ViewModelProviders.of(activity).get(class)からViewModelを取得したときに、取得したViewModelはViewModelStoreにキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。
@RunWith(AndroidJUnit4::class) class BaseViewModelTest { @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java) @Test fun `dispose a coroutine when finished lifecycle of ViewModel`() { activityRule.activity.viewModelStore.clear() // ViewModelが開放される } } このテストはコード的には簡単ですが、ViewModelStoreがViewModelを管理していることを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。
なので、素直にonDestroyをコールするテストも書いてみます。
2. Instrumentation.callActivityOnDestroyを使う Instrumentationクラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。 InstrumentationはInstrumentationRegistryクラスから取得することができ、次のように書くことで、onDestroyをコールすることができます。
@Test fun `dispose a coroutine when finished lifecycle of ViewModel 2`() { // onDestroyがコールされViewModelが開放される InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity) } ActivityのonDestroyがコールされ、ViewModelのonClearedもコールされます！
以下追記
3. ActivityScenarioを使う 新しく追加されたActivityScenarioを使うとよりすっきりとonDestroyを表現することが出来ます。
@Test fun `dispose a coroutine when finished lifecycle of ViewModel 3`() { val scenario = ActivityScenario.</description>
    </item>
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。 ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。
このライブラリの機能に、safeargsというものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。
safeargsを使ってみる 一般的にFragmentに適当な値を渡すときはBundleを通して渡します。
// 呼び出し側 val bundle = Bundle() bundle.putInt(&amp;#34;step&amp;#34;, 10) // 呼び出され側 val step = arguments?.getInt(&amp;#34;step&amp;#34;) これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&amp;quot;step2&amp;quot;にしてしまうと、ランタイムエラーになります。
これを解決にするためにNavigationではsafe argsという機能を提供しています。 これは、DataBindingのように、クラスを生成することでtypesafeを実現します。
&amp;lt;navigation xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;&amp;gt; &amp;lt;fragment android:name=&amp;#34;com.example.android.codelabs.navigation.HogeFragment&amp;#34; android:label=&amp;#34;Hoge&amp;#34;&amp;gt; &amp;lt;argument android:name=&amp;#34;step&amp;#34; app:type=&amp;#34;integer&amp;#34; android:defaultValue=&amp;#34;1&amp;#34;/&amp;gt; &amp;lt;/fragment&amp;gt; &amp;lt;/navigation&amp;gt; とnavigationを記述すると、
public class HogeFragmentArgs { private int step = 1; private HogeFragmentArgs() { } public static HogeFragmentArgs fromBundle(Bundle bundle) { HogeFragmentArgs result = new HogeFragmentArgs(); if (bundle.containsKey(&amp;#34;step&amp;#34;)) { result.step = bundle.getInt(&amp;#34;step&amp;#34;); } return result; } public int getStep() { return step; } public Bundle toBundle() { Bundle __outBundle = new Bundle(); __outBundle.</description>
    </item>
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。 適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。
定義は以下のようになります。
fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; { // skip用の初期値を入れておく return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null } } fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) { // 最初の値は常にskipすることで、キャッシュを無視する val firstIgnore = AtomicBoolean(true) this.observe(owner, Observer { if (firstIgnore.getAndSet(false)) return@Observer observer(it) }) } 使う時はこんな感じで使います。
// TestViewModel.kt class TestViewModel: ViewModel() { val errorEvent = singleLiveData&amp;lt;String&amp;gt;() } // TestActivity.kt testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java) testViewModel.errorEvent.observeSingle(activity) { Log.d(&amp;#34;one&amp;#34;, it.toString()) } メリットはサブクラスを作らずに済むところです。
参考 https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16 </description>
    </item>
    
    <item>
      <title>LiveDataのpostValueは全て流れてくるとは限らない</title>
      <link>https://satoshun.github.io/2017/12/livedata-postvalue-unsafe/</link>
      <pubDate>Wed, 06 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/12/livedata-postvalue-unsafe/</guid>
      <description>結論 LiveData.postValueを短い間に複数回コールすると最後の値しかObseverに流れてこないことがある 背景 RxJavaのSubjectの代替としてMutableLiveData(postValueとsetValueがpublicになっている)を使っている部分があり、短い間に2回コールされたとき、全ての値が流れて欲しかったが何故か1回しか叩かれていなかった。 どこに原因があるか調査したところ、どうもpostValueメソッドの仕様(LiveDataクラス全体の仕様?)的に短い間に複数回コールされた場合は、最後にpostValueした値のみをpostするようになっていた。
実装詳細 LiveDataのpostValueのコードは以下のようになっています(v1.0.0)
protected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); } postValueメソッドでは
mPendingDataフィールドにObserverに渡すデータをセットする メインスレッドでmPostValueRunnableを実行する (ただしmPendingDataにまだ以前のデータが残っていたら、以前のデータを更新する) といったことをやっています。
このコードを見て分かる通り、前にセットしたmPendingDataがObserverに渡される前に、新しい値で上書きされる可能性があることが分かります。 よって、短い間に複数回のpostValueをコールすると最後の値のみしかObserverに流れてこない可能性があります。
まとめ RxJavaのSubjectのように、全ての値を流す動作を意図しているとハマる そもそもLiveDataは最新のViewの状態を保持する用途だと思うので、短い間に複数回コールされたら、最後の値のみを流すのは正しい。LiveDataは悪くない。悪いのは俺。 </description>
    </item>
    
    <item>
      <title>Android: Roomにおけるデータ変更通知の仕組みについて(InvalidationTracker)</title>
      <link>https://satoshun.github.io/2017/11/jetpack-room-invalidationtracker/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2017/11/jetpack-room-invalidationtracker/</guid>
      <description>こんにちはʕ•ӫ̫͡•ʔ
この記事ではどのようにしてRoomがテーブルの変更を検知し、LiveDataなどからデータの変更をオブザーバーに通知しているかについて説明します。
前置き/前提知識 RoomはGoogleが提供しているSQLiteをいい感じに扱うためのライブラリです。
RoomにはDao(Data access object)と呼ばれるインターフェース/抽象クラスがあり、そこを起点にクエリを実行します。
@Dao interface UserDao { @Query(&amp;#34;SELECT * FROM users&amp;#34;) fun getUsers(): Flowable&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; } 返り値として、observableデータ型を取ることができ、RoomではLiveDataとRxJava2の型(Flowableとか)などのobservable型サポートしています。
そして、LiveDataまたはFlowableで返り値を定義すると対象のテーブルがInsertなどで変更されたときに、変更通知を受け取ることが出来ます。
// クライアント側のコード userDao.getUsers() .subscribeOn(Schedulers.io) .subscribe { println(it) // ここが対象のテーブルが変更されるたびに評価される。 } テーブルの変更検知はRoomの内部クラスのInvalidationTrackerクラスで行っています。 これからInvalidationTrackerの内部実装を見ていきます。
InvalidationTrackerの流れ InvalidationTracker#startTrackingTableメソッドでTrigger(SQL)を生成 obsevableが生成されたら、対応するInvalidationTracker.Observer(変更通知用コールバック)をInvalidationTrackerに登録 RoomData#endTransactionのタイミングで各テーブルが更新されたかを確認 テーブルが更新されていたら変更通知コールバックを実行 というのが大まかな流れになります。2はobserver(変更通知用コールバック)を登録するだけ、4は登録したコールバックにデータを流すだけです。なので1, 3について詳しく見ていきます。
InvalidationTracker#startTrackingTableメソッドによりTriggerを生成する 最初に各テーブルのバージョンを管理する room_table_modification_logが生成されます。
CREATE TEMP TABLE room_table_modification_log ( version INTEGER PRIMARY KEY AUTOINCREMENT, table_id INTEGER ) このクエリの意味することは、テーブル操作があったときに、対象のテーブルのversionを更新するようにすることで、version変更されていたら更新を検知することが出来ます。このversionを更新するためにRoomではSQLにある機能の1つTriggerを使っています。具体的には次のTriggerを利用しています。
CREATE TEMP TRIGGER IF NOT EXISTS room_table_modification_trigger_users_UPDATE AFTER UPDATE ON users BEGIN INSERT OR REPLACE INTO room_table_modification_log VALUES (null, 0); # 0はtable_id END これは一見複雑に見えますがものすごい単純で、usersテーブルがUPDATEされたら上記のクエリがフックされて実行されるだけです。上のクエリINSERT OR REPLACE INTO room_table_modification_log VALUES (null, 0); は room_table_modification_logテーブルに最新のid + 1のrowを追加/更新するものになります。</description>
    </item>
    
  </channel>
</rss>
