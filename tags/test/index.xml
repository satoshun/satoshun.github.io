<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>test on stsnブログ</title>
    <link>https://satoshun.github.io/tags/test/</link>
    <description>Recent content in test on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sat, 23 Feb 2019 02:47:59 +0000</lastBuildDate><atom:link href="https://satoshun.github.io/tags/test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。 まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、AndroidJUnit4ランナーが使えるなど、かなりの部分が共通化出来ます。
この記事では、ユニットテストでActivity.onActivityResultのテストをどこまでandroid testのように書けるかを検証します。
テスト対象コード まず最初に、テスト対象コードは次のようになっています。
class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... button.setOnClickListener { startActivityForResult( Intent(this, Sub2Activity::class.java).apply { putExtra(&amp;#34;fuga&amp;#34;, &amp;#34;hoge&amp;#34;) }, 1 ) } } override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent? ) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == 1) { if (resultCode == Activity.RESULT_OK) { val value = data!!.getIntExtra(&amp;#34;test&amp;#34;, -1) button.text = value.toString() } } } } class Sub2Activity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>TruthはGoogleが開発をしているテストアサーションライブラリです。
従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。
 readableにアサーションが書ける デフォルトの失敗メッセージがわかりやすい  それぞれについて説明していきます。
readableにアサーションが書ける ドキュメントのbenefitにあるサンプルを取り上げ説明します。 http://google.github.io/truth/benefits
まず従来のJUnitスタイルを使って書きます。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertFalse(middleName.isPresent()); assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）
これがTruthを使うと次のようになります。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertThat(middleName).isAbsent(); assertThatはTruthに定義されているメソッドです。middleNameがabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。
上記のisAbsentはOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。 例えばIterableには、containsAnyInやisEmptyなどが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。
失敗メッセージがわかりやすい こちらもbenefitにあるサンプルを取り上げます。
まずは従来にJUnitスタイルから。
assertTrue(googleColors.contains(PINK)); この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。 失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。
次にTruthスタイルです。
assertThat(googleColors).contains(PINK); &amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。
以上がTruthのメリットになります。
補足 Truth-Androidライブラリ JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。 例えば、Intentには以下のアサーションメソッドを使うことが出来ます。
hasComponent hasComponentClass hasComponentPackage hasPackage hasAction hasNoAction hasData hasType extras categories hasFlags Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。
AssertJとの比較 これも公式ドキュメントにまとめてあります。http://google.github.io/truth/comparison
現状の主だった差分は次のようになっています。
 Truhtはまだ1.0.0になっていないのでAPIが変わる可能性がある TruthはChainスタイルで書くことを想定していない  これは現状のTruth哲学だが、AssertJのようなChainスタイルも普及してきたので、どちらが便利かはわからない    多少の差異はあれど、AssertJとTruthはとても似ているライブラリです。どちらか一方を使っているなら、乗り換えるメリットはおそらくないだろうという旨の内容です。</description>
    </item>
    
    <item>
      <title>Android: MVPのPresenterの非同期周りのユニットテストの書き方</title>
      <link>https://satoshun.github.io/2016/07/android-test-mvp/</link>
      <pubDate>Sun, 31 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/07/android-test-mvp/</guid>
      <description>MVP(Model-View-Presenter)アーキテクチャが流行ってますね!
MVPはテスタブルであることが1つのウリとなっていますが, 実際にPresenterのユニットテストをどのようにして書くかを紹介したいと思います.
今回のコードは https://github.com/satoshun-example/AndroidTestSample に上げてあるので, 良かったら見て下さい.
使うツール/ライブラリ  JUnit4 Mockito  今回, テスト書きたい箇所 今回は, MainPresenterクラスをテストします.
public class MainPresenter implements MainContract.Presenter { @NonNull private final UserDataSource dataSource; @NonNull private final MainContract.View view; public MainPresenter(@NonNull UserDataSource dataSource, @NonNull MainContract.View view) { this.dataSource = dataSource; this.view = view; } @Override public void start() { view.showLoadingIndicator(); dataSource.getUser(new UserDataSource.Callback() { @Override public void onUserLoaded(@NonNull User user) { view.hideLoadingIndicator(); view.showUser(user); } @Override public void onNotAvailable() { view.</description>
    </item>
    
    <item>
      <title>Android: テストメソッドの命名規則について</title>
      <link>https://satoshun.github.io/2016/02/android-test-method-naming-convention/</link>
      <pubDate>Fri, 12 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2016/02/android-test-method-naming-convention/</guid>
      <description>ソフトウェアの世界ではAndroidに限らず, テストを書くというのは非常に重要です.
ユニットテストの場合は, メソッドレベルでリグレッションが起きていないことを, 機能/受け入れテストの場合は, ユーザの行動レベルでリグレッションが起きていないことを保証するために必要になります.
今回の記事では, Androidにおけるユニットテスト(各テストメソッド)の命名規則の話をします. しかし, 他の言語/プラットフォームの場合でも同様の考え方を出来ると思います.
用語定義 アプリコード: アプリケーション本体のコード
なぜテストケースの命名規則を気にする必要があるか? Androidアプリを作っていて, アプリコードはリファクタリングや, 新機能の追加などで頻繁に目を通しますが, テストコードは1度書いたら, そのテストが失敗するまで放置するパターンが多いなと感じています(何にしてもアプリコードほどは目を通さない)
数週間前に書いたテストコードなんて忘れてしまうので, テストコードにはいろいろな情報をコメントなどで残しておく必要があります.
まず, テストケースの構成を考える 本題に入る前に, テストケースがどのような要素で構成されているかを説明をします.
一般的なテストケースは次の4つの要素に分割できます.
 事前準備(setup) 実行(exercise) 宣言(assertion) 後処理(teardown)  これだと分かりにくいので, コードで説明すると,
public class HogeTest { List&amp;lt;String&amp;gt; lists; @Before public void setup() { // 事前準備(setup)  lists = new ArrayList&amp;lt;&amp;gt;(); lists.add(&amp;#34;1&amp;#34;); lists.add(&amp;#34;123&amp;#34;); } @After public void teardown() { // 後処理(teardown)  } @Test public void testGet() { // 実行(exercise)  String actual = lists.</description>
    </item>
    
  </channel>
</rss>
