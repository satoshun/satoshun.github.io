<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coroutine on stsnブログ</title>
    <link>https://satoshun.github.io/tags/coroutine/</link>
    <description>Recent content in Coroutine on stsnブログ</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sat, 30 Jan 2021 07:20:42 +0000</lastBuildDate>
    <atom:link href="https://satoshun.github.io/tags/coroutine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kotlin: RxJava -&gt; Coroutineへの置き換えに使えるMigration.ktの紹介</title>
      <link>https://satoshun.github.io/2021/01/coroutine-migration-from-rxjava/</link>
      <pubDate>Sat, 30 Jan 2021 07:20:42 +0000</pubDate>
      <guid>https://satoshun.github.io/2021/01/coroutine-migration-from-rxjava/</guid>
      <description>&lt;p&gt;Kotlin Coroutineには &lt;a href=&#34;https://github.com/Kotlin/kotlinx.coroutines/blob/e16eb9d315cbee42bcadb438a8d62b10f65a9aa4/kotlinx-coroutines-core/common/src/flow/Migration.kt&#34;&gt;Migration.kt&lt;/a&gt; が用意されており、RxJavaからCoroutineへの置き換えを手伝ってくれます。この記事では、どのように使うかを説明します。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;例として、次のRxJavaを使ったクラスがあるとします。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; io.reactivex.Observable&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestRepository&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUser&lt;/span&gt;(): Observable&amp;lt;User&amp;gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これは、次のように使うことが出来ます。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; disposble = repository.getUser()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .subscribeOn(&lt;span style=&#34;color:#a6e22e&#34;&gt;Schedulers&lt;/span&gt;.io())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .subscribe(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { println(&lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;) },&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    { println(&lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;) }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  )&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Kotlin: FlowのflowOnオペレータの挙動</title>
      <link>https://satoshun.github.io/2020/01/coroutine-flowon/</link>
      <pubDate>Mon, 13 Jan 2020 11:47:10 +0000</pubDate>
      <guid>https://satoshun.github.io/2020/01/coroutine-flowon/</guid>
      <description>&lt;p&gt;CoroutineのFlowにはflowOnオペレータが定義されており、実行コンテキストを変更することが出来ます。&lt;/p&gt;&#xA;&lt;p&gt;この記事はRxJava2のsubscribeOnとの挙動の違いを見ていきたいと思います。&lt;/p&gt;&#xA;&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;&#xA;&lt;p&gt;まずは、Flowから。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;withContext(&lt;span style=&#34;color:#a6e22e&#34;&gt;Dispatchers&lt;/span&gt;.Main) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  flowOf(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .map {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Dispatchers.Defaultで動く&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${Thread.currentThread()}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .flowOn(&lt;span style=&#34;color:#a6e22e&#34;&gt;Dispatchers&lt;/span&gt;.Default)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .map {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Dispatchers.Mainで動く&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${Thread.currentThread()}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .collect {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Dispatchers.Mainで動く&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${Thread.currentThread()}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>ViewModelとKotlin Coroutinesの書き方あれこれ</title>
      <link>https://satoshun.github.io/2019/12/android-viewodel-kotlin-coroutine/</link>
      <pubDate>Sun, 15 Dec 2019 07:15:43 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/12/android-viewodel-kotlin-coroutine/</guid>
      <description>&lt;p&gt;ViewModel + Kotlin Coroutineを使う場合、どんな感じでViewModelでCoroutineを表現するかについてあれこれ書いてみました。&lt;/p&gt;&#xA;&lt;p&gt;MVVM + Repositoryを想定しており、UIに反映する部分はLiveDataを考えています。&lt;/p&gt;&#xA;&lt;p&gt;環境は&lt;code&gt;androidx.lifecycle:lifecycle-viewmodel-ktx&lt;/code&gt;は2.2.0-rc03、Coroutineは1.3.3です。&lt;/p&gt;&#xA;&lt;p&gt;この記事は次の順序で進んでいきます。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;viewModelScopeとは?&lt;/li&gt;&#xA;&lt;li&gt;suspend関数をコールするとき&lt;/li&gt;&#xA;&lt;li&gt;Flowをコール/購読するとき&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;viewmodelscopeとは&#34;&gt;viewModelScopeとは?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;androidx.lifecycle:lifecycle-viewmodel-ktx&lt;/code&gt;ライブラリには、viewModelScope拡張関数が含まれています。定義は次の通りです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * [CoroutineScope] tied to this [ViewModel].&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; ViewModel.viewModelScope: CoroutineScope&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ViewModelのライフサイクルに合わせたCoroutineScopeを取得することが出来ます。&#xA;このスコープ上でCoroutineを実行すれば、ViewModelの破棄に合わせて、自動でdisposeしてくれます。&lt;/p&gt;&#xA;&lt;p&gt;また、&lt;code&gt;viewModelScope&lt;/code&gt;は、メインスレッド上で実行してくれるため、&lt;code&gt;LiveData.setValue&lt;/code&gt;を使い、値を更新します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin: FlowのBufferの指定について</title>
      <link>https://satoshun.github.io/2019/08/flow-buffer/</link>
      <pubDate>Sat, 03 Aug 2019 23:37:02 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/08/flow-buffer/</guid>
      <description>&lt;p&gt;CoroutineのFlowにはBufferを指定することができます。Bufferの指定によってどのように動作が変わるかを試してみました。&lt;/p&gt;&#xA;&lt;p&gt;この記事は、少しFlowを触ったことあるぞ！って言う人向けになります。また、検証はCoroutine 1.3.0-RCで行っております。&lt;/p&gt;&#xA;&lt;h2 id=&#34;bufferの種類&#34;&gt;Bufferの種類&lt;/h2&gt;&#xA;&lt;p&gt;Bufferの種類は5つあります。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UNLIMITED&lt;/li&gt;&#xA;&lt;li&gt;RENDEZVOUS&lt;/li&gt;&#xA;&lt;li&gt;CONFLATED&lt;/li&gt;&#xA;&lt;li&gt;BUFFERED&lt;/li&gt;&#xA;&lt;li&gt;50、100などの、具体的な値&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実質、BUFFEREDと同じ挙動をする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;検証コード&#34;&gt;検証コード&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// flowストリームの作成&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; f = flow {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  repeat(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$it&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// observeする&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;lifecycleScope.launch {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  f&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .buffer(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.) ここでBufferを指定する&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .collect {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      delay(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;Log&lt;/span&gt;.d(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;t4&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$it&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Retrofit: Coroutineを使うときの、Response&lt;T&gt;と生のTの使い分け</title>
      <link>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</link>
      <pubDate>Tue, 02 Jul 2019 13:46:54 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</guid>
      <description>&lt;p&gt;psideさんの、&lt;a href=&#34;https://qiita.com/pside/items/e546f0f12989e8dcd729&#34;&gt;Retrofit2でRxJavaを使う時の Result&lt;T&gt;, Response&lt;T&gt;, そのままT の使い分け所感&lt;/a&gt;のCoroutineバージョンの記事となります。&lt;/p&gt;&#xA;&lt;p&gt;上記の記事に書いてある、Rxとは違い、Result型は用意されていないので、Response型で包むか、生で値ｗ受け取るかのどちらかが基本となります。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HogeService&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getHoge&lt;/span&gt;(): Hoge&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    or&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getHoge&lt;/span&gt;(): Response&amp;lt;Hoge&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Retrofitの2.6.0で、挙動の違いを確認しました。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;生&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Response&lt;T&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;200&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;成功&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;成功&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;404&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;例外&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;成功&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ネットワークに繋がっていない&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;例外&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;例外&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;シリアライズが出来ない（型がおかしい）&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;例外&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;例外&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生の場合、HTTPのstatus Code的に失敗とされるものは例外になる&lt;/li&gt;&#xA;&lt;li&gt;Response型で包めば、HTTPのstatus Code的に失敗だとしても例外が発生しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;っていう感じの挙動になります。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>&lt;p&gt;Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;launch {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task1 = async { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task1() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task2 = async { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task2() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${task1.await()}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${task2.await()}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;asyncで包むことで、並列に処理をすることができます。&lt;/p&gt;&#xA;&lt;p&gt;次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元で&lt;code&gt;runCatching&lt;/code&gt;を使います。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;launch {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task1 = async { runCatching { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task1() } }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; task2 = async { runCatching { &lt;span style=&#34;color:#a6e22e&#34;&gt;MainService&lt;/span&gt;.task2() } }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result1 = task1.await()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result2 = task2.await()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$result1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; + &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$result2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 +0000</pubDate>
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>&lt;p&gt;Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、&#xA;どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。&lt;/p&gt;&#xA;&lt;p&gt;以下、&lt;del&gt;2019年3月10日&lt;/del&gt; 2019年3月11日の調査結果になります。&#xA;また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。&lt;/p&gt;&#xA;&lt;p&gt;Lifecycle&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Lifecycleに従うCoroutineScopeの生成&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; Lifecycle.coroutineScope: CoroutineScope&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LifecycleOwner&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// LifecycleOwnerに従うCoroutineScopeの生成&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; LifecycleOwner.lifecycleScope: CoroutineScope&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ViewModel&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ViewModelに従うCoroutineScopeの生成&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; ViewModel.viewModelScope: CoroutineScope&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;WorkManager&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CoroutineWorker&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  appContext: Context,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  params: WorkerParameters&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) : ListenableWorker(appContext, params) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// suspendメソッドで定義された&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doWork&lt;/span&gt;(): Result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>&lt;p&gt;Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、&lt;code&gt;ContinuationInterceptor&lt;/code&gt;を使えば上手くいきそうです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;continuationinterceptorとは&#34;&gt;ContinuationInterceptorとは?&lt;/h2&gt;&#xA;&lt;p&gt;ContinuationInterceptorは次のようなインターフェースです。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Marks coroutine context element that intercepts coroutine continuations.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * intercepts all coroutine continuations with [interceptContinuation] invocations.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@SinceKotlin&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1.3&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ContinuationInterceptor&lt;/span&gt; : &lt;span style=&#34;color:#a6e22e&#34;&gt;CoroutineContext&lt;/span&gt;.Element {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;interceptContinuation&lt;/span&gt;(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;releaseInterceptedContinuation&lt;/span&gt;(continuation: Continuation&amp;lt;*&amp;gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 計測方法は実環境に全く即していないので意味がない可能性が高いです。&lt;/p&gt;&#xA;&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AGP3.4.0-alpha06&lt;/li&gt;&#xA;&lt;li&gt;Kotlin 1.3.10&lt;/li&gt;&#xA;&lt;li&gt;Kotlinx.coroutine 1.0.1&lt;/li&gt;&#xA;&lt;li&gt;Gradle 5.0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;比較対象&#34;&gt;比較対象&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kotlinx.coroutineを使ったサンプル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラス数 300&lt;/li&gt;&#xA;&lt;li&gt;各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;300 * 7の2100箇所がCoroutine関連のコードになります&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;kotlinx.coroutineを使わないサンプル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラス数 300&lt;/li&gt;&#xA;&lt;li&gt;各クラスは7つのメソッドを持ち、その中で適当なメソッド（&lt;code&gt;Handler().post {}&lt;/code&gt;）をコールしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/CoroutineBuildPerfExample&#34;&gt;サンプルコード&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;計測コマンド&#34;&gt;計測コマンド&lt;/h3&gt;&#xA;&lt;p&gt;Build Scanを使って計測します。その際。build-cacheはoffにします。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./gradlew clean&#xA;./gradlew build --no-build-cache --scan&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。&#xA;また試行回数は10回程度で、最終結果のみを以下に掲載します。&lt;/p&gt;&#xA;&lt;h2 id=&#34;kotlinxcoroutineを使う&#34;&gt;kotlinx.coroutineを使う&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Time spent executing tasks 1m 16.034s&#xA;    All tasks&#x9;207&#x9;2m 42.833s&#xA;    Tasks avoided&#x9;12 (09.7%)&#x9;0.062s&#xA;    From cache&#x9;0 (00.0%)&#x9;0.000s&#xA;    Up-to-date&#x9;12 (09.7%)&#x9;0.062s&#xA;    Tasks executed&#x9;112 (90.3%)&#x9;2m 42.739s&#xA;    Cacheable&#x9;0 (00.0%)&#x9;0.000s&#xA;    Not cacheable&#x9;112 (90.3%)&#x9;2m 42.739s&#xA;    Lifecycle&#x9;45&#x9;0.023s&#xA;    No source&#x9;38&#x9;0.009s&#xA;    Skipped&#x9;0&#x9;0.000s&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
